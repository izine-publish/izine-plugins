/* soapC.cpp
   Generated by gSOAP 2.7.13 from server.h
   Copyright(C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.13 2011-07-26 12:24:25 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_wsse__FaultcodeEnum:
		return soap_in_wsse__FaultcodeEnum(soap, NULL, NULL, "wsse:FaultcodeEnum");
	case SOAP_TYPE_wsu__tTimestampFault:
		return soap_in_wsu__tTimestampFault(soap, NULL, NULL, "wsu:tTimestampFault");
	case SOAP_TYPE_wsa__FaultSubcodeValues:
		return soap_in_wsa__FaultSubcodeValues(soap, NULL, NULL, "wsa:FaultSubcodeValues");
	case SOAP_TYPE_wsa__RelationshipTypeValues:
		return soap_in_wsa__RelationshipTypeValues(soap, NULL, NULL, "wsa:RelationshipTypeValues");
	case SOAP_TYPE_ns3__ArrayOfLockDTO:
		return soap_in_ns3__ArrayOfLockDTO(soap, NULL, NULL, "ns3:ArrayOfLockDTO");
	case SOAP_TYPE_ns3__StatusDTO:
		return soap_in_ns3__StatusDTO(soap, NULL, NULL, "ns3:StatusDTO");
	case SOAP_TYPE_ns3__ArrayOfStatusDTO:
		return soap_in_ns3__ArrayOfStatusDTO(soap, NULL, NULL, "ns3:ArrayOfStatusDTO");
	case SOAP_TYPE_ns3__TitleStatusDTO:
		return soap_in_ns3__TitleStatusDTO(soap, NULL, NULL, "ns3:TitleStatusDTO");
	case SOAP_TYPE_ns3__ArrayOfTitleStatusDTO:
		return soap_in_ns3__ArrayOfTitleStatusDTO(soap, NULL, NULL, "ns3:ArrayOfTitleStatusDTO");
	case SOAP_TYPE_ns3__EditionTitlesDTO:
		return soap_in_ns3__EditionTitlesDTO(soap, NULL, NULL, "ns3:EditionTitlesDTO");
	case SOAP_TYPE_ns3__ArrayOfEditionTitlesDTO:
		return soap_in_ns3__ArrayOfEditionTitlesDTO(soap, NULL, NULL, "ns3:ArrayOfEditionTitlesDTO");
	case SOAP_TYPE_ns3__ArrayOfTaskDTO:
		return soap_in_ns3__ArrayOfTaskDTO(soap, NULL, NULL, "ns3:ArrayOfTaskDTO");
	case SOAP_TYPE_ns3__VersionDTO:
		return soap_in_ns3__VersionDTO(soap, NULL, NULL, "ns3:VersionDTO");
	case SOAP_TYPE_ns3__ArrayOfAssetDTO:
		return soap_in_ns3__ArrayOfAssetDTO(soap, NULL, NULL, "ns3:ArrayOfAssetDTO");
	case SOAP_TYPE_ns3__ArrayOfGuid:
		return soap_in_ns3__ArrayOfGuid(soap, NULL, NULL, "ns3:ArrayOfGuid");
	case SOAP_TYPE_ns3__VersionInfo:
		return soap_in_ns3__VersionInfo(soap, NULL, NULL, "ns3:VersionInfo");
	case SOAP_TYPE_ns3__AssetDTO:
		return soap_in_ns3__AssetDTO(soap, NULL, NULL, "ns3:AssetDTO");
	case SOAP_TYPE_ns3__LockDTO:
		return soap_in_ns3__LockDTO(soap, NULL, NULL, "ns3:LockDTO");
	case SOAP_TYPE_ns3__ShelveDTO:
		return soap_in_ns3__ShelveDTO(soap, NULL, NULL, "ns3:ShelveDTO");
	case SOAP_TYPE_ns3__ArrayOfShelveDTO:
		return soap_in_ns3__ArrayOfShelveDTO(soap, NULL, NULL, "ns3:ArrayOfShelveDTO");
	case SOAP_TYPE_ns3__ArrayOfString:
		return soap_in_ns3__ArrayOfString(soap, NULL, NULL, "ns3:ArrayOfString");
	case SOAP_TYPE_ns3__CommentDTO:
		return soap_in_ns3__CommentDTO(soap, NULL, NULL, "ns3:CommentDTO");
	case SOAP_TYPE_ns3__ArrayOfCommentDTO:
		return soap_in_ns3__ArrayOfCommentDTO(soap, NULL, NULL, "ns3:ArrayOfCommentDTO");
	case SOAP_TYPE_ns3__ConstantDTO:
		return soap_in_ns3__ConstantDTO(soap, NULL, NULL, "ns3:ConstantDTO");
	case SOAP_TYPE_ns3__TitleDTO:
		return soap_in_ns3__TitleDTO(soap, NULL, NULL, "ns3:TitleDTO");
	case SOAP_TYPE_ns3__ArrayOfTitleDTO:
		return soap_in_ns3__ArrayOfTitleDTO(soap, NULL, NULL, "ns3:ArrayOfTitleDTO");
	case SOAP_TYPE_ns3__TaskUpdateInfo:
		return soap_in_ns3__TaskUpdateInfo(soap, NULL, NULL, "ns3:TaskUpdateInfo");
	case SOAP_TYPE_ns3__TaskDTO:
		return soap_in_ns3__TaskDTO(soap, NULL, NULL, "ns3:TaskDTO");
	case SOAP_TYPE_ns3__IdNameDTO:
		return soap_in_ns3__IdNameDTO(soap, NULL, NULL, "ns3:IdNameDTO");
	case SOAP_TYPE_ns3__ArrayOfIdNameDTO:
		return soap_in_ns3__ArrayOfIdNameDTO(soap, NULL, NULL, "ns3:ArrayOfIdNameDTO");
	case SOAP_TYPE_ns3__UserDTO:
		return soap_in_ns3__UserDTO(soap, NULL, NULL, "ns3:UserDTO");
	case SOAP_TYPE_ns3__ArrayOfUserDTO:
		return soap_in_ns3__ArrayOfUserDTO(soap, NULL, NULL, "ns3:ArrayOfUserDTO");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_ds__RSAKeyValueType:
		return soap_in_ds__RSAKeyValueType(soap, NULL, NULL, "ds:RSAKeyValueType");
	case SOAP_TYPE_ds__DSAKeyValueType:
		return soap_in_ds__DSAKeyValueType(soap, NULL, NULL, "ds:DSAKeyValueType");
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return soap_in_ds__X509IssuerSerialType(soap, NULL, NULL, "ds:X509IssuerSerialType");
	case SOAP_TYPE_ds__X509DataType:
		return soap_in_ds__X509DataType(soap, NULL, NULL, "ds:X509DataType");
	case SOAP_TYPE_ds__RetrievalMethodType:
		return soap_in_ds__RetrievalMethodType(soap, NULL, NULL, "ds:RetrievalMethodType");
	case SOAP_TYPE_ds__KeyValueType:
		return soap_in_ds__KeyValueType(soap, NULL, NULL, "ds:KeyValueType");
	case SOAP_TYPE_ds__DigestMethodType:
		return soap_in_ds__DigestMethodType(soap, NULL, NULL, "ds:DigestMethodType");
	case SOAP_TYPE_ds__TransformType:
		return soap_in_ds__TransformType(soap, NULL, NULL, "ds:TransformType");
	case SOAP_TYPE_ds__TransformsType:
		return soap_in_ds__TransformsType(soap, NULL, NULL, "ds:TransformsType");
	case SOAP_TYPE_ds__ReferenceType:
		return soap_in_ds__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_ds__SignatureMethodType:
		return soap_in_ds__SignatureMethodType(soap, NULL, NULL, "ds:SignatureMethodType");
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return soap_in_ds__CanonicalizationMethodType(soap, NULL, NULL, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_ds__KeyInfoType:
		return soap_in_ds__KeyInfoType(soap, NULL, NULL, "ds:KeyInfoType");
	case SOAP_TYPE_ds__SignedInfoType:
		return soap_in_ds__SignedInfoType(soap, NULL, NULL, "ds:SignedInfoType");
	case SOAP_TYPE_ds__SignatureType:
		return soap_in_ds__SignatureType(soap, NULL, NULL, "ds:SignatureType");
	case SOAP_TYPE_wsa__Relationship:
		return soap_in_wsa__Relationship(soap, NULL, NULL, "wsa:Relationship");
	case SOAP_TYPE_wsa__ServiceNameType:
		return soap_in_wsa__ServiceNameType(soap, NULL, NULL, "wsa:ServiceNameType");
	case SOAP_TYPE_wsa__ReferenceParametersType:
		return soap_in_wsa__ReferenceParametersType(soap, NULL, NULL, "wsa:ReferenceParametersType");
	case SOAP_TYPE_wsa__ReferencePropertiesType:
		return soap_in_wsa__ReferencePropertiesType(soap, NULL, NULL, "wsa:ReferencePropertiesType");
	case SOAP_TYPE_wsa__EndpointReferenceType:
		return soap_in_wsa__EndpointReferenceType(soap, NULL, NULL, "wsa:EndpointReferenceType");
	case SOAP_TYPE_wsrp__fault_USCOREt:
		return soap_in_wsrp__fault_USCOREt(soap, NULL, NULL, "wsrp:fault_t");
	case SOAP_TYPE_wsrp__found_USCOREt:
		return soap_in_wsrp__found_USCOREt(soap, NULL, NULL, "wsrp:found_t");
	case SOAP_TYPE_wsrp__rev_USCOREt:
		return soap_in_wsrp__rev_USCOREt(soap, NULL, NULL, "wsrp:rev_t");
	case SOAP_TYPE_wsrp__fwd_USCOREt:
		return soap_in_wsrp__fwd_USCOREt(soap, NULL, NULL, "wsrp:fwd_t");
	case SOAP_TYPE_wsrp__via_USCOREt:
		return soap_in_wsrp__via_USCOREt(soap, NULL, NULL, "wsrp:via_t");
	case SOAP_TYPE_wsrp__path_USCOREt:
		return soap_in_wsrp__path_USCOREt(soap, NULL, NULL, "wsrp:path_t");
	case SOAP_TYPE_PointerTo_ns3__DownloadVersionResponse:
		return soap_in_PointerTo_ns3__DownloadVersionResponse(soap, NULL, NULL, "ns3:DownloadVersionResponse");
	case SOAP_TYPE_PointerTo_ns3__DownloadVersion:
		return soap_in_PointerTo_ns3__DownloadVersion(soap, NULL, NULL, "ns3:DownloadVersion");
	case SOAP_TYPE_PointerTo_ns3__CheckInAssetResponse:
		return soap_in_PointerTo_ns3__CheckInAssetResponse(soap, NULL, NULL, "ns3:CheckInAssetResponse");
	case SOAP_TYPE_PointerTo_ns3__CheckInAsset:
		return soap_in_PointerTo_ns3__CheckInAsset(soap, NULL, NULL, "ns3:CheckInAsset");
	case SOAP_TYPE_PointerTo_ns3__GetLockResponse:
		return soap_in_PointerTo_ns3__GetLockResponse(soap, NULL, NULL, "ns3:GetLockResponse");
	case SOAP_TYPE_PointerTo_ns3__GetLock:
		return soap_in_PointerTo_ns3__GetLock(soap, NULL, NULL, "ns3:GetLock");
	case SOAP_TYPE_PointerTo_ns3__UpdateAssetStatusResponse:
		return soap_in_PointerTo_ns3__UpdateAssetStatusResponse(soap, NULL, NULL, "ns3:UpdateAssetStatusResponse");
	case SOAP_TYPE_PointerTo_ns3__UpdateAssetStatus:
		return soap_in_PointerTo_ns3__UpdateAssetStatus(soap, NULL, NULL, "ns3:UpdateAssetStatus");
	case SOAP_TYPE_PointerTo_ns3__UpdateAssetResponse:
		return soap_in_PointerTo_ns3__UpdateAssetResponse(soap, NULL, NULL, "ns3:UpdateAssetResponse");
	case SOAP_TYPE_PointerTo_ns3__UpdateAsset:
		return soap_in_PointerTo_ns3__UpdateAsset(soap, NULL, NULL, "ns3:UpdateAsset");
	case SOAP_TYPE_PointerTo_ns3__GetAssetListResponse:
		return soap_in_PointerTo_ns3__GetAssetListResponse(soap, NULL, NULL, "ns3:GetAssetListResponse");
	case SOAP_TYPE_PointerTo_ns3__GetAssetList:
		return soap_in_PointerTo_ns3__GetAssetList(soap, NULL, NULL, "ns3:GetAssetList");
	case SOAP_TYPE_PointerTo_ns3__GetStatusByTitleResponse:
		return soap_in_PointerTo_ns3__GetStatusByTitleResponse(soap, NULL, NULL, "ns3:GetStatusByTitleResponse");
	case SOAP_TYPE_PointerTo_ns3__GetStatusByTitle:
		return soap_in_PointerTo_ns3__GetStatusByTitle(soap, NULL, NULL, "ns3:GetStatusByTitle");
	case SOAP_TYPE_PointerTo_ns3__GetEditionsByTitleResponse:
		return soap_in_PointerTo_ns3__GetEditionsByTitleResponse(soap, NULL, NULL, "ns3:GetEditionsByTitleResponse");
	case SOAP_TYPE_PointerTo_ns3__GetEditionsByTitle:
		return soap_in_PointerTo_ns3__GetEditionsByTitle(soap, NULL, NULL, "ns3:GetEditionsByTitle");
	case SOAP_TYPE_PointerTo_ns3__CheckOutAssetResponse:
		return soap_in_PointerTo_ns3__CheckOutAssetResponse(soap, NULL, NULL, "ns3:CheckOutAssetResponse");
	case SOAP_TYPE_PointerTo_ns3__CheckOutAsset:
		return soap_in_PointerTo_ns3__CheckOutAsset(soap, NULL, NULL, "ns3:CheckOutAsset");
	case SOAP_TYPE_PointerTo_ns3__GetEditionTaskListResponse:
		return soap_in_PointerTo_ns3__GetEditionTaskListResponse(soap, NULL, NULL, "ns3:GetEditionTaskListResponse");
	case SOAP_TYPE_PointerTo_ns3__GetEditionTaskList:
		return soap_in_PointerTo_ns3__GetEditionTaskList(soap, NULL, NULL, "ns3:GetEditionTaskList");
	case SOAP_TYPE_PointerTo_ns3__RelinkAssetResponse:
		return soap_in_PointerTo_ns3__RelinkAssetResponse(soap, NULL, NULL, "ns3:RelinkAssetResponse");
	case SOAP_TYPE_PointerTo_ns3__RelinkAsset:
		return soap_in_PointerTo_ns3__RelinkAsset(soap, NULL, NULL, "ns3:RelinkAsset");
	case SOAP_TYPE_PointerTo_ns3__UnlinkAssetResponse:
		return soap_in_PointerTo_ns3__UnlinkAssetResponse(soap, NULL, NULL, "ns3:UnlinkAssetResponse");
	case SOAP_TYPE_PointerTo_ns3__UnlinkAsset:
		return soap_in_PointerTo_ns3__UnlinkAsset(soap, NULL, NULL, "ns3:UnlinkAsset");
	case SOAP_TYPE_PointerTo_ns3__UploadExportResponse:
		return soap_in_PointerTo_ns3__UploadExportResponse(soap, NULL, NULL, "ns3:UploadExportResponse");
	case SOAP_TYPE_PointerTo_ns3__UploadExport:
		return soap_in_PointerTo_ns3__UploadExport(soap, NULL, NULL, "ns3:UploadExport");
	case SOAP_TYPE_PointerTo_ns3__UploadVersionResponse:
		return soap_in_PointerTo_ns3__UploadVersionResponse(soap, NULL, NULL, "ns3:UploadVersionResponse");
	case SOAP_TYPE_PointerTo_ns3__UploadVersion:
		return soap_in_PointerTo_ns3__UploadVersion(soap, NULL, NULL, "ns3:UploadVersion");
	case SOAP_TYPE_PointerTo_ns3__UploadPageResponse:
		return soap_in_PointerTo_ns3__UploadPageResponse(soap, NULL, NULL, "ns3:UploadPageResponse");
	case SOAP_TYPE_PointerTo_ns3__UploadPage:
		return soap_in_PointerTo_ns3__UploadPage(soap, NULL, NULL, "ns3:UploadPage");
	case SOAP_TYPE_PointerTo_ns3__UploadPDFResponse:
		return soap_in_PointerTo_ns3__UploadPDFResponse(soap, NULL, NULL, "ns3:UploadPDFResponse");
	case SOAP_TYPE_PointerTo_ns3__UploadPDF:
		return soap_in_PointerTo_ns3__UploadPDF(soap, NULL, NULL, "ns3:UploadPDF");
	case SOAP_TYPE_PointerTo_ns3__GetAssetResponse:
		return soap_in_PointerTo_ns3__GetAssetResponse(soap, NULL, NULL, "ns3:GetAssetResponse");
	case SOAP_TYPE_PointerTo_ns3__GetAsset:
		return soap_in_PointerTo_ns3__GetAsset(soap, NULL, NULL, "ns3:GetAsset");
	case SOAP_TYPE_PointerTo_ns3__CanUpdateAssetNameResponse:
		return soap_in_PointerTo_ns3__CanUpdateAssetNameResponse(soap, NULL, NULL, "ns3:CanUpdateAssetNameResponse");
	case SOAP_TYPE_PointerTo_ns3__CanUpdateAssetName:
		return soap_in_PointerTo_ns3__CanUpdateAssetName(soap, NULL, NULL, "ns3:CanUpdateAssetName");
	case SOAP_TYPE_PointerTo_ns3__UpdateAssetNameResponse:
		return soap_in_PointerTo_ns3__UpdateAssetNameResponse(soap, NULL, NULL, "ns3:UpdateAssetNameResponse");
	case SOAP_TYPE_PointerTo_ns3__UpdateAssetName:
		return soap_in_PointerTo_ns3__UpdateAssetName(soap, NULL, NULL, "ns3:UpdateAssetName");
	case SOAP_TYPE_PointerTo_ns3__CreateAssetResponse:
		return soap_in_PointerTo_ns3__CreateAssetResponse(soap, NULL, NULL, "ns3:CreateAssetResponse");
	case SOAP_TYPE_PointerTo_ns3__CreateAsset:
		return soap_in_PointerTo_ns3__CreateAsset(soap, NULL, NULL, "ns3:CreateAsset");
	case SOAP_TYPE_PointerTo_ns3__DeleteAssetResponse:
		return soap_in_PointerTo_ns3__DeleteAssetResponse(soap, NULL, NULL, "ns3:DeleteAssetResponse");
	case SOAP_TYPE_PointerTo_ns3__DeleteAsset:
		return soap_in_PointerTo_ns3__DeleteAsset(soap, NULL, NULL, "ns3:DeleteAsset");
	case SOAP_TYPE_PointerTo_ns3__UnlockAssetResponse:
		return soap_in_PointerTo_ns3__UnlockAssetResponse(soap, NULL, NULL, "ns3:UnlockAssetResponse");
	case SOAP_TYPE_PointerTo_ns3__UnlockAsset:
		return soap_in_PointerTo_ns3__UnlockAsset(soap, NULL, NULL, "ns3:UnlockAsset");
	case SOAP_TYPE_PointerTo_ns3__LockAssetResponse:
		return soap_in_PointerTo_ns3__LockAssetResponse(soap, NULL, NULL, "ns3:LockAssetResponse");
	case SOAP_TYPE_PointerTo_ns3__LockAsset:
		return soap_in_PointerTo_ns3__LockAsset(soap, NULL, NULL, "ns3:LockAsset");
	case SOAP_TYPE_PointerTo_ns3__GetThumbnailResponse:
		return soap_in_PointerTo_ns3__GetThumbnailResponse(soap, NULL, NULL, "ns3:GetThumbnailResponse");
	case SOAP_TYPE_PointerTo_ns3__GetThumbnail:
		return soap_in_PointerTo_ns3__GetThumbnail(soap, NULL, NULL, "ns3:GetThumbnail");
	case SOAP_TYPE_PointerTo_ns3__GetUserResponse:
		return soap_in_PointerTo_ns3__GetUserResponse(soap, NULL, NULL, "ns3:GetUserResponse");
	case SOAP_TYPE_PointerTo_ns3__GetUser:
		return soap_in_PointerTo_ns3__GetUser(soap, NULL, NULL, "ns3:GetUser");
	case SOAP_TYPE_PointerTo_ns3__LogoffResponse:
		return soap_in_PointerTo_ns3__LogoffResponse(soap, NULL, NULL, "ns3:LogoffResponse");
	case SOAP_TYPE_PointerTo_ns3__Logoff:
		return soap_in_PointerTo_ns3__Logoff(soap, NULL, NULL, "ns3:Logoff");
	case SOAP_TYPE_PointerTo_ns3__GetShelveListResponse:
		return soap_in_PointerTo_ns3__GetShelveListResponse(soap, NULL, NULL, "ns3:GetShelveListResponse");
	case SOAP_TYPE_PointerTo_ns3__GetShelveList:
		return soap_in_PointerTo_ns3__GetShelveList(soap, NULL, NULL, "ns3:GetShelveList");
	case SOAP_TYPE_PointerTo_ns3__GetTagsResponse:
		return soap_in_PointerTo_ns3__GetTagsResponse(soap, NULL, NULL, "ns3:GetTagsResponse");
	case SOAP_TYPE_PointerTo_ns3__GetTags:
		return soap_in_PointerTo_ns3__GetTags(soap, NULL, NULL, "ns3:GetTags");
	case SOAP_TYPE_PointerTo_ns3__GetCommentListResponse:
		return soap_in_PointerTo_ns3__GetCommentListResponse(soap, NULL, NULL, "ns3:GetCommentListResponse");
	case SOAP_TYPE_PointerTo_ns3__GetCommentList:
		return soap_in_PointerTo_ns3__GetCommentList(soap, NULL, NULL, "ns3:GetCommentList");
	case SOAP_TYPE_PointerTo_ns3__GetRoleResponse:
		return soap_in_PointerTo_ns3__GetRoleResponse(soap, NULL, NULL, "ns3:GetRoleResponse");
	case SOAP_TYPE_PointerTo_ns3__GetRole:
		return soap_in_PointerTo_ns3__GetRole(soap, NULL, NULL, "ns3:GetRole");
	case SOAP_TYPE_PointerTo_ns3__GetTitleListResponse:
		return soap_in_PointerTo_ns3__GetTitleListResponse(soap, NULL, NULL, "ns3:GetTitleListResponse");
	case SOAP_TYPE_PointerTo_ns3__GetTitleList:
		return soap_in_PointerTo_ns3__GetTitleList(soap, NULL, NULL, "ns3:GetTitleList");
	case SOAP_TYPE_PointerTo_ns3__LoginResponse:
		return soap_in_PointerTo_ns3__LoginResponse(soap, NULL, NULL, "ns3:LoginResponse");
	case SOAP_TYPE_PointerTo_ns3__Login:
		return soap_in_PointerTo_ns3__Login(soap, NULL, NULL, "ns3:Login");
	case SOAP_TYPE_PointerTo_ns3__DeleteTaskResponse:
		return soap_in_PointerTo_ns3__DeleteTaskResponse(soap, NULL, NULL, "ns3:DeleteTaskResponse");
	case SOAP_TYPE_PointerTo_ns3__DeleteTask:
		return soap_in_PointerTo_ns3__DeleteTask(soap, NULL, NULL, "ns3:DeleteTask");
	case SOAP_TYPE_PointerTo_ns3__GetTaskHistoryResponse:
		return soap_in_PointerTo_ns3__GetTaskHistoryResponse(soap, NULL, NULL, "ns3:GetTaskHistoryResponse");
	case SOAP_TYPE_PointerTo_ns3__GetTaskHistory:
		return soap_in_PointerTo_ns3__GetTaskHistory(soap, NULL, NULL, "ns3:GetTaskHistory");
	case SOAP_TYPE_PointerTo_ns3__UpdateTaskResponse:
		return soap_in_PointerTo_ns3__UpdateTaskResponse(soap, NULL, NULL, "ns3:UpdateTaskResponse");
	case SOAP_TYPE_PointerTo_ns3__UpdateTask:
		return soap_in_PointerTo_ns3__UpdateTask(soap, NULL, NULL, "ns3:UpdateTask");
	case SOAP_TYPE_PointerTo_ns3__GetTaskCategoryListResponse:
		return soap_in_PointerTo_ns3__GetTaskCategoryListResponse(soap, NULL, NULL, "ns3:GetTaskCategoryListResponse");
	case SOAP_TYPE_PointerTo_ns3__GetTaskCategoryList:
		return soap_in_PointerTo_ns3__GetTaskCategoryList(soap, NULL, NULL, "ns3:GetTaskCategoryList");
	case SOAP_TYPE_PointerTo_ns3__CreateTaskResponse:
		return soap_in_PointerTo_ns3__CreateTaskResponse(soap, NULL, NULL, "ns3:CreateTaskResponse");
	case SOAP_TYPE_PointerTo_ns3__CreateTask:
		return soap_in_PointerTo_ns3__CreateTask(soap, NULL, NULL, "ns3:CreateTask");
	case SOAP_TYPE_PointerTo_ns3__GetTaskStatusListResponse:
		return soap_in_PointerTo_ns3__GetTaskStatusListResponse(soap, NULL, NULL, "ns3:GetTaskStatusListResponse");
	case SOAP_TYPE_PointerTo_ns3__GetTaskStatusList:
		return soap_in_PointerTo_ns3__GetTaskStatusList(soap, NULL, NULL, "ns3:GetTaskStatusList");
	case SOAP_TYPE_PointerTo_ns3__GetUsersForTitleResponse:
		return soap_in_PointerTo_ns3__GetUsersForTitleResponse(soap, NULL, NULL, "ns3:GetUsersForTitleResponse");
	case SOAP_TYPE_PointerTo_ns3__GetUsersForTitle:
		return soap_in_PointerTo_ns3__GetUsersForTitle(soap, NULL, NULL, "ns3:GetUsersForTitle");
	case SOAP_TYPE_PointerTons3__ArrayOfLockDTO:
		return soap_in_PointerTons3__ArrayOfLockDTO(soap, NULL, NULL, "ns3:ArrayOfLockDTO");
	case SOAP_TYPE_PointerTons3__ArrayOfTitleStatusDTO:
		return soap_in_PointerTons3__ArrayOfTitleStatusDTO(soap, NULL, NULL, "ns3:ArrayOfTitleStatusDTO");
	case SOAP_TYPE_PointerTons3__ArrayOfEditionTitlesDTO:
		return soap_in_PointerTons3__ArrayOfEditionTitlesDTO(soap, NULL, NULL, "ns3:ArrayOfEditionTitlesDTO");
	case SOAP_TYPE_PointerTons3__ArrayOfTaskDTO:
		return soap_in_PointerTons3__ArrayOfTaskDTO(soap, NULL, NULL, "ns3:ArrayOfTaskDTO");
	case SOAP_TYPE_PointerTons3__VersionDTO:
		return soap_in_PointerTons3__VersionDTO(soap, NULL, NULL, "ns3:VersionDTO");
	case SOAP_TYPE_PointerTons3__ArrayOfAssetDTO:
		return soap_in_PointerTons3__ArrayOfAssetDTO(soap, NULL, NULL, "ns3:ArrayOfAssetDTO");
	case SOAP_TYPE_PointerTons3__ArrayOfGuid:
		return soap_in_PointerTons3__ArrayOfGuid(soap, NULL, NULL, "ns3:ArrayOfGuid");
	case SOAP_TYPE_PointerTons3__ArrayOfString:
		return soap_in_PointerTons3__ArrayOfString(soap, NULL, NULL, "ns3:ArrayOfString");
	case SOAP_TYPE_PointerTons3__ArrayOfCommentDTO:
		return soap_in_PointerTons3__ArrayOfCommentDTO(soap, NULL, NULL, "ns3:ArrayOfCommentDTO");
	case SOAP_TYPE_PointerTons3__ArrayOfTitleDTO:
		return soap_in_PointerTons3__ArrayOfTitleDTO(soap, NULL, NULL, "ns3:ArrayOfTitleDTO");
	case SOAP_TYPE_PointerTons3__ArrayOfIdNameDTO:
		return soap_in_PointerTons3__ArrayOfIdNameDTO(soap, NULL, NULL, "ns3:ArrayOfIdNameDTO");
	case SOAP_TYPE_PointerTons3__ArrayOfUserDTO:
		return soap_in_PointerTons3__ArrayOfUserDTO(soap, NULL, NULL, "ns3:ArrayOfUserDTO");
	case SOAP_TYPE_PointerToPointerTons3__LockDTO:
		return soap_in_PointerToPointerTons3__LockDTO(soap, NULL, NULL, "ns3:LockDTO");
	case SOAP_TYPE_PointerTons3__LockDTO:
		return soap_in_PointerTons3__LockDTO(soap, NULL, NULL, "ns3:LockDTO");
	case SOAP_TYPE_PointerToPointerTons3__StatusDTO:
		return soap_in_PointerToPointerTons3__StatusDTO(soap, NULL, NULL, "ns3:StatusDTO");
	case SOAP_TYPE_PointerTons3__StatusDTO:
		return soap_in_PointerTons3__StatusDTO(soap, NULL, NULL, "ns3:StatusDTO");
	case SOAP_TYPE_PointerTons3__ArrayOfStatusDTO:
		return soap_in_PointerTons3__ArrayOfStatusDTO(soap, NULL, NULL, "ns3:ArrayOfStatusDTO");
	case SOAP_TYPE_PointerToPointerTons3__TitleStatusDTO:
		return soap_in_PointerToPointerTons3__TitleStatusDTO(soap, NULL, NULL, "ns3:TitleStatusDTO");
	case SOAP_TYPE_PointerTons3__TitleStatusDTO:
		return soap_in_PointerTons3__TitleStatusDTO(soap, NULL, NULL, "ns3:TitleStatusDTO");
	case SOAP_TYPE_PointerTons3__ArrayOfShelveDTO:
		return soap_in_PointerTons3__ArrayOfShelveDTO(soap, NULL, NULL, "ns3:ArrayOfShelveDTO");
	case SOAP_TYPE_PointerToPointerTons3__EditionTitlesDTO:
		return soap_in_PointerToPointerTons3__EditionTitlesDTO(soap, NULL, NULL, "ns3:EditionTitlesDTO");
	case SOAP_TYPE_PointerTons3__EditionTitlesDTO:
		return soap_in_PointerTons3__EditionTitlesDTO(soap, NULL, NULL, "ns3:EditionTitlesDTO");
	case SOAP_TYPE_PointerToPointerTons3__TaskDTO:
		return soap_in_PointerToPointerTons3__TaskDTO(soap, NULL, NULL, "ns3:TaskDTO");
	case SOAP_TYPE_PointerTons3__TaskDTO:
		return soap_in_PointerTons3__TaskDTO(soap, NULL, NULL, "ns3:TaskDTO");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerToPointerTons3__AssetDTO:
		return soap_in_PointerToPointerTons3__AssetDTO(soap, NULL, NULL, "ns3:AssetDTO");
	case SOAP_TYPE_PointerTons3__AssetDTO:
		return soap_in_PointerTons3__AssetDTO(soap, NULL, NULL, "ns3:AssetDTO");
	case SOAP_TYPE_PointerTons4__guid:
		return soap_in_PointerTons4__guid(soap, NULL, NULL, "ns4:guid");
	case SOAP_TYPE_PointerTons3__VersionInfo:
		return soap_in_PointerTons3__VersionInfo(soap, NULL, NULL, "ns3:VersionInfo");
	case SOAP_TYPE_PointerToPointerTons3__ShelveDTO:
		return soap_in_PointerToPointerTons3__ShelveDTO(soap, NULL, NULL, "ns3:ShelveDTO");
	case SOAP_TYPE_PointerTons3__ShelveDTO:
		return soap_in_PointerTons3__ShelveDTO(soap, NULL, NULL, "ns3:ShelveDTO");
	case SOAP_TYPE_PointerTowstring:
		return soap_in_PointerTowstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons3__CommentDTO:
		return soap_in_PointerToPointerTons3__CommentDTO(soap, NULL, NULL, "ns3:CommentDTO");
	case SOAP_TYPE_PointerTons3__CommentDTO:
		return soap_in_PointerTons3__CommentDTO(soap, NULL, NULL, "ns3:CommentDTO");
	case SOAP_TYPE_PointerToPointerTons3__TitleDTO:
		return soap_in_PointerToPointerTons3__TitleDTO(soap, NULL, NULL, "ns3:TitleDTO");
	case SOAP_TYPE_PointerTons3__TitleDTO:
		return soap_in_PointerTons3__TitleDTO(soap, NULL, NULL, "ns3:TitleDTO");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTons3__TaskUpdateInfo:
		return soap_in_PointerTons3__TaskUpdateInfo(soap, NULL, NULL, "ns3:TaskUpdateInfo");
	case SOAP_TYPE_PointerToPointerTons3__IdNameDTO:
		return soap_in_PointerToPointerTons3__IdNameDTO(soap, NULL, NULL, "ns3:IdNameDTO");
	case SOAP_TYPE_PointerTons3__IdNameDTO:
		return soap_in_PointerTons3__IdNameDTO(soap, NULL, NULL, "ns3:IdNameDTO");
	case SOAP_TYPE_PointerToPointerTons3__UserDTO:
		return soap_in_PointerToPointerTons3__UserDTO(soap, NULL, NULL, "ns3:UserDTO");
	case SOAP_TYPE_PointerTons3__UserDTO:
		return soap_in_PointerTons3__UserDTO(soap, NULL, NULL, "ns3:UserDTO");
	case SOAP_TYPE_ns4__guid:
	{	wchar_t **s;
		s = soap_in_ns4__guid(soap, NULL, NULL, "ns4:guid");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wstring:
	{	wchar_t **s;
		s = soap_in_wstring(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_PointerTo_wsrp__path:
		return soap_in_PointerTo_wsrp__path(soap, NULL, NULL, "wsrp:path");
	case SOAP_TYPE_PointerTo_wsse__Security:
		return soap_in_PointerTo_wsse__Security(soap, NULL, NULL, "wsse:Security");
	case SOAP_TYPE_PointerTods__SignatureType:
		return soap_in_PointerTods__SignatureType(soap, NULL, NULL, "ds:SignatureType");
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		return soap_in_PointerTo_wsse__BinarySecurityToken(soap, NULL, NULL, "wsse:BinarySecurityToken");
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		return soap_in_PointerTo_wsse__UsernameToken(soap, NULL, NULL, "wsse:UsernameToken");
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		return soap_in_PointerTo_wsu__Timestamp(soap, NULL, NULL, "wsu:Timestamp");
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		return soap_in_PointerTods__X509IssuerSerialType(soap, NULL, NULL, "ds:X509IssuerSerialType");
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		return soap_in_PointerTods__RSAKeyValueType(soap, NULL, NULL, "ds:RSAKeyValueType");
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		return soap_in_PointerTods__DSAKeyValueType(soap, NULL, NULL, "ds:DSAKeyValueType");
	case SOAP_TYPE_PointerTods__TransformType:
		return soap_in_PointerTods__TransformType(soap, NULL, NULL, "ds:TransformType");
	case SOAP_TYPE_PointerTods__DigestMethodType:
		return soap_in_PointerTods__DigestMethodType(soap, NULL, NULL, "ds:DigestMethodType");
	case SOAP_TYPE_PointerTods__TransformsType:
		return soap_in_PointerTods__TransformsType(soap, NULL, NULL, "ds:TransformsType");
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		return soap_in_PointerToPointerTods__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__ReferenceType:
		return soap_in_PointerTods__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		return soap_in_PointerTods__SignatureMethodType(soap, NULL, NULL, "ds:SignatureMethodType");
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		return soap_in_PointerTods__CanonicalizationMethodType(soap, NULL, NULL, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		return soap_in_PointerTo_wsse__SecurityTokenReference(soap, NULL, NULL, "wsse:SecurityTokenReference");
	case SOAP_TYPE_PointerTods__X509DataType:
		return soap_in_PointerTods__X509DataType(soap, NULL, NULL, "ds:X509DataType");
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		return soap_in_PointerTods__RetrievalMethodType(soap, NULL, NULL, "ds:RetrievalMethodType");
	case SOAP_TYPE_PointerTods__KeyValueType:
		return soap_in_PointerTods__KeyValueType(soap, NULL, NULL, "ds:KeyValueType");
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		return soap_in_PointerTo_c14n__InclusiveNamespaces(soap, NULL, NULL, "c14n:InclusiveNamespaces");
	case SOAP_TYPE_PointerTods__KeyInfoType:
		return soap_in_PointerTods__KeyInfoType(soap, NULL, NULL, "ds:KeyInfoType");
	case SOAP_TYPE_PointerTods__SignedInfoType:
		return soap_in_PointerTods__SignedInfoType(soap, NULL, NULL, "ds:SignedInfoType");
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		return soap_in_PointerTo_wsse__Embedded(soap, NULL, NULL, "wsse:Embedded");
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		return soap_in_PointerTo_wsse__KeyIdentifier(soap, NULL, NULL, "wsse:KeyIdentifier");
	case SOAP_TYPE_PointerTo_wsse__Reference:
		return soap_in_PointerTo_wsse__Reference(soap, NULL, NULL, "wsse:Reference");
	case SOAP_TYPE_PointerTo_wsse__Password:
		return soap_in_PointerTo_wsse__Password(soap, NULL, NULL, "wsse:Password");
	case SOAP_TYPE_PointerTo_wsa__FaultTo:
		return soap_in_PointerTo_wsa__FaultTo(soap, NULL, NULL, "wsa:FaultTo");
	case SOAP_TYPE_PointerTo_wsa__ReplyTo:
		return soap_in_PointerTo_wsa__ReplyTo(soap, NULL, NULL, "wsa:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa__From:
		return soap_in_PointerTo_wsa__From(soap, NULL, NULL, "wsa:From");
	case SOAP_TYPE_PointerTo_wsa__RelatesTo:
		return soap_in_PointerTo_wsa__RelatesTo(soap, NULL, NULL, "wsa:RelatesTo");
	case SOAP_TYPE_PointerTowsa__ServiceNameType:
		return soap_in_PointerTowsa__ServiceNameType(soap, NULL, NULL, "wsa:ServiceNameType");
	case SOAP_TYPE_PointerTo_QName:
		return soap_in_PointerTo_QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_PointerTowsa__ReferenceParametersType:
		return soap_in_PointerTowsa__ReferenceParametersType(soap, NULL, NULL, "wsa:ReferenceParametersType");
	case SOAP_TYPE_PointerTowsa__ReferencePropertiesType:
		return soap_in_PointerTowsa__ReferencePropertiesType(soap, NULL, NULL, "wsa:ReferencePropertiesType");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTowsrp__found_USCOREt:
		return soap_in_PointerTowsrp__found_USCOREt(soap, NULL, NULL, "wsrp:found_t");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToPointerTowsrp__via_USCOREt:
		return soap_in_PointerToPointerTowsrp__via_USCOREt(soap, NULL, NULL, "wsrp:via_t");
	case SOAP_TYPE_PointerTowsrp__via_USCOREt:
		return soap_in_PointerTowsrp__via_USCOREt(soap, NULL, NULL, "wsrp:via_t");
	case SOAP_TYPE_PointerTowsrp__fault_USCOREt:
		return soap_in_PointerTowsrp__fault_USCOREt(soap, NULL, NULL, "wsrp:fault_t");
	case SOAP_TYPE_PointerTowsrp__rev_USCOREt:
		return soap_in_PointerTowsrp__rev_USCOREt(soap, NULL, NULL, "wsrp:rev_t");
	case SOAP_TYPE_PointerTowsrp__fwd_USCOREt:
		return soap_in_PointerTowsrp__fwd_USCOREt(soap, NULL, NULL, "wsrp:fwd_t");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns3:ArrayOfLockDTO"))
		{	*type = SOAP_TYPE_ns3__ArrayOfLockDTO;
			return soap_in_ns3__ArrayOfLockDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:StatusDTO"))
		{	*type = SOAP_TYPE_ns3__StatusDTO;
			return soap_in_ns3__StatusDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfStatusDTO"))
		{	*type = SOAP_TYPE_ns3__ArrayOfStatusDTO;
			return soap_in_ns3__ArrayOfStatusDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TitleStatusDTO"))
		{	*type = SOAP_TYPE_ns3__TitleStatusDTO;
			return soap_in_ns3__TitleStatusDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfTitleStatusDTO"))
		{	*type = SOAP_TYPE_ns3__ArrayOfTitleStatusDTO;
			return soap_in_ns3__ArrayOfTitleStatusDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:EditionTitlesDTO"))
		{	*type = SOAP_TYPE_ns3__EditionTitlesDTO;
			return soap_in_ns3__EditionTitlesDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfEditionTitlesDTO"))
		{	*type = SOAP_TYPE_ns3__ArrayOfEditionTitlesDTO;
			return soap_in_ns3__ArrayOfEditionTitlesDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfTaskDTO"))
		{	*type = SOAP_TYPE_ns3__ArrayOfTaskDTO;
			return soap_in_ns3__ArrayOfTaskDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:VersionDTO"))
		{	*type = SOAP_TYPE_ns3__VersionDTO;
			return soap_in_ns3__VersionDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfAssetDTO"))
		{	*type = SOAP_TYPE_ns3__ArrayOfAssetDTO;
			return soap_in_ns3__ArrayOfAssetDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfGuid"))
		{	*type = SOAP_TYPE_ns3__ArrayOfGuid;
			return soap_in_ns3__ArrayOfGuid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:VersionInfo"))
		{	*type = SOAP_TYPE_ns3__VersionInfo;
			return soap_in_ns3__VersionInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:AssetDTO"))
		{	*type = SOAP_TYPE_ns3__AssetDTO;
			return soap_in_ns3__AssetDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:LockDTO"))
		{	*type = SOAP_TYPE_ns3__LockDTO;
			return soap_in_ns3__LockDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ShelveDTO"))
		{	*type = SOAP_TYPE_ns3__ShelveDTO;
			return soap_in_ns3__ShelveDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfShelveDTO"))
		{	*type = SOAP_TYPE_ns3__ArrayOfShelveDTO;
			return soap_in_ns3__ArrayOfShelveDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfString"))
		{	*type = SOAP_TYPE_ns3__ArrayOfString;
			return soap_in_ns3__ArrayOfString(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CommentDTO"))
		{	*type = SOAP_TYPE_ns3__CommentDTO;
			return soap_in_ns3__CommentDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfCommentDTO"))
		{	*type = SOAP_TYPE_ns3__ArrayOfCommentDTO;
			return soap_in_ns3__ArrayOfCommentDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ConstantDTO"))
		{	*type = SOAP_TYPE_ns3__ConstantDTO;
			return soap_in_ns3__ConstantDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TitleDTO"))
		{	*type = SOAP_TYPE_ns3__TitleDTO;
			return soap_in_ns3__TitleDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfTitleDTO"))
		{	*type = SOAP_TYPE_ns3__ArrayOfTitleDTO;
			return soap_in_ns3__ArrayOfTitleDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TaskUpdateInfo"))
		{	*type = SOAP_TYPE_ns3__TaskUpdateInfo;
			return soap_in_ns3__TaskUpdateInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TaskDTO"))
		{	*type = SOAP_TYPE_ns3__TaskDTO;
			return soap_in_ns3__TaskDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:IdNameDTO"))
		{	*type = SOAP_TYPE_ns3__IdNameDTO;
			return soap_in_ns3__IdNameDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfIdNameDTO"))
		{	*type = SOAP_TYPE_ns3__ArrayOfIdNameDTO;
			return soap_in_ns3__ArrayOfIdNameDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UserDTO"))
		{	*type = SOAP_TYPE_ns3__UserDTO;
			return soap_in_ns3__UserDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:ArrayOfUserDTO"))
		{	*type = SOAP_TYPE_ns3__ArrayOfUserDTO;
			return soap_in_ns3__ArrayOfUserDTO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:FaultcodeEnum"))
		{	*type = SOAP_TYPE_wsse__FaultcodeEnum;
			return soap_in_wsse__FaultcodeEnum(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsu:tTimestampFault"))
		{	*type = SOAP_TYPE_wsu__tTimestampFault;
			return soap_in_wsu__tTimestampFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:FaultSubcodeValues"))
		{	*type = SOAP_TYPE_wsa__FaultSubcodeValues;
			return soap_in_wsa__FaultSubcodeValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:RelationshipTypeValues"))
		{	*type = SOAP_TYPE_wsa__RelationshipTypeValues;
			return soap_in_wsa__RelationshipTypeValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:RSAKeyValueType"))
		{	*type = SOAP_TYPE_ds__RSAKeyValueType;
			return soap_in_ds__RSAKeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:DSAKeyValueType"))
		{	*type = SOAP_TYPE_ds__DSAKeyValueType;
			return soap_in_ds__DSAKeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:X509IssuerSerialType"))
		{	*type = SOAP_TYPE_ds__X509IssuerSerialType;
			return soap_in_ds__X509IssuerSerialType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:X509DataType"))
		{	*type = SOAP_TYPE_ds__X509DataType;
			return soap_in_ds__X509DataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:RetrievalMethodType"))
		{	*type = SOAP_TYPE_ds__RetrievalMethodType;
			return soap_in_ds__RetrievalMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyValueType"))
		{	*type = SOAP_TYPE_ds__KeyValueType;
			return soap_in_ds__KeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:DigestMethodType"))
		{	*type = SOAP_TYPE_ds__DigestMethodType;
			return soap_in_ds__DigestMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:TransformType"))
		{	*type = SOAP_TYPE_ds__TransformType;
			return soap_in_ds__TransformType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:TransformsType"))
		{	*type = SOAP_TYPE_ds__TransformsType;
			return soap_in_ds__TransformsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:ReferenceType"))
		{	*type = SOAP_TYPE_ds__ReferenceType;
			return soap_in_ds__ReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureMethodType"))
		{	*type = SOAP_TYPE_ds__SignatureMethodType;
			return soap_in_ds__SignatureMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:CanonicalizationMethodType"))
		{	*type = SOAP_TYPE_ds__CanonicalizationMethodType;
			return soap_in_ds__CanonicalizationMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyInfoType"))
		{	*type = SOAP_TYPE_ds__KeyInfoType;
			return soap_in_ds__KeyInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignedInfoType"))
		{	*type = SOAP_TYPE_ds__SignedInfoType;
			return soap_in_ds__SignedInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureType"))
		{	*type = SOAP_TYPE_ds__SignatureType;
			return soap_in_ds__SignatureType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:Relationship"))
		{	*type = SOAP_TYPE_wsa__Relationship;
			return soap_in_wsa__Relationship(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ServiceNameType"))
		{	*type = SOAP_TYPE_wsa__ServiceNameType;
			return soap_in_wsa__ServiceNameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ReferenceParametersType"))
		{	*type = SOAP_TYPE_wsa__ReferenceParametersType;
			return soap_in_wsa__ReferenceParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ReferencePropertiesType"))
		{	*type = SOAP_TYPE_wsa__ReferencePropertiesType;
			return soap_in_wsa__ReferencePropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:EndpointReferenceType"))
		{	*type = SOAP_TYPE_wsa__EndpointReferenceType;
			return soap_in_wsa__EndpointReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:fault_t"))
		{	*type = SOAP_TYPE_wsrp__fault_USCOREt;
			return soap_in_wsrp__fault_USCOREt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:found_t"))
		{	*type = SOAP_TYPE_wsrp__found_USCOREt;
			return soap_in_wsrp__found_USCOREt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:rev_t"))
		{	*type = SOAP_TYPE_wsrp__rev_USCOREt;
			return soap_in_wsrp__rev_USCOREt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:fwd_t"))
		{	*type = SOAP_TYPE_wsrp__fwd_USCOREt;
			return soap_in_wsrp__fwd_USCOREt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:via_t"))
		{	*type = SOAP_TYPE_wsrp__via_USCOREt;
			return soap_in_wsrp__via_USCOREt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:path_t"))
		{	*type = SOAP_TYPE_wsrp__path_USCOREt;
			return soap_in_wsrp__path_USCOREt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "wsrp:faultreason"))
		{	*type = SOAP_TYPE__wsrp__faultreason;
			return soap_in__wsrp__faultreason(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:faultcode"))
		{	*type = SOAP_TYPE__wsrp__faultcode;
			return soap_in__wsrp__faultcode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:relatesTo"))
		{	*type = SOAP_TYPE__wsrp__relatesTo;
			return soap_in__wsrp__relatesTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:id"))
		{	*type = SOAP_TYPE__wsrp__id;
			return soap_in__wsrp__id(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:from"))
		{	*type = SOAP_TYPE__wsrp__from;
			return soap_in__wsrp__from(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:to"))
		{	*type = SOAP_TYPE__wsrp__to;
			return soap_in__wsrp__to(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:action"))
		{	*type = SOAP_TYPE__wsrp__action;
			return soap_in__wsrp__action(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ReplyAfter"))
		{	*type = SOAP_TYPE__wsa__ReplyAfter;
			return soap_in__wsa__ReplyAfter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:DownloadVersionResponse"))
		{	*type = SOAP_TYPE__ns3__DownloadVersionResponse;
			return soap_in__ns3__DownloadVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:DownloadVersion"))
		{	*type = SOAP_TYPE__ns3__DownloadVersion;
			return soap_in__ns3__DownloadVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CheckInAssetResponse"))
		{	*type = SOAP_TYPE__ns3__CheckInAssetResponse;
			return soap_in__ns3__CheckInAssetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CheckInAsset"))
		{	*type = SOAP_TYPE__ns3__CheckInAsset;
			return soap_in__ns3__CheckInAsset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetLockResponse"))
		{	*type = SOAP_TYPE__ns3__GetLockResponse;
			return soap_in__ns3__GetLockResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetLock"))
		{	*type = SOAP_TYPE__ns3__GetLock;
			return soap_in__ns3__GetLock(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UpdateAssetStatusResponse"))
		{	*type = SOAP_TYPE__ns3__UpdateAssetStatusResponse;
			return soap_in__ns3__UpdateAssetStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UpdateAssetStatus"))
		{	*type = SOAP_TYPE__ns3__UpdateAssetStatus;
			return soap_in__ns3__UpdateAssetStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UpdateAssetResponse"))
		{	*type = SOAP_TYPE__ns3__UpdateAssetResponse;
			return soap_in__ns3__UpdateAssetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UpdateAsset"))
		{	*type = SOAP_TYPE__ns3__UpdateAsset;
			return soap_in__ns3__UpdateAsset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetAssetListResponse"))
		{	*type = SOAP_TYPE__ns3__GetAssetListResponse;
			return soap_in__ns3__GetAssetListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetAssetList"))
		{	*type = SOAP_TYPE__ns3__GetAssetList;
			return soap_in__ns3__GetAssetList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetStatusByTitleResponse"))
		{	*type = SOAP_TYPE__ns3__GetStatusByTitleResponse;
			return soap_in__ns3__GetStatusByTitleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetStatusByTitle"))
		{	*type = SOAP_TYPE__ns3__GetStatusByTitle;
			return soap_in__ns3__GetStatusByTitle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetEditionsByTitleResponse"))
		{	*type = SOAP_TYPE__ns3__GetEditionsByTitleResponse;
			return soap_in__ns3__GetEditionsByTitleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetEditionsByTitle"))
		{	*type = SOAP_TYPE__ns3__GetEditionsByTitle;
			return soap_in__ns3__GetEditionsByTitle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CheckOutAssetResponse"))
		{	*type = SOAP_TYPE__ns3__CheckOutAssetResponse;
			return soap_in__ns3__CheckOutAssetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CheckOutAsset"))
		{	*type = SOAP_TYPE__ns3__CheckOutAsset;
			return soap_in__ns3__CheckOutAsset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetEditionTaskListResponse"))
		{	*type = SOAP_TYPE__ns3__GetEditionTaskListResponse;
			return soap_in__ns3__GetEditionTaskListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetEditionTaskList"))
		{	*type = SOAP_TYPE__ns3__GetEditionTaskList;
			return soap_in__ns3__GetEditionTaskList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RelinkAssetResponse"))
		{	*type = SOAP_TYPE__ns3__RelinkAssetResponse;
			return soap_in__ns3__RelinkAssetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RelinkAsset"))
		{	*type = SOAP_TYPE__ns3__RelinkAsset;
			return soap_in__ns3__RelinkAsset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UnlinkAssetResponse"))
		{	*type = SOAP_TYPE__ns3__UnlinkAssetResponse;
			return soap_in__ns3__UnlinkAssetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UnlinkAsset"))
		{	*type = SOAP_TYPE__ns3__UnlinkAsset;
			return soap_in__ns3__UnlinkAsset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UploadExportResponse"))
		{	*type = SOAP_TYPE__ns3__UploadExportResponse;
			return soap_in__ns3__UploadExportResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UploadExport"))
		{	*type = SOAP_TYPE__ns3__UploadExport;
			return soap_in__ns3__UploadExport(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UploadVersionResponse"))
		{	*type = SOAP_TYPE__ns3__UploadVersionResponse;
			return soap_in__ns3__UploadVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UploadVersion"))
		{	*type = SOAP_TYPE__ns3__UploadVersion;
			return soap_in__ns3__UploadVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UploadPageResponse"))
		{	*type = SOAP_TYPE__ns3__UploadPageResponse;
			return soap_in__ns3__UploadPageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UploadPage"))
		{	*type = SOAP_TYPE__ns3__UploadPage;
			return soap_in__ns3__UploadPage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UploadPDFResponse"))
		{	*type = SOAP_TYPE__ns3__UploadPDFResponse;
			return soap_in__ns3__UploadPDFResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UploadPDF"))
		{	*type = SOAP_TYPE__ns3__UploadPDF;
			return soap_in__ns3__UploadPDF(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetAssetResponse"))
		{	*type = SOAP_TYPE__ns3__GetAssetResponse;
			return soap_in__ns3__GetAssetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetAsset"))
		{	*type = SOAP_TYPE__ns3__GetAsset;
			return soap_in__ns3__GetAsset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CanUpdateAssetNameResponse"))
		{	*type = SOAP_TYPE__ns3__CanUpdateAssetNameResponse;
			return soap_in__ns3__CanUpdateAssetNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CanUpdateAssetName"))
		{	*type = SOAP_TYPE__ns3__CanUpdateAssetName;
			return soap_in__ns3__CanUpdateAssetName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UpdateAssetNameResponse"))
		{	*type = SOAP_TYPE__ns3__UpdateAssetNameResponse;
			return soap_in__ns3__UpdateAssetNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UpdateAssetName"))
		{	*type = SOAP_TYPE__ns3__UpdateAssetName;
			return soap_in__ns3__UpdateAssetName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CreateAssetResponse"))
		{	*type = SOAP_TYPE__ns3__CreateAssetResponse;
			return soap_in__ns3__CreateAssetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CreateAsset"))
		{	*type = SOAP_TYPE__ns3__CreateAsset;
			return soap_in__ns3__CreateAsset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:DeleteAssetResponse"))
		{	*type = SOAP_TYPE__ns3__DeleteAssetResponse;
			return soap_in__ns3__DeleteAssetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:DeleteAsset"))
		{	*type = SOAP_TYPE__ns3__DeleteAsset;
			return soap_in__ns3__DeleteAsset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UnlockAssetResponse"))
		{	*type = SOAP_TYPE__ns3__UnlockAssetResponse;
			return soap_in__ns3__UnlockAssetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UnlockAsset"))
		{	*type = SOAP_TYPE__ns3__UnlockAsset;
			return soap_in__ns3__UnlockAsset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:LockAssetResponse"))
		{	*type = SOAP_TYPE__ns3__LockAssetResponse;
			return soap_in__ns3__LockAssetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:LockAsset"))
		{	*type = SOAP_TYPE__ns3__LockAsset;
			return soap_in__ns3__LockAsset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetThumbnailResponse"))
		{	*type = SOAP_TYPE__ns3__GetThumbnailResponse;
			return soap_in__ns3__GetThumbnailResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetThumbnail"))
		{	*type = SOAP_TYPE__ns3__GetThumbnail;
			return soap_in__ns3__GetThumbnail(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetUserResponse"))
		{	*type = SOAP_TYPE__ns3__GetUserResponse;
			return soap_in__ns3__GetUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetUser"))
		{	*type = SOAP_TYPE__ns3__GetUser;
			return soap_in__ns3__GetUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:LogoffResponse"))
		{	*type = SOAP_TYPE__ns3__LogoffResponse;
			return soap_in__ns3__LogoffResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Logoff"))
		{	*type = SOAP_TYPE__ns3__Logoff;
			return soap_in__ns3__Logoff(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetShelveListResponse"))
		{	*type = SOAP_TYPE__ns3__GetShelveListResponse;
			return soap_in__ns3__GetShelveListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetShelveList"))
		{	*type = SOAP_TYPE__ns3__GetShelveList;
			return soap_in__ns3__GetShelveList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetTagsResponse"))
		{	*type = SOAP_TYPE__ns3__GetTagsResponse;
			return soap_in__ns3__GetTagsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetTags"))
		{	*type = SOAP_TYPE__ns3__GetTags;
			return soap_in__ns3__GetTags(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetCommentListResponse"))
		{	*type = SOAP_TYPE__ns3__GetCommentListResponse;
			return soap_in__ns3__GetCommentListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetCommentList"))
		{	*type = SOAP_TYPE__ns3__GetCommentList;
			return soap_in__ns3__GetCommentList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRoleResponse"))
		{	*type = SOAP_TYPE__ns3__GetRoleResponse;
			return soap_in__ns3__GetRoleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetRole"))
		{	*type = SOAP_TYPE__ns3__GetRole;
			return soap_in__ns3__GetRole(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetTitleListResponse"))
		{	*type = SOAP_TYPE__ns3__GetTitleListResponse;
			return soap_in__ns3__GetTitleListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetTitleList"))
		{	*type = SOAP_TYPE__ns3__GetTitleList;
			return soap_in__ns3__GetTitleList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:LoginResponse"))
		{	*type = SOAP_TYPE__ns3__LoginResponse;
			return soap_in__ns3__LoginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Login"))
		{	*type = SOAP_TYPE__ns3__Login;
			return soap_in__ns3__Login(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:DeleteTaskResponse"))
		{	*type = SOAP_TYPE__ns3__DeleteTaskResponse;
			return soap_in__ns3__DeleteTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:DeleteTask"))
		{	*type = SOAP_TYPE__ns3__DeleteTask;
			return soap_in__ns3__DeleteTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetTaskHistoryResponse"))
		{	*type = SOAP_TYPE__ns3__GetTaskHistoryResponse;
			return soap_in__ns3__GetTaskHistoryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetTaskHistory"))
		{	*type = SOAP_TYPE__ns3__GetTaskHistory;
			return soap_in__ns3__GetTaskHistory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UpdateTaskResponse"))
		{	*type = SOAP_TYPE__ns3__UpdateTaskResponse;
			return soap_in__ns3__UpdateTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:UpdateTask"))
		{	*type = SOAP_TYPE__ns3__UpdateTask;
			return soap_in__ns3__UpdateTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetTaskCategoryListResponse"))
		{	*type = SOAP_TYPE__ns3__GetTaskCategoryListResponse;
			return soap_in__ns3__GetTaskCategoryListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetTaskCategoryList"))
		{	*type = SOAP_TYPE__ns3__GetTaskCategoryList;
			return soap_in__ns3__GetTaskCategoryList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CreateTaskResponse"))
		{	*type = SOAP_TYPE__ns3__CreateTaskResponse;
			return soap_in__ns3__CreateTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CreateTask"))
		{	*type = SOAP_TYPE__ns3__CreateTask;
			return soap_in__ns3__CreateTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetTaskStatusListResponse"))
		{	*type = SOAP_TYPE__ns3__GetTaskStatusListResponse;
			return soap_in__ns3__GetTaskStatusListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetTaskStatusList"))
		{	*type = SOAP_TYPE__ns3__GetTaskStatusList;
			return soap_in__ns3__GetTaskStatusList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetUsersForTitleResponse"))
		{	*type = SOAP_TYPE__ns3__GetUsersForTitleResponse;
			return soap_in__ns3__GetUsersForTitleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetUsersForTitle"))
		{	*type = SOAP_TYPE__ns3__GetUsersForTitle;
			return soap_in__ns3__GetUsersForTitle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xop:Include"))
		{	*type = SOAP_TYPE__xop__Include;
			return soap_in__xop__Include(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Security"))
		{	*type = SOAP_TYPE__wsse__Security;
			return soap_in__wsse__Security(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "c14n:InclusiveNamespaces"))
		{	*type = SOAP_TYPE__c14n__InclusiveNamespaces;
			return soap_in__c14n__InclusiveNamespaces(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:SecurityTokenReference"))
		{	*type = SOAP_TYPE__wsse__SecurityTokenReference;
			return soap_in__wsse__SecurityTokenReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:KeyIdentifier"))
		{	*type = SOAP_TYPE__wsse__KeyIdentifier;
			return soap_in__wsse__KeyIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Embedded"))
		{	*type = SOAP_TYPE__wsse__Embedded;
			return soap_in__wsse__Embedded(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Reference"))
		{	*type = SOAP_TYPE__wsse__Reference;
			return soap_in__wsse__Reference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:BinarySecurityToken"))
		{	*type = SOAP_TYPE__wsse__BinarySecurityToken;
			return soap_in__wsse__BinarySecurityToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Password"))
		{	*type = SOAP_TYPE__wsse__Password;
			return soap_in__wsse__Password(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:UsernameToken"))
		{	*type = SOAP_TYPE__wsse__UsernameToken;
			return soap_in__wsse__UsernameToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsu:Timestamp"))
		{	*type = SOAP_TYPE__wsu__Timestamp;
			return soap_in__wsu__Timestamp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:FaultTo"))
		{	*type = SOAP_TYPE__wsa__FaultTo;
			return soap_in__wsa__FaultTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:ReplyTo"))
		{	*type = SOAP_TYPE__wsa__ReplyTo;
			return soap_in__wsa__ReplyTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:From"))
		{	*type = SOAP_TYPE__wsa__From;
			return soap_in__wsa__From(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:RelatesTo"))
		{	*type = SOAP_TYPE__wsa__RelatesTo;
			return soap_in__wsa__RelatesTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:EndpointReference"))
		{	*type = SOAP_TYPE__wsa__EndpointReference;
			return soap_in__wsa__EndpointReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:via"))
		{	*type = SOAP_TYPE__wsrp__via;
			return soap_in__wsrp__via(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:fault"))
		{	*type = SOAP_TYPE__wsrp__fault;
			return soap_in__wsrp__fault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:found"))
		{	*type = SOAP_TYPE__wsrp__found;
			return soap_in__wsrp__found(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:rev"))
		{	*type = SOAP_TYPE__wsrp__rev;
			return soap_in__wsrp__rev(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:fwd"))
		{	*type = SOAP_TYPE__wsrp__fwd;
			return soap_in__wsrp__fwd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrp:path"))
		{	*type = SOAP_TYPE__wsrp__path;
			return soap_in__wsrp__path(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa:Action"))
		{	char **s;
			*type = SOAP_TYPE__wsa__Action;
			s = soap_in__wsa__Action(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa:To"))
		{	char **s;
			*type = SOAP_TYPE__wsa__To;
			s = soap_in__wsa__To(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa:MessageID"))
		{	char **s;
			*type = SOAP_TYPE__wsa__MessageID;
			s = soap_in__wsa__MessageID(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE__wsrp__faultreason:
		return soap_out__wsrp__faultreason(soap, "wsrp:faultreason", id, (const char *)ptr, NULL);
	case SOAP_TYPE__wsrp__faultcode:
		return soap_out__wsrp__faultcode(soap, "wsrp:faultcode", id, (const char *)ptr, NULL);
	case SOAP_TYPE__wsrp__relatesTo:
		return soap_out__wsrp__relatesTo(soap, "wsrp:relatesTo", id, (const char *)ptr, NULL);
	case SOAP_TYPE__wsrp__id:
		return soap_out__wsrp__id(soap, "wsrp:id", id, (const char *)ptr, NULL);
	case SOAP_TYPE__wsrp__from:
		return soap_out__wsrp__from(soap, "wsrp:from", id, (const char *)ptr, NULL);
	case SOAP_TYPE__wsrp__to:
		return soap_out__wsrp__to(soap, "wsrp:to", id, (const char *)ptr, NULL);
	case SOAP_TYPE__wsrp__action:
		return soap_out__wsrp__action(soap, "wsrp:action", id, (const char *)ptr, NULL);
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__wsa__ReplyAfter:
		return soap_out__wsa__ReplyAfter(soap, "wsa:ReplyAfter", id, (const unsigned int *)ptr, NULL);
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_wsse__FaultcodeEnum:
		return soap_out_wsse__FaultcodeEnum(soap, tag, id, (const enum wsse__FaultcodeEnum *)ptr, "wsse:FaultcodeEnum");
	case SOAP_TYPE_wsu__tTimestampFault:
		return soap_out_wsu__tTimestampFault(soap, tag, id, (const enum wsu__tTimestampFault *)ptr, "wsu:tTimestampFault");
	case SOAP_TYPE_wsa__FaultSubcodeValues:
		return soap_out_wsa__FaultSubcodeValues(soap, tag, id, (const enum wsa__FaultSubcodeValues *)ptr, "wsa:FaultSubcodeValues");
	case SOAP_TYPE_wsa__RelationshipTypeValues:
		return soap_out_wsa__RelationshipTypeValues(soap, tag, id, (const enum wsa__RelationshipTypeValues *)ptr, "wsa:RelationshipTypeValues");
	case SOAP_TYPE__ns3__DownloadVersionResponse:
		return ((_ns3__DownloadVersionResponse *)ptr)->soap_out(soap, "ns3:DownloadVersionResponse", id, NULL);
	case SOAP_TYPE__ns3__DownloadVersion:
		return ((_ns3__DownloadVersion *)ptr)->soap_out(soap, "ns3:DownloadVersion", id, NULL);
	case SOAP_TYPE__ns3__CheckInAssetResponse:
		return ((_ns3__CheckInAssetResponse *)ptr)->soap_out(soap, "ns3:CheckInAssetResponse", id, NULL);
	case SOAP_TYPE__ns3__CheckInAsset:
		return ((_ns3__CheckInAsset *)ptr)->soap_out(soap, "ns3:CheckInAsset", id, NULL);
	case SOAP_TYPE__ns3__GetLockResponse:
		return ((_ns3__GetLockResponse *)ptr)->soap_out(soap, "ns3:GetLockResponse", id, NULL);
	case SOAP_TYPE__ns3__GetLock:
		return ((_ns3__GetLock *)ptr)->soap_out(soap, "ns3:GetLock", id, NULL);
	case SOAP_TYPE__ns3__UpdateAssetStatusResponse:
		return ((_ns3__UpdateAssetStatusResponse *)ptr)->soap_out(soap, "ns3:UpdateAssetStatusResponse", id, NULL);
	case SOAP_TYPE__ns3__UpdateAssetStatus:
		return ((_ns3__UpdateAssetStatus *)ptr)->soap_out(soap, "ns3:UpdateAssetStatus", id, NULL);
	case SOAP_TYPE__ns3__UpdateAssetResponse:
		return ((_ns3__UpdateAssetResponse *)ptr)->soap_out(soap, "ns3:UpdateAssetResponse", id, NULL);
	case SOAP_TYPE__ns3__UpdateAsset:
		return ((_ns3__UpdateAsset *)ptr)->soap_out(soap, "ns3:UpdateAsset", id, NULL);
	case SOAP_TYPE__ns3__GetAssetListResponse:
		return ((_ns3__GetAssetListResponse *)ptr)->soap_out(soap, "ns3:GetAssetListResponse", id, NULL);
	case SOAP_TYPE__ns3__GetAssetList:
		return ((_ns3__GetAssetList *)ptr)->soap_out(soap, "ns3:GetAssetList", id, NULL);
	case SOAP_TYPE__ns3__GetStatusByTitleResponse:
		return ((_ns3__GetStatusByTitleResponse *)ptr)->soap_out(soap, "ns3:GetStatusByTitleResponse", id, NULL);
	case SOAP_TYPE__ns3__GetStatusByTitle:
		return ((_ns3__GetStatusByTitle *)ptr)->soap_out(soap, "ns3:GetStatusByTitle", id, NULL);
	case SOAP_TYPE__ns3__GetEditionsByTitleResponse:
		return ((_ns3__GetEditionsByTitleResponse *)ptr)->soap_out(soap, "ns3:GetEditionsByTitleResponse", id, NULL);
	case SOAP_TYPE__ns3__GetEditionsByTitle:
		return ((_ns3__GetEditionsByTitle *)ptr)->soap_out(soap, "ns3:GetEditionsByTitle", id, NULL);
	case SOAP_TYPE__ns3__CheckOutAssetResponse:
		return ((_ns3__CheckOutAssetResponse *)ptr)->soap_out(soap, "ns3:CheckOutAssetResponse", id, NULL);
	case SOAP_TYPE__ns3__CheckOutAsset:
		return ((_ns3__CheckOutAsset *)ptr)->soap_out(soap, "ns3:CheckOutAsset", id, NULL);
	case SOAP_TYPE__ns3__GetEditionTaskListResponse:
		return ((_ns3__GetEditionTaskListResponse *)ptr)->soap_out(soap, "ns3:GetEditionTaskListResponse", id, NULL);
	case SOAP_TYPE__ns3__GetEditionTaskList:
		return ((_ns3__GetEditionTaskList *)ptr)->soap_out(soap, "ns3:GetEditionTaskList", id, NULL);
	case SOAP_TYPE__ns3__RelinkAssetResponse:
		return ((_ns3__RelinkAssetResponse *)ptr)->soap_out(soap, "ns3:RelinkAssetResponse", id, NULL);
	case SOAP_TYPE__ns3__RelinkAsset:
		return ((_ns3__RelinkAsset *)ptr)->soap_out(soap, "ns3:RelinkAsset", id, NULL);
	case SOAP_TYPE__ns3__UnlinkAssetResponse:
		return ((_ns3__UnlinkAssetResponse *)ptr)->soap_out(soap, "ns3:UnlinkAssetResponse", id, NULL);
	case SOAP_TYPE__ns3__UnlinkAsset:
		return ((_ns3__UnlinkAsset *)ptr)->soap_out(soap, "ns3:UnlinkAsset", id, NULL);
	case SOAP_TYPE__ns3__UploadExportResponse:
		return ((_ns3__UploadExportResponse *)ptr)->soap_out(soap, "ns3:UploadExportResponse", id, NULL);
	case SOAP_TYPE__ns3__UploadExport:
		return ((_ns3__UploadExport *)ptr)->soap_out(soap, "ns3:UploadExport", id, NULL);
	case SOAP_TYPE__ns3__UploadVersionResponse:
		return ((_ns3__UploadVersionResponse *)ptr)->soap_out(soap, "ns3:UploadVersionResponse", id, NULL);
	case SOAP_TYPE__ns3__UploadVersion:
		return ((_ns3__UploadVersion *)ptr)->soap_out(soap, "ns3:UploadVersion", id, NULL);
	case SOAP_TYPE__ns3__UploadPageResponse:
		return ((_ns3__UploadPageResponse *)ptr)->soap_out(soap, "ns3:UploadPageResponse", id, NULL);
	case SOAP_TYPE__ns3__UploadPage:
		return ((_ns3__UploadPage *)ptr)->soap_out(soap, "ns3:UploadPage", id, NULL);
	case SOAP_TYPE__ns3__UploadPDFResponse:
		return ((_ns3__UploadPDFResponse *)ptr)->soap_out(soap, "ns3:UploadPDFResponse", id, NULL);
	case SOAP_TYPE__ns3__UploadPDF:
		return ((_ns3__UploadPDF *)ptr)->soap_out(soap, "ns3:UploadPDF", id, NULL);
	case SOAP_TYPE__ns3__GetAssetResponse:
		return ((_ns3__GetAssetResponse *)ptr)->soap_out(soap, "ns3:GetAssetResponse", id, NULL);
	case SOAP_TYPE__ns3__GetAsset:
		return ((_ns3__GetAsset *)ptr)->soap_out(soap, "ns3:GetAsset", id, NULL);
	case SOAP_TYPE__ns3__CanUpdateAssetNameResponse:
		return ((_ns3__CanUpdateAssetNameResponse *)ptr)->soap_out(soap, "ns3:CanUpdateAssetNameResponse", id, NULL);
	case SOAP_TYPE__ns3__CanUpdateAssetName:
		return ((_ns3__CanUpdateAssetName *)ptr)->soap_out(soap, "ns3:CanUpdateAssetName", id, NULL);
	case SOAP_TYPE__ns3__UpdateAssetNameResponse:
		return ((_ns3__UpdateAssetNameResponse *)ptr)->soap_out(soap, "ns3:UpdateAssetNameResponse", id, NULL);
	case SOAP_TYPE__ns3__UpdateAssetName:
		return ((_ns3__UpdateAssetName *)ptr)->soap_out(soap, "ns3:UpdateAssetName", id, NULL);
	case SOAP_TYPE__ns3__CreateAssetResponse:
		return ((_ns3__CreateAssetResponse *)ptr)->soap_out(soap, "ns3:CreateAssetResponse", id, NULL);
	case SOAP_TYPE__ns3__CreateAsset:
		return ((_ns3__CreateAsset *)ptr)->soap_out(soap, "ns3:CreateAsset", id, NULL);
	case SOAP_TYPE__ns3__DeleteAssetResponse:
		return ((_ns3__DeleteAssetResponse *)ptr)->soap_out(soap, "ns3:DeleteAssetResponse", id, NULL);
	case SOAP_TYPE__ns3__DeleteAsset:
		return ((_ns3__DeleteAsset *)ptr)->soap_out(soap, "ns3:DeleteAsset", id, NULL);
	case SOAP_TYPE__ns3__UnlockAssetResponse:
		return ((_ns3__UnlockAssetResponse *)ptr)->soap_out(soap, "ns3:UnlockAssetResponse", id, NULL);
	case SOAP_TYPE__ns3__UnlockAsset:
		return ((_ns3__UnlockAsset *)ptr)->soap_out(soap, "ns3:UnlockAsset", id, NULL);
	case SOAP_TYPE__ns3__LockAssetResponse:
		return ((_ns3__LockAssetResponse *)ptr)->soap_out(soap, "ns3:LockAssetResponse", id, NULL);
	case SOAP_TYPE__ns3__LockAsset:
		return ((_ns3__LockAsset *)ptr)->soap_out(soap, "ns3:LockAsset", id, NULL);
	case SOAP_TYPE__ns3__GetThumbnailResponse:
		return ((_ns3__GetThumbnailResponse *)ptr)->soap_out(soap, "ns3:GetThumbnailResponse", id, NULL);
	case SOAP_TYPE__ns3__GetThumbnail:
		return ((_ns3__GetThumbnail *)ptr)->soap_out(soap, "ns3:GetThumbnail", id, NULL);
	case SOAP_TYPE__ns3__GetUserResponse:
		return ((_ns3__GetUserResponse *)ptr)->soap_out(soap, "ns3:GetUserResponse", id, NULL);
	case SOAP_TYPE__ns3__GetUser:
		return ((_ns3__GetUser *)ptr)->soap_out(soap, "ns3:GetUser", id, NULL);
	case SOAP_TYPE__ns3__LogoffResponse:
		return ((_ns3__LogoffResponse *)ptr)->soap_out(soap, "ns3:LogoffResponse", id, NULL);
	case SOAP_TYPE__ns3__Logoff:
		return ((_ns3__Logoff *)ptr)->soap_out(soap, "ns3:Logoff", id, NULL);
	case SOAP_TYPE__ns3__GetShelveListResponse:
		return ((_ns3__GetShelveListResponse *)ptr)->soap_out(soap, "ns3:GetShelveListResponse", id, NULL);
	case SOAP_TYPE__ns3__GetShelveList:
		return ((_ns3__GetShelveList *)ptr)->soap_out(soap, "ns3:GetShelveList", id, NULL);
	case SOAP_TYPE__ns3__GetTagsResponse:
		return ((_ns3__GetTagsResponse *)ptr)->soap_out(soap, "ns3:GetTagsResponse", id, NULL);
	case SOAP_TYPE__ns3__GetTags:
		return ((_ns3__GetTags *)ptr)->soap_out(soap, "ns3:GetTags", id, NULL);
	case SOAP_TYPE__ns3__GetCommentListResponse:
		return ((_ns3__GetCommentListResponse *)ptr)->soap_out(soap, "ns3:GetCommentListResponse", id, NULL);
	case SOAP_TYPE__ns3__GetCommentList:
		return ((_ns3__GetCommentList *)ptr)->soap_out(soap, "ns3:GetCommentList", id, NULL);
	case SOAP_TYPE__ns3__GetRoleResponse:
		return ((_ns3__GetRoleResponse *)ptr)->soap_out(soap, "ns3:GetRoleResponse", id, NULL);
	case SOAP_TYPE__ns3__GetRole:
		return ((_ns3__GetRole *)ptr)->soap_out(soap, "ns3:GetRole", id, NULL);
	case SOAP_TYPE__ns3__GetTitleListResponse:
		return ((_ns3__GetTitleListResponse *)ptr)->soap_out(soap, "ns3:GetTitleListResponse", id, NULL);
	case SOAP_TYPE__ns3__GetTitleList:
		return ((_ns3__GetTitleList *)ptr)->soap_out(soap, "ns3:GetTitleList", id, NULL);
	case SOAP_TYPE__ns3__LoginResponse:
		return ((_ns3__LoginResponse *)ptr)->soap_out(soap, "ns3:LoginResponse", id, NULL);
	case SOAP_TYPE__ns3__Login:
		return ((_ns3__Login *)ptr)->soap_out(soap, "ns3:Login", id, NULL);
	case SOAP_TYPE__ns3__DeleteTaskResponse:
		return ((_ns3__DeleteTaskResponse *)ptr)->soap_out(soap, "ns3:DeleteTaskResponse", id, NULL);
	case SOAP_TYPE__ns3__DeleteTask:
		return ((_ns3__DeleteTask *)ptr)->soap_out(soap, "ns3:DeleteTask", id, NULL);
	case SOAP_TYPE__ns3__GetTaskHistoryResponse:
		return ((_ns3__GetTaskHistoryResponse *)ptr)->soap_out(soap, "ns3:GetTaskHistoryResponse", id, NULL);
	case SOAP_TYPE__ns3__GetTaskHistory:
		return ((_ns3__GetTaskHistory *)ptr)->soap_out(soap, "ns3:GetTaskHistory", id, NULL);
	case SOAP_TYPE__ns3__UpdateTaskResponse:
		return ((_ns3__UpdateTaskResponse *)ptr)->soap_out(soap, "ns3:UpdateTaskResponse", id, NULL);
	case SOAP_TYPE__ns3__UpdateTask:
		return ((_ns3__UpdateTask *)ptr)->soap_out(soap, "ns3:UpdateTask", id, NULL);
	case SOAP_TYPE__ns3__GetTaskCategoryListResponse:
		return ((_ns3__GetTaskCategoryListResponse *)ptr)->soap_out(soap, "ns3:GetTaskCategoryListResponse", id, NULL);
	case SOAP_TYPE__ns3__GetTaskCategoryList:
		return ((_ns3__GetTaskCategoryList *)ptr)->soap_out(soap, "ns3:GetTaskCategoryList", id, NULL);
	case SOAP_TYPE__ns3__CreateTaskResponse:
		return ((_ns3__CreateTaskResponse *)ptr)->soap_out(soap, "ns3:CreateTaskResponse", id, NULL);
	case SOAP_TYPE__ns3__CreateTask:
		return ((_ns3__CreateTask *)ptr)->soap_out(soap, "ns3:CreateTask", id, NULL);
	case SOAP_TYPE__ns3__GetTaskStatusListResponse:
		return ((_ns3__GetTaskStatusListResponse *)ptr)->soap_out(soap, "ns3:GetTaskStatusListResponse", id, NULL);
	case SOAP_TYPE__ns3__GetTaskStatusList:
		return ((_ns3__GetTaskStatusList *)ptr)->soap_out(soap, "ns3:GetTaskStatusList", id, NULL);
	case SOAP_TYPE__ns3__GetUsersForTitleResponse:
		return ((_ns3__GetUsersForTitleResponse *)ptr)->soap_out(soap, "ns3:GetUsersForTitleResponse", id, NULL);
	case SOAP_TYPE__ns3__GetUsersForTitle:
		return ((_ns3__GetUsersForTitle *)ptr)->soap_out(soap, "ns3:GetUsersForTitle", id, NULL);
	case SOAP_TYPE_ns3__ArrayOfLockDTO:
		return ((ns3__ArrayOfLockDTO *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfLockDTO");
	case SOAP_TYPE_ns3__StatusDTO:
		return ((ns3__StatusDTO *)ptr)->soap_out(soap, tag, id, "ns3:StatusDTO");
	case SOAP_TYPE_ns3__ArrayOfStatusDTO:
		return ((ns3__ArrayOfStatusDTO *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfStatusDTO");
	case SOAP_TYPE_ns3__TitleStatusDTO:
		return ((ns3__TitleStatusDTO *)ptr)->soap_out(soap, tag, id, "ns3:TitleStatusDTO");
	case SOAP_TYPE_ns3__ArrayOfTitleStatusDTO:
		return ((ns3__ArrayOfTitleStatusDTO *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfTitleStatusDTO");
	case SOAP_TYPE_ns3__EditionTitlesDTO:
		return ((ns3__EditionTitlesDTO *)ptr)->soap_out(soap, tag, id, "ns3:EditionTitlesDTO");
	case SOAP_TYPE_ns3__ArrayOfEditionTitlesDTO:
		return ((ns3__ArrayOfEditionTitlesDTO *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfEditionTitlesDTO");
	case SOAP_TYPE_ns3__ArrayOfTaskDTO:
		return ((ns3__ArrayOfTaskDTO *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfTaskDTO");
	case SOAP_TYPE_ns3__VersionDTO:
		return ((ns3__VersionDTO *)ptr)->soap_out(soap, tag, id, "ns3:VersionDTO");
	case SOAP_TYPE_ns3__ArrayOfAssetDTO:
		return ((ns3__ArrayOfAssetDTO *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfAssetDTO");
	case SOAP_TYPE_ns3__ArrayOfGuid:
		return ((ns3__ArrayOfGuid *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfGuid");
	case SOAP_TYPE_ns3__VersionInfo:
		return ((ns3__VersionInfo *)ptr)->soap_out(soap, tag, id, "ns3:VersionInfo");
	case SOAP_TYPE_ns3__AssetDTO:
		return ((ns3__AssetDTO *)ptr)->soap_out(soap, tag, id, "ns3:AssetDTO");
	case SOAP_TYPE_ns3__LockDTO:
		return ((ns3__LockDTO *)ptr)->soap_out(soap, tag, id, "ns3:LockDTO");
	case SOAP_TYPE_ns3__ShelveDTO:
		return ((ns3__ShelveDTO *)ptr)->soap_out(soap, tag, id, "ns3:ShelveDTO");
	case SOAP_TYPE_ns3__ArrayOfShelveDTO:
		return ((ns3__ArrayOfShelveDTO *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfShelveDTO");
	case SOAP_TYPE_ns3__ArrayOfString:
		return ((ns3__ArrayOfString *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfString");
	case SOAP_TYPE_ns3__CommentDTO:
		return ((ns3__CommentDTO *)ptr)->soap_out(soap, tag, id, "ns3:CommentDTO");
	case SOAP_TYPE_ns3__ArrayOfCommentDTO:
		return ((ns3__ArrayOfCommentDTO *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfCommentDTO");
	case SOAP_TYPE_ns3__ConstantDTO:
		return ((ns3__ConstantDTO *)ptr)->soap_out(soap, tag, id, "ns3:ConstantDTO");
	case SOAP_TYPE_ns3__TitleDTO:
		return ((ns3__TitleDTO *)ptr)->soap_out(soap, tag, id, "ns3:TitleDTO");
	case SOAP_TYPE_ns3__ArrayOfTitleDTO:
		return ((ns3__ArrayOfTitleDTO *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfTitleDTO");
	case SOAP_TYPE_ns3__TaskUpdateInfo:
		return ((ns3__TaskUpdateInfo *)ptr)->soap_out(soap, tag, id, "ns3:TaskUpdateInfo");
	case SOAP_TYPE_ns3__TaskDTO:
		return ((ns3__TaskDTO *)ptr)->soap_out(soap, tag, id, "ns3:TaskDTO");
	case SOAP_TYPE_ns3__IdNameDTO:
		return ((ns3__IdNameDTO *)ptr)->soap_out(soap, tag, id, "ns3:IdNameDTO");
	case SOAP_TYPE_ns3__ArrayOfIdNameDTO:
		return ((ns3__ArrayOfIdNameDTO *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfIdNameDTO");
	case SOAP_TYPE_ns3__UserDTO:
		return ((ns3__UserDTO *)ptr)->soap_out(soap, tag, id, "ns3:UserDTO");
	case SOAP_TYPE_ns3__ArrayOfUserDTO:
		return ((ns3__ArrayOfUserDTO *)ptr)->soap_out(soap, tag, id, "ns3:ArrayOfUserDTO");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE__xop__Include:
		return soap_out__xop__Include(soap, "xop:Include", id, (const struct _xop__Include *)ptr, NULL);
	case SOAP_TYPE__wsse__Security:
		return soap_out__wsse__Security(soap, "wsse:Security", id, (const struct _wsse__Security *)ptr, NULL);
	case SOAP_TYPE_ds__RSAKeyValueType:
		return soap_out_ds__RSAKeyValueType(soap, tag, id, (const struct ds__RSAKeyValueType *)ptr, "ds:RSAKeyValueType");
	case SOAP_TYPE_ds__DSAKeyValueType:
		return soap_out_ds__DSAKeyValueType(soap, tag, id, (const struct ds__DSAKeyValueType *)ptr, "ds:DSAKeyValueType");
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return soap_out_ds__X509IssuerSerialType(soap, tag, id, (const struct ds__X509IssuerSerialType *)ptr, "ds:X509IssuerSerialType");
	case SOAP_TYPE_ds__X509DataType:
		return soap_out_ds__X509DataType(soap, tag, id, (const struct ds__X509DataType *)ptr, "ds:X509DataType");
	case SOAP_TYPE_ds__RetrievalMethodType:
		return soap_out_ds__RetrievalMethodType(soap, tag, id, (const struct ds__RetrievalMethodType *)ptr, "ds:RetrievalMethodType");
	case SOAP_TYPE_ds__KeyValueType:
		return soap_out_ds__KeyValueType(soap, tag, id, (const struct ds__KeyValueType *)ptr, "ds:KeyValueType");
	case SOAP_TYPE_ds__DigestMethodType:
		return soap_out_ds__DigestMethodType(soap, tag, id, (const struct ds__DigestMethodType *)ptr, "ds:DigestMethodType");
	case SOAP_TYPE_ds__TransformType:
		return soap_out_ds__TransformType(soap, tag, id, (const struct ds__TransformType *)ptr, "ds:TransformType");
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		return soap_out__c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", id, (const struct _c14n__InclusiveNamespaces *)ptr, NULL);
	case SOAP_TYPE_ds__TransformsType:
		return soap_out_ds__TransformsType(soap, tag, id, (const struct ds__TransformsType *)ptr, "ds:TransformsType");
	case SOAP_TYPE_ds__ReferenceType:
		return soap_out_ds__ReferenceType(soap, tag, id, (const struct ds__ReferenceType *)ptr, "ds:ReferenceType");
	case SOAP_TYPE_ds__SignatureMethodType:
		return soap_out_ds__SignatureMethodType(soap, tag, id, (const struct ds__SignatureMethodType *)ptr, "ds:SignatureMethodType");
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return soap_out_ds__CanonicalizationMethodType(soap, tag, id, (const struct ds__CanonicalizationMethodType *)ptr, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_ds__KeyInfoType:
		return soap_out_ds__KeyInfoType(soap, tag, id, (const struct ds__KeyInfoType *)ptr, "ds:KeyInfoType");
	case SOAP_TYPE_ds__SignedInfoType:
		return soap_out_ds__SignedInfoType(soap, tag, id, (const struct ds__SignedInfoType *)ptr, "ds:SignedInfoType");
	case SOAP_TYPE_ds__SignatureType:
		return soap_out_ds__SignatureType(soap, tag, id, (const struct ds__SignatureType *)ptr, "ds:SignatureType");
	case SOAP_TYPE__wsse__SecurityTokenReference:
		return soap_out__wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", id, (const struct _wsse__SecurityTokenReference *)ptr, NULL);
	case SOAP_TYPE__wsse__KeyIdentifier:
		return soap_out__wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", id, (const struct _wsse__KeyIdentifier *)ptr, NULL);
	case SOAP_TYPE__wsse__Embedded:
		return soap_out__wsse__Embedded(soap, "wsse:Embedded", id, (const struct _wsse__Embedded *)ptr, NULL);
	case SOAP_TYPE__wsse__Reference:
		return soap_out__wsse__Reference(soap, "wsse:Reference", id, (const struct _wsse__Reference *)ptr, NULL);
	case SOAP_TYPE__wsse__BinarySecurityToken:
		return soap_out__wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", id, (const struct _wsse__BinarySecurityToken *)ptr, NULL);
	case SOAP_TYPE__wsse__Password:
		return soap_out__wsse__Password(soap, "wsse:Password", id, (const struct _wsse__Password *)ptr, NULL);
	case SOAP_TYPE__wsse__UsernameToken:
		return soap_out__wsse__UsernameToken(soap, "wsse:UsernameToken", id, (const struct _wsse__UsernameToken *)ptr, NULL);
	case SOAP_TYPE__wsu__Timestamp:
		return soap_out__wsu__Timestamp(soap, "wsu:Timestamp", id, (const struct _wsu__Timestamp *)ptr, NULL);
	case SOAP_TYPE__wsa__FaultTo:
		return soap_out__wsa__FaultTo(soap, "wsa:FaultTo", id, (const struct wsa__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE__wsa__ReplyTo:
		return soap_out__wsa__ReplyTo(soap, "wsa:ReplyTo", id, (const struct wsa__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE__wsa__From:
		return soap_out__wsa__From(soap, "wsa:From", id, (const struct wsa__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE__wsa__RelatesTo:
		return soap_out__wsa__RelatesTo(soap, "wsa:RelatesTo", id, (const struct wsa__Relationship *)ptr, NULL);
	case SOAP_TYPE__wsa__EndpointReference:
		return soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", id, (const struct wsa__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE_wsa__Relationship:
		return soap_out_wsa__Relationship(soap, tag, id, (const struct wsa__Relationship *)ptr, "wsa:Relationship");
	case SOAP_TYPE_wsa__ServiceNameType:
		return soap_out_wsa__ServiceNameType(soap, tag, id, (const struct wsa__ServiceNameType *)ptr, "wsa:ServiceNameType");
	case SOAP_TYPE_wsa__ReferenceParametersType:
		return soap_out_wsa__ReferenceParametersType(soap, tag, id, (const struct wsa__ReferenceParametersType *)ptr, "wsa:ReferenceParametersType");
	case SOAP_TYPE_wsa__ReferencePropertiesType:
		return soap_out_wsa__ReferencePropertiesType(soap, tag, id, (const struct wsa__ReferencePropertiesType *)ptr, "wsa:ReferencePropertiesType");
	case SOAP_TYPE_wsa__EndpointReferenceType:
		return soap_out_wsa__EndpointReferenceType(soap, tag, id, (const struct wsa__EndpointReferenceType *)ptr, "wsa:EndpointReferenceType");
	case SOAP_TYPE__wsrp__via:
		return soap_out__wsrp__via(soap, "wsrp:via", id, (const struct wsrp__via_USCOREt *)ptr, NULL);
	case SOAP_TYPE__wsrp__fault:
		return soap_out__wsrp__fault(soap, "wsrp:fault", id, (const struct wsrp__fault_USCOREt *)ptr, NULL);
	case SOAP_TYPE__wsrp__found:
		return soap_out__wsrp__found(soap, "wsrp:found", id, (const struct wsrp__found_USCOREt *)ptr, NULL);
	case SOAP_TYPE__wsrp__rev:
		return soap_out__wsrp__rev(soap, "wsrp:rev", id, (const struct wsrp__rev_USCOREt *)ptr, NULL);
	case SOAP_TYPE__wsrp__fwd:
		return soap_out__wsrp__fwd(soap, "wsrp:fwd", id, (const struct wsrp__fwd_USCOREt *)ptr, NULL);
	case SOAP_TYPE__wsrp__path:
		return soap_out__wsrp__path(soap, "wsrp:path", id, (const struct wsrp__path_USCOREt *)ptr, NULL);
	case SOAP_TYPE_wsrp__fault_USCOREt:
		return soap_out_wsrp__fault_USCOREt(soap, tag, id, (const struct wsrp__fault_USCOREt *)ptr, "wsrp:fault_t");
	case SOAP_TYPE_wsrp__found_USCOREt:
		return soap_out_wsrp__found_USCOREt(soap, tag, id, (const struct wsrp__found_USCOREt *)ptr, "wsrp:found_t");
	case SOAP_TYPE_wsrp__rev_USCOREt:
		return soap_out_wsrp__rev_USCOREt(soap, tag, id, (const struct wsrp__rev_USCOREt *)ptr, "wsrp:rev_t");
	case SOAP_TYPE_wsrp__fwd_USCOREt:
		return soap_out_wsrp__fwd_USCOREt(soap, tag, id, (const struct wsrp__fwd_USCOREt *)ptr, "wsrp:fwd_t");
	case SOAP_TYPE_wsrp__via_USCOREt:
		return soap_out_wsrp__via_USCOREt(soap, tag, id, (const struct wsrp__via_USCOREt *)ptr, "wsrp:via_t");
	case SOAP_TYPE_wsrp__path_USCOREt:
		return soap_out_wsrp__path_USCOREt(soap, tag, id, (const struct wsrp__path_USCOREt *)ptr, "wsrp:path_t");
	case SOAP_TYPE_PointerTo_ns3__DownloadVersionResponse:
		return soap_out_PointerTo_ns3__DownloadVersionResponse(soap, tag, id, (_ns3__DownloadVersionResponse *const*)ptr, "ns3:DownloadVersionResponse");
	case SOAP_TYPE_PointerTo_ns3__DownloadVersion:
		return soap_out_PointerTo_ns3__DownloadVersion(soap, tag, id, (_ns3__DownloadVersion *const*)ptr, "ns3:DownloadVersion");
	case SOAP_TYPE_PointerTo_ns3__CheckInAssetResponse:
		return soap_out_PointerTo_ns3__CheckInAssetResponse(soap, tag, id, (_ns3__CheckInAssetResponse *const*)ptr, "ns3:CheckInAssetResponse");
	case SOAP_TYPE_PointerTo_ns3__CheckInAsset:
		return soap_out_PointerTo_ns3__CheckInAsset(soap, tag, id, (_ns3__CheckInAsset *const*)ptr, "ns3:CheckInAsset");
	case SOAP_TYPE_PointerTo_ns3__GetLockResponse:
		return soap_out_PointerTo_ns3__GetLockResponse(soap, tag, id, (_ns3__GetLockResponse *const*)ptr, "ns3:GetLockResponse");
	case SOAP_TYPE_PointerTo_ns3__GetLock:
		return soap_out_PointerTo_ns3__GetLock(soap, tag, id, (_ns3__GetLock *const*)ptr, "ns3:GetLock");
	case SOAP_TYPE_PointerTo_ns3__UpdateAssetStatusResponse:
		return soap_out_PointerTo_ns3__UpdateAssetStatusResponse(soap, tag, id, (_ns3__UpdateAssetStatusResponse *const*)ptr, "ns3:UpdateAssetStatusResponse");
	case SOAP_TYPE_PointerTo_ns3__UpdateAssetStatus:
		return soap_out_PointerTo_ns3__UpdateAssetStatus(soap, tag, id, (_ns3__UpdateAssetStatus *const*)ptr, "ns3:UpdateAssetStatus");
	case SOAP_TYPE_PointerTo_ns3__UpdateAssetResponse:
		return soap_out_PointerTo_ns3__UpdateAssetResponse(soap, tag, id, (_ns3__UpdateAssetResponse *const*)ptr, "ns3:UpdateAssetResponse");
	case SOAP_TYPE_PointerTo_ns3__UpdateAsset:
		return soap_out_PointerTo_ns3__UpdateAsset(soap, tag, id, (_ns3__UpdateAsset *const*)ptr, "ns3:UpdateAsset");
	case SOAP_TYPE_PointerTo_ns3__GetAssetListResponse:
		return soap_out_PointerTo_ns3__GetAssetListResponse(soap, tag, id, (_ns3__GetAssetListResponse *const*)ptr, "ns3:GetAssetListResponse");
	case SOAP_TYPE_PointerTo_ns3__GetAssetList:
		return soap_out_PointerTo_ns3__GetAssetList(soap, tag, id, (_ns3__GetAssetList *const*)ptr, "ns3:GetAssetList");
	case SOAP_TYPE_PointerTo_ns3__GetStatusByTitleResponse:
		return soap_out_PointerTo_ns3__GetStatusByTitleResponse(soap, tag, id, (_ns3__GetStatusByTitleResponse *const*)ptr, "ns3:GetStatusByTitleResponse");
	case SOAP_TYPE_PointerTo_ns3__GetStatusByTitle:
		return soap_out_PointerTo_ns3__GetStatusByTitle(soap, tag, id, (_ns3__GetStatusByTitle *const*)ptr, "ns3:GetStatusByTitle");
	case SOAP_TYPE_PointerTo_ns3__GetEditionsByTitleResponse:
		return soap_out_PointerTo_ns3__GetEditionsByTitleResponse(soap, tag, id, (_ns3__GetEditionsByTitleResponse *const*)ptr, "ns3:GetEditionsByTitleResponse");
	case SOAP_TYPE_PointerTo_ns3__GetEditionsByTitle:
		return soap_out_PointerTo_ns3__GetEditionsByTitle(soap, tag, id, (_ns3__GetEditionsByTitle *const*)ptr, "ns3:GetEditionsByTitle");
	case SOAP_TYPE_PointerTo_ns3__CheckOutAssetResponse:
		return soap_out_PointerTo_ns3__CheckOutAssetResponse(soap, tag, id, (_ns3__CheckOutAssetResponse *const*)ptr, "ns3:CheckOutAssetResponse");
	case SOAP_TYPE_PointerTo_ns3__CheckOutAsset:
		return soap_out_PointerTo_ns3__CheckOutAsset(soap, tag, id, (_ns3__CheckOutAsset *const*)ptr, "ns3:CheckOutAsset");
	case SOAP_TYPE_PointerTo_ns3__GetEditionTaskListResponse:
		return soap_out_PointerTo_ns3__GetEditionTaskListResponse(soap, tag, id, (_ns3__GetEditionTaskListResponse *const*)ptr, "ns3:GetEditionTaskListResponse");
	case SOAP_TYPE_PointerTo_ns3__GetEditionTaskList:
		return soap_out_PointerTo_ns3__GetEditionTaskList(soap, tag, id, (_ns3__GetEditionTaskList *const*)ptr, "ns3:GetEditionTaskList");
	case SOAP_TYPE_PointerTo_ns3__RelinkAssetResponse:
		return soap_out_PointerTo_ns3__RelinkAssetResponse(soap, tag, id, (_ns3__RelinkAssetResponse *const*)ptr, "ns3:RelinkAssetResponse");
	case SOAP_TYPE_PointerTo_ns3__RelinkAsset:
		return soap_out_PointerTo_ns3__RelinkAsset(soap, tag, id, (_ns3__RelinkAsset *const*)ptr, "ns3:RelinkAsset");
	case SOAP_TYPE_PointerTo_ns3__UnlinkAssetResponse:
		return soap_out_PointerTo_ns3__UnlinkAssetResponse(soap, tag, id, (_ns3__UnlinkAssetResponse *const*)ptr, "ns3:UnlinkAssetResponse");
	case SOAP_TYPE_PointerTo_ns3__UnlinkAsset:
		return soap_out_PointerTo_ns3__UnlinkAsset(soap, tag, id, (_ns3__UnlinkAsset *const*)ptr, "ns3:UnlinkAsset");
	case SOAP_TYPE_PointerTo_ns3__UploadExportResponse:
		return soap_out_PointerTo_ns3__UploadExportResponse(soap, tag, id, (_ns3__UploadExportResponse *const*)ptr, "ns3:UploadExportResponse");
	case SOAP_TYPE_PointerTo_ns3__UploadExport:
		return soap_out_PointerTo_ns3__UploadExport(soap, tag, id, (_ns3__UploadExport *const*)ptr, "ns3:UploadExport");
	case SOAP_TYPE_PointerTo_ns3__UploadVersionResponse:
		return soap_out_PointerTo_ns3__UploadVersionResponse(soap, tag, id, (_ns3__UploadVersionResponse *const*)ptr, "ns3:UploadVersionResponse");
	case SOAP_TYPE_PointerTo_ns3__UploadVersion:
		return soap_out_PointerTo_ns3__UploadVersion(soap, tag, id, (_ns3__UploadVersion *const*)ptr, "ns3:UploadVersion");
	case SOAP_TYPE_PointerTo_ns3__UploadPageResponse:
		return soap_out_PointerTo_ns3__UploadPageResponse(soap, tag, id, (_ns3__UploadPageResponse *const*)ptr, "ns3:UploadPageResponse");
	case SOAP_TYPE_PointerTo_ns3__UploadPage:
		return soap_out_PointerTo_ns3__UploadPage(soap, tag, id, (_ns3__UploadPage *const*)ptr, "ns3:UploadPage");
	case SOAP_TYPE_PointerTo_ns3__UploadPDFResponse:
		return soap_out_PointerTo_ns3__UploadPDFResponse(soap, tag, id, (_ns3__UploadPDFResponse *const*)ptr, "ns3:UploadPDFResponse");
	case SOAP_TYPE_PointerTo_ns3__UploadPDF:
		return soap_out_PointerTo_ns3__UploadPDF(soap, tag, id, (_ns3__UploadPDF *const*)ptr, "ns3:UploadPDF");
	case SOAP_TYPE_PointerTo_ns3__GetAssetResponse:
		return soap_out_PointerTo_ns3__GetAssetResponse(soap, tag, id, (_ns3__GetAssetResponse *const*)ptr, "ns3:GetAssetResponse");
	case SOAP_TYPE_PointerTo_ns3__GetAsset:
		return soap_out_PointerTo_ns3__GetAsset(soap, tag, id, (_ns3__GetAsset *const*)ptr, "ns3:GetAsset");
	case SOAP_TYPE_PointerTo_ns3__CanUpdateAssetNameResponse:
		return soap_out_PointerTo_ns3__CanUpdateAssetNameResponse(soap, tag, id, (_ns3__CanUpdateAssetNameResponse *const*)ptr, "ns3:CanUpdateAssetNameResponse");
	case SOAP_TYPE_PointerTo_ns3__CanUpdateAssetName:
		return soap_out_PointerTo_ns3__CanUpdateAssetName(soap, tag, id, (_ns3__CanUpdateAssetName *const*)ptr, "ns3:CanUpdateAssetName");
	case SOAP_TYPE_PointerTo_ns3__UpdateAssetNameResponse:
		return soap_out_PointerTo_ns3__UpdateAssetNameResponse(soap, tag, id, (_ns3__UpdateAssetNameResponse *const*)ptr, "ns3:UpdateAssetNameResponse");
	case SOAP_TYPE_PointerTo_ns3__UpdateAssetName:
		return soap_out_PointerTo_ns3__UpdateAssetName(soap, tag, id, (_ns3__UpdateAssetName *const*)ptr, "ns3:UpdateAssetName");
	case SOAP_TYPE_PointerTo_ns3__CreateAssetResponse:
		return soap_out_PointerTo_ns3__CreateAssetResponse(soap, tag, id, (_ns3__CreateAssetResponse *const*)ptr, "ns3:CreateAssetResponse");
	case SOAP_TYPE_PointerTo_ns3__CreateAsset:
		return soap_out_PointerTo_ns3__CreateAsset(soap, tag, id, (_ns3__CreateAsset *const*)ptr, "ns3:CreateAsset");
	case SOAP_TYPE_PointerTo_ns3__DeleteAssetResponse:
		return soap_out_PointerTo_ns3__DeleteAssetResponse(soap, tag, id, (_ns3__DeleteAssetResponse *const*)ptr, "ns3:DeleteAssetResponse");
	case SOAP_TYPE_PointerTo_ns3__DeleteAsset:
		return soap_out_PointerTo_ns3__DeleteAsset(soap, tag, id, (_ns3__DeleteAsset *const*)ptr, "ns3:DeleteAsset");
	case SOAP_TYPE_PointerTo_ns3__UnlockAssetResponse:
		return soap_out_PointerTo_ns3__UnlockAssetResponse(soap, tag, id, (_ns3__UnlockAssetResponse *const*)ptr, "ns3:UnlockAssetResponse");
	case SOAP_TYPE_PointerTo_ns3__UnlockAsset:
		return soap_out_PointerTo_ns3__UnlockAsset(soap, tag, id, (_ns3__UnlockAsset *const*)ptr, "ns3:UnlockAsset");
	case SOAP_TYPE_PointerTo_ns3__LockAssetResponse:
		return soap_out_PointerTo_ns3__LockAssetResponse(soap, tag, id, (_ns3__LockAssetResponse *const*)ptr, "ns3:LockAssetResponse");
	case SOAP_TYPE_PointerTo_ns3__LockAsset:
		return soap_out_PointerTo_ns3__LockAsset(soap, tag, id, (_ns3__LockAsset *const*)ptr, "ns3:LockAsset");
	case SOAP_TYPE_PointerTo_ns3__GetThumbnailResponse:
		return soap_out_PointerTo_ns3__GetThumbnailResponse(soap, tag, id, (_ns3__GetThumbnailResponse *const*)ptr, "ns3:GetThumbnailResponse");
	case SOAP_TYPE_PointerTo_ns3__GetThumbnail:
		return soap_out_PointerTo_ns3__GetThumbnail(soap, tag, id, (_ns3__GetThumbnail *const*)ptr, "ns3:GetThumbnail");
	case SOAP_TYPE_PointerTo_ns3__GetUserResponse:
		return soap_out_PointerTo_ns3__GetUserResponse(soap, tag, id, (_ns3__GetUserResponse *const*)ptr, "ns3:GetUserResponse");
	case SOAP_TYPE_PointerTo_ns3__GetUser:
		return soap_out_PointerTo_ns3__GetUser(soap, tag, id, (_ns3__GetUser *const*)ptr, "ns3:GetUser");
	case SOAP_TYPE_PointerTo_ns3__LogoffResponse:
		return soap_out_PointerTo_ns3__LogoffResponse(soap, tag, id, (_ns3__LogoffResponse *const*)ptr, "ns3:LogoffResponse");
	case SOAP_TYPE_PointerTo_ns3__Logoff:
		return soap_out_PointerTo_ns3__Logoff(soap, tag, id, (_ns3__Logoff *const*)ptr, "ns3:Logoff");
	case SOAP_TYPE_PointerTo_ns3__GetShelveListResponse:
		return soap_out_PointerTo_ns3__GetShelveListResponse(soap, tag, id, (_ns3__GetShelveListResponse *const*)ptr, "ns3:GetShelveListResponse");
	case SOAP_TYPE_PointerTo_ns3__GetShelveList:
		return soap_out_PointerTo_ns3__GetShelveList(soap, tag, id, (_ns3__GetShelveList *const*)ptr, "ns3:GetShelveList");
	case SOAP_TYPE_PointerTo_ns3__GetTagsResponse:
		return soap_out_PointerTo_ns3__GetTagsResponse(soap, tag, id, (_ns3__GetTagsResponse *const*)ptr, "ns3:GetTagsResponse");
	case SOAP_TYPE_PointerTo_ns3__GetTags:
		return soap_out_PointerTo_ns3__GetTags(soap, tag, id, (_ns3__GetTags *const*)ptr, "ns3:GetTags");
	case SOAP_TYPE_PointerTo_ns3__GetCommentListResponse:
		return soap_out_PointerTo_ns3__GetCommentListResponse(soap, tag, id, (_ns3__GetCommentListResponse *const*)ptr, "ns3:GetCommentListResponse");
	case SOAP_TYPE_PointerTo_ns3__GetCommentList:
		return soap_out_PointerTo_ns3__GetCommentList(soap, tag, id, (_ns3__GetCommentList *const*)ptr, "ns3:GetCommentList");
	case SOAP_TYPE_PointerTo_ns3__GetRoleResponse:
		return soap_out_PointerTo_ns3__GetRoleResponse(soap, tag, id, (_ns3__GetRoleResponse *const*)ptr, "ns3:GetRoleResponse");
	case SOAP_TYPE_PointerTo_ns3__GetRole:
		return soap_out_PointerTo_ns3__GetRole(soap, tag, id, (_ns3__GetRole *const*)ptr, "ns3:GetRole");
	case SOAP_TYPE_PointerTo_ns3__GetTitleListResponse:
		return soap_out_PointerTo_ns3__GetTitleListResponse(soap, tag, id, (_ns3__GetTitleListResponse *const*)ptr, "ns3:GetTitleListResponse");
	case SOAP_TYPE_PointerTo_ns3__GetTitleList:
		return soap_out_PointerTo_ns3__GetTitleList(soap, tag, id, (_ns3__GetTitleList *const*)ptr, "ns3:GetTitleList");
	case SOAP_TYPE_PointerTo_ns3__LoginResponse:
		return soap_out_PointerTo_ns3__LoginResponse(soap, tag, id, (_ns3__LoginResponse *const*)ptr, "ns3:LoginResponse");
	case SOAP_TYPE_PointerTo_ns3__Login:
		return soap_out_PointerTo_ns3__Login(soap, tag, id, (_ns3__Login *const*)ptr, "ns3:Login");
	case SOAP_TYPE_PointerTo_ns3__DeleteTaskResponse:
		return soap_out_PointerTo_ns3__DeleteTaskResponse(soap, tag, id, (_ns3__DeleteTaskResponse *const*)ptr, "ns3:DeleteTaskResponse");
	case SOAP_TYPE_PointerTo_ns3__DeleteTask:
		return soap_out_PointerTo_ns3__DeleteTask(soap, tag, id, (_ns3__DeleteTask *const*)ptr, "ns3:DeleteTask");
	case SOAP_TYPE_PointerTo_ns3__GetTaskHistoryResponse:
		return soap_out_PointerTo_ns3__GetTaskHistoryResponse(soap, tag, id, (_ns3__GetTaskHistoryResponse *const*)ptr, "ns3:GetTaskHistoryResponse");
	case SOAP_TYPE_PointerTo_ns3__GetTaskHistory:
		return soap_out_PointerTo_ns3__GetTaskHistory(soap, tag, id, (_ns3__GetTaskHistory *const*)ptr, "ns3:GetTaskHistory");
	case SOAP_TYPE_PointerTo_ns3__UpdateTaskResponse:
		return soap_out_PointerTo_ns3__UpdateTaskResponse(soap, tag, id, (_ns3__UpdateTaskResponse *const*)ptr, "ns3:UpdateTaskResponse");
	case SOAP_TYPE_PointerTo_ns3__UpdateTask:
		return soap_out_PointerTo_ns3__UpdateTask(soap, tag, id, (_ns3__UpdateTask *const*)ptr, "ns3:UpdateTask");
	case SOAP_TYPE_PointerTo_ns3__GetTaskCategoryListResponse:
		return soap_out_PointerTo_ns3__GetTaskCategoryListResponse(soap, tag, id, (_ns3__GetTaskCategoryListResponse *const*)ptr, "ns3:GetTaskCategoryListResponse");
	case SOAP_TYPE_PointerTo_ns3__GetTaskCategoryList:
		return soap_out_PointerTo_ns3__GetTaskCategoryList(soap, tag, id, (_ns3__GetTaskCategoryList *const*)ptr, "ns3:GetTaskCategoryList");
	case SOAP_TYPE_PointerTo_ns3__CreateTaskResponse:
		return soap_out_PointerTo_ns3__CreateTaskResponse(soap, tag, id, (_ns3__CreateTaskResponse *const*)ptr, "ns3:CreateTaskResponse");
	case SOAP_TYPE_PointerTo_ns3__CreateTask:
		return soap_out_PointerTo_ns3__CreateTask(soap, tag, id, (_ns3__CreateTask *const*)ptr, "ns3:CreateTask");
	case SOAP_TYPE_PointerTo_ns3__GetTaskStatusListResponse:
		return soap_out_PointerTo_ns3__GetTaskStatusListResponse(soap, tag, id, (_ns3__GetTaskStatusListResponse *const*)ptr, "ns3:GetTaskStatusListResponse");
	case SOAP_TYPE_PointerTo_ns3__GetTaskStatusList:
		return soap_out_PointerTo_ns3__GetTaskStatusList(soap, tag, id, (_ns3__GetTaskStatusList *const*)ptr, "ns3:GetTaskStatusList");
	case SOAP_TYPE_PointerTo_ns3__GetUsersForTitleResponse:
		return soap_out_PointerTo_ns3__GetUsersForTitleResponse(soap, tag, id, (_ns3__GetUsersForTitleResponse *const*)ptr, "ns3:GetUsersForTitleResponse");
	case SOAP_TYPE_PointerTo_ns3__GetUsersForTitle:
		return soap_out_PointerTo_ns3__GetUsersForTitle(soap, tag, id, (_ns3__GetUsersForTitle *const*)ptr, "ns3:GetUsersForTitle");
	case SOAP_TYPE_PointerTons3__ArrayOfLockDTO:
		return soap_out_PointerTons3__ArrayOfLockDTO(soap, tag, id, (ns3__ArrayOfLockDTO *const*)ptr, "ns3:ArrayOfLockDTO");
	case SOAP_TYPE_PointerTons3__ArrayOfTitleStatusDTO:
		return soap_out_PointerTons3__ArrayOfTitleStatusDTO(soap, tag, id, (ns3__ArrayOfTitleStatusDTO *const*)ptr, "ns3:ArrayOfTitleStatusDTO");
	case SOAP_TYPE_PointerTons3__ArrayOfEditionTitlesDTO:
		return soap_out_PointerTons3__ArrayOfEditionTitlesDTO(soap, tag, id, (ns3__ArrayOfEditionTitlesDTO *const*)ptr, "ns3:ArrayOfEditionTitlesDTO");
	case SOAP_TYPE_PointerTons3__ArrayOfTaskDTO:
		return soap_out_PointerTons3__ArrayOfTaskDTO(soap, tag, id, (ns3__ArrayOfTaskDTO *const*)ptr, "ns3:ArrayOfTaskDTO");
	case SOAP_TYPE_PointerTons3__VersionDTO:
		return soap_out_PointerTons3__VersionDTO(soap, tag, id, (ns3__VersionDTO *const*)ptr, "ns3:VersionDTO");
	case SOAP_TYPE_PointerTons3__ArrayOfAssetDTO:
		return soap_out_PointerTons3__ArrayOfAssetDTO(soap, tag, id, (ns3__ArrayOfAssetDTO *const*)ptr, "ns3:ArrayOfAssetDTO");
	case SOAP_TYPE_PointerTons3__ArrayOfGuid:
		return soap_out_PointerTons3__ArrayOfGuid(soap, tag, id, (ns3__ArrayOfGuid *const*)ptr, "ns3:ArrayOfGuid");
	case SOAP_TYPE_PointerTons3__ArrayOfString:
		return soap_out_PointerTons3__ArrayOfString(soap, tag, id, (ns3__ArrayOfString *const*)ptr, "ns3:ArrayOfString");
	case SOAP_TYPE_PointerTons3__ArrayOfCommentDTO:
		return soap_out_PointerTons3__ArrayOfCommentDTO(soap, tag, id, (ns3__ArrayOfCommentDTO *const*)ptr, "ns3:ArrayOfCommentDTO");
	case SOAP_TYPE_PointerTons3__ArrayOfTitleDTO:
		return soap_out_PointerTons3__ArrayOfTitleDTO(soap, tag, id, (ns3__ArrayOfTitleDTO *const*)ptr, "ns3:ArrayOfTitleDTO");
	case SOAP_TYPE_PointerTons3__ArrayOfIdNameDTO:
		return soap_out_PointerTons3__ArrayOfIdNameDTO(soap, tag, id, (ns3__ArrayOfIdNameDTO *const*)ptr, "ns3:ArrayOfIdNameDTO");
	case SOAP_TYPE_PointerTons3__ArrayOfUserDTO:
		return soap_out_PointerTons3__ArrayOfUserDTO(soap, tag, id, (ns3__ArrayOfUserDTO *const*)ptr, "ns3:ArrayOfUserDTO");
	case SOAP_TYPE_PointerToPointerTons3__LockDTO:
		return soap_out_PointerToPointerTons3__LockDTO(soap, tag, id, (ns3__LockDTO **const*)ptr, "ns3:LockDTO");
	case SOAP_TYPE_PointerTons3__LockDTO:
		return soap_out_PointerTons3__LockDTO(soap, tag, id, (ns3__LockDTO *const*)ptr, "ns3:LockDTO");
	case SOAP_TYPE_PointerToPointerTons3__StatusDTO:
		return soap_out_PointerToPointerTons3__StatusDTO(soap, tag, id, (ns3__StatusDTO **const*)ptr, "ns3:StatusDTO");
	case SOAP_TYPE_PointerTons3__StatusDTO:
		return soap_out_PointerTons3__StatusDTO(soap, tag, id, (ns3__StatusDTO *const*)ptr, "ns3:StatusDTO");
	case SOAP_TYPE_PointerTons3__ArrayOfStatusDTO:
		return soap_out_PointerTons3__ArrayOfStatusDTO(soap, tag, id, (ns3__ArrayOfStatusDTO *const*)ptr, "ns3:ArrayOfStatusDTO");
	case SOAP_TYPE_PointerToPointerTons3__TitleStatusDTO:
		return soap_out_PointerToPointerTons3__TitleStatusDTO(soap, tag, id, (ns3__TitleStatusDTO **const*)ptr, "ns3:TitleStatusDTO");
	case SOAP_TYPE_PointerTons3__TitleStatusDTO:
		return soap_out_PointerTons3__TitleStatusDTO(soap, tag, id, (ns3__TitleStatusDTO *const*)ptr, "ns3:TitleStatusDTO");
	case SOAP_TYPE_PointerTons3__ArrayOfShelveDTO:
		return soap_out_PointerTons3__ArrayOfShelveDTO(soap, tag, id, (ns3__ArrayOfShelveDTO *const*)ptr, "ns3:ArrayOfShelveDTO");
	case SOAP_TYPE_PointerToPointerTons3__EditionTitlesDTO:
		return soap_out_PointerToPointerTons3__EditionTitlesDTO(soap, tag, id, (ns3__EditionTitlesDTO **const*)ptr, "ns3:EditionTitlesDTO");
	case SOAP_TYPE_PointerTons3__EditionTitlesDTO:
		return soap_out_PointerTons3__EditionTitlesDTO(soap, tag, id, (ns3__EditionTitlesDTO *const*)ptr, "ns3:EditionTitlesDTO");
	case SOAP_TYPE_PointerToPointerTons3__TaskDTO:
		return soap_out_PointerToPointerTons3__TaskDTO(soap, tag, id, (ns3__TaskDTO **const*)ptr, "ns3:TaskDTO");
	case SOAP_TYPE_PointerTons3__TaskDTO:
		return soap_out_PointerTons3__TaskDTO(soap, tag, id, (ns3__TaskDTO *const*)ptr, "ns3:TaskDTO");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerToPointerTons3__AssetDTO:
		return soap_out_PointerToPointerTons3__AssetDTO(soap, tag, id, (ns3__AssetDTO **const*)ptr, "ns3:AssetDTO");
	case SOAP_TYPE_PointerTons3__AssetDTO:
		return soap_out_PointerTons3__AssetDTO(soap, tag, id, (ns3__AssetDTO *const*)ptr, "ns3:AssetDTO");
	case SOAP_TYPE_PointerTons4__guid:
		return soap_out_PointerTons4__guid(soap, tag, id, (wchar_t **const*)ptr, "ns4:guid");
	case SOAP_TYPE_PointerTons3__VersionInfo:
		return soap_out_PointerTons3__VersionInfo(soap, tag, id, (ns3__VersionInfo *const*)ptr, "ns3:VersionInfo");
	case SOAP_TYPE_PointerToPointerTons3__ShelveDTO:
		return soap_out_PointerToPointerTons3__ShelveDTO(soap, tag, id, (ns3__ShelveDTO **const*)ptr, "ns3:ShelveDTO");
	case SOAP_TYPE_PointerTons3__ShelveDTO:
		return soap_out_PointerTons3__ShelveDTO(soap, tag, id, (ns3__ShelveDTO *const*)ptr, "ns3:ShelveDTO");
	case SOAP_TYPE_PointerTowstring:
		return soap_out_PointerTowstring(soap, tag, id, (wchar_t **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons3__CommentDTO:
		return soap_out_PointerToPointerTons3__CommentDTO(soap, tag, id, (ns3__CommentDTO **const*)ptr, "ns3:CommentDTO");
	case SOAP_TYPE_PointerTons3__CommentDTO:
		return soap_out_PointerTons3__CommentDTO(soap, tag, id, (ns3__CommentDTO *const*)ptr, "ns3:CommentDTO");
	case SOAP_TYPE_PointerToPointerTons3__TitleDTO:
		return soap_out_PointerToPointerTons3__TitleDTO(soap, tag, id, (ns3__TitleDTO **const*)ptr, "ns3:TitleDTO");
	case SOAP_TYPE_PointerTons3__TitleDTO:
		return soap_out_PointerTons3__TitleDTO(soap, tag, id, (ns3__TitleDTO *const*)ptr, "ns3:TitleDTO");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTons3__TaskUpdateInfo:
		return soap_out_PointerTons3__TaskUpdateInfo(soap, tag, id, (ns3__TaskUpdateInfo *const*)ptr, "ns3:TaskUpdateInfo");
	case SOAP_TYPE_PointerToPointerTons3__IdNameDTO:
		return soap_out_PointerToPointerTons3__IdNameDTO(soap, tag, id, (ns3__IdNameDTO **const*)ptr, "ns3:IdNameDTO");
	case SOAP_TYPE_PointerTons3__IdNameDTO:
		return soap_out_PointerTons3__IdNameDTO(soap, tag, id, (ns3__IdNameDTO *const*)ptr, "ns3:IdNameDTO");
	case SOAP_TYPE_PointerToPointerTons3__UserDTO:
		return soap_out_PointerToPointerTons3__UserDTO(soap, tag, id, (ns3__UserDTO **const*)ptr, "ns3:UserDTO");
	case SOAP_TYPE_PointerTons3__UserDTO:
		return soap_out_PointerTons3__UserDTO(soap, tag, id, (ns3__UserDTO *const*)ptr, "ns3:UserDTO");
	case SOAP_TYPE_ns4__guid:
		return soap_out_wstring(soap, tag, id, (wchar_t*const*)&ptr, "ns4:guid");
	case SOAP_TYPE_wstring:
		return soap_out_wstring(soap, tag, id, (wchar_t*const*)&ptr, "xsd:string");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_PointerTo_wsrp__path:
		return soap_out_PointerTo_wsrp__path(soap, tag, id, (struct wsrp__path_USCOREt *const*)ptr, "wsrp:path");
	case SOAP_TYPE_PointerTo_wsse__Security:
		return soap_out_PointerTo_wsse__Security(soap, tag, id, (struct _wsse__Security *const*)ptr, "wsse:Security");
	case SOAP_TYPE_PointerTods__SignatureType:
		return soap_out_PointerTods__SignatureType(soap, tag, id, (struct ds__SignatureType *const*)ptr, "ds:SignatureType");
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		return soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag, id, (struct _wsse__BinarySecurityToken *const*)ptr, "wsse:BinarySecurityToken");
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		return soap_out_PointerTo_wsse__UsernameToken(soap, tag, id, (struct _wsse__UsernameToken *const*)ptr, "wsse:UsernameToken");
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		return soap_out_PointerTo_wsu__Timestamp(soap, tag, id, (struct _wsu__Timestamp *const*)ptr, "wsu:Timestamp");
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		return soap_out_PointerTods__X509IssuerSerialType(soap, tag, id, (struct ds__X509IssuerSerialType *const*)ptr, "ds:X509IssuerSerialType");
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		return soap_out_PointerTods__RSAKeyValueType(soap, tag, id, (struct ds__RSAKeyValueType *const*)ptr, "ds:RSAKeyValueType");
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		return soap_out_PointerTods__DSAKeyValueType(soap, tag, id, (struct ds__DSAKeyValueType *const*)ptr, "ds:DSAKeyValueType");
	case SOAP_TYPE_PointerTods__TransformType:
		return soap_out_PointerTods__TransformType(soap, tag, id, (struct ds__TransformType *const*)ptr, "ds:TransformType");
	case SOAP_TYPE_PointerTods__DigestMethodType:
		return soap_out_PointerTods__DigestMethodType(soap, tag, id, (struct ds__DigestMethodType *const*)ptr, "ds:DigestMethodType");
	case SOAP_TYPE_PointerTods__TransformsType:
		return soap_out_PointerTods__TransformsType(soap, tag, id, (struct ds__TransformsType *const*)ptr, "ds:TransformsType");
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		return soap_out_PointerToPointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType **const*)ptr, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__ReferenceType:
		return soap_out_PointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType *const*)ptr, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		return soap_out_PointerTods__SignatureMethodType(soap, tag, id, (struct ds__SignatureMethodType *const*)ptr, "ds:SignatureMethodType");
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		return soap_out_PointerTods__CanonicalizationMethodType(soap, tag, id, (struct ds__CanonicalizationMethodType *const*)ptr, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		return soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag, id, (struct _wsse__SecurityTokenReference *const*)ptr, "wsse:SecurityTokenReference");
	case SOAP_TYPE_PointerTods__X509DataType:
		return soap_out_PointerTods__X509DataType(soap, tag, id, (struct ds__X509DataType *const*)ptr, "ds:X509DataType");
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		return soap_out_PointerTods__RetrievalMethodType(soap, tag, id, (struct ds__RetrievalMethodType *const*)ptr, "ds:RetrievalMethodType");
	case SOAP_TYPE_PointerTods__KeyValueType:
		return soap_out_PointerTods__KeyValueType(soap, tag, id, (struct ds__KeyValueType *const*)ptr, "ds:KeyValueType");
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		return soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag, id, (struct _c14n__InclusiveNamespaces *const*)ptr, "c14n:InclusiveNamespaces");
	case SOAP_TYPE_PointerTods__KeyInfoType:
		return soap_out_PointerTods__KeyInfoType(soap, tag, id, (struct ds__KeyInfoType *const*)ptr, "ds:KeyInfoType");
	case SOAP_TYPE_PointerTods__SignedInfoType:
		return soap_out_PointerTods__SignedInfoType(soap, tag, id, (struct ds__SignedInfoType *const*)ptr, "ds:SignedInfoType");
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		return soap_out_PointerTo_wsse__Embedded(soap, tag, id, (struct _wsse__Embedded *const*)ptr, "wsse:Embedded");
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		return soap_out_PointerTo_wsse__KeyIdentifier(soap, tag, id, (struct _wsse__KeyIdentifier *const*)ptr, "wsse:KeyIdentifier");
	case SOAP_TYPE_PointerTo_wsse__Reference:
		return soap_out_PointerTo_wsse__Reference(soap, tag, id, (struct _wsse__Reference *const*)ptr, "wsse:Reference");
	case SOAP_TYPE_PointerTo_wsse__Password:
		return soap_out_PointerTo_wsse__Password(soap, tag, id, (struct _wsse__Password *const*)ptr, "wsse:Password");
	case SOAP_TYPE_PointerTo_wsa__FaultTo:
		return soap_out_PointerTo_wsa__FaultTo(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:FaultTo");
	case SOAP_TYPE_PointerTo_wsa__ReplyTo:
		return soap_out_PointerTo_wsa__ReplyTo(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa__From:
		return soap_out_PointerTo_wsa__From(soap, tag, id, (struct wsa__EndpointReferenceType *const*)ptr, "wsa:From");
	case SOAP_TYPE_PointerTo_wsa__RelatesTo:
		return soap_out_PointerTo_wsa__RelatesTo(soap, tag, id, (struct wsa__Relationship *const*)ptr, "wsa:RelatesTo");
	case SOAP_TYPE__wsa__Action:
		return soap_out_string(soap, "wsa:Action", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__wsa__To:
		return soap_out_string(soap, "wsa:To", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__wsa__MessageID:
		return soap_out_string(soap, "wsa:MessageID", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_PointerTowsa__ServiceNameType:
		return soap_out_PointerTowsa__ServiceNameType(soap, tag, id, (struct wsa__ServiceNameType *const*)ptr, "wsa:ServiceNameType");
	case SOAP_TYPE_PointerTo_QName:
		return soap_out_PointerTo_QName(soap, tag, id, (char **const*)ptr, "xsd:QName");
	case SOAP_TYPE_PointerTowsa__ReferenceParametersType:
		return soap_out_PointerTowsa__ReferenceParametersType(soap, tag, id, (struct wsa__ReferenceParametersType *const*)ptr, "wsa:ReferenceParametersType");
	case SOAP_TYPE_PointerTowsa__ReferencePropertiesType:
		return soap_out_PointerTowsa__ReferencePropertiesType(soap, tag, id, (struct wsa__ReferencePropertiesType *const*)ptr, "wsa:ReferencePropertiesType");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTowsrp__found_USCOREt:
		return soap_out_PointerTowsrp__found_USCOREt(soap, tag, id, (struct wsrp__found_USCOREt *const*)ptr, "wsrp:found_t");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToPointerTowsrp__via_USCOREt:
		return soap_out_PointerToPointerTowsrp__via_USCOREt(soap, tag, id, (struct wsrp__via_USCOREt **const*)ptr, "wsrp:via_t");
	case SOAP_TYPE_PointerTowsrp__via_USCOREt:
		return soap_out_PointerTowsrp__via_USCOREt(soap, tag, id, (struct wsrp__via_USCOREt *const*)ptr, "wsrp:via_t");
	case SOAP_TYPE_PointerTowsrp__fault_USCOREt:
		return soap_out_PointerTowsrp__fault_USCOREt(soap, tag, id, (struct wsrp__fault_USCOREt *const*)ptr, "wsrp:fault_t");
	case SOAP_TYPE_PointerTowsrp__rev_USCOREt:
		return soap_out_PointerTowsrp__rev_USCOREt(soap, tag, id, (struct wsrp__rev_USCOREt *const*)ptr, "wsrp:rev_t");
	case SOAP_TYPE_PointerTowsrp__fwd_USCOREt:
		return soap_out_PointerTowsrp__fwd_USCOREt(soap, tag, id, (struct wsrp__fwd_USCOREt *const*)ptr, "wsrp:fwd_t");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns3__DownloadVersionResponse:
		((_ns3__DownloadVersionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__DownloadVersion:
		((_ns3__DownloadVersion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__CheckInAssetResponse:
		((_ns3__CheckInAssetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__CheckInAsset:
		((_ns3__CheckInAsset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetLockResponse:
		((_ns3__GetLockResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetLock:
		((_ns3__GetLock *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__UpdateAssetStatusResponse:
		((_ns3__UpdateAssetStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__UpdateAssetStatus:
		((_ns3__UpdateAssetStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__UpdateAssetResponse:
		((_ns3__UpdateAssetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__UpdateAsset:
		((_ns3__UpdateAsset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetAssetListResponse:
		((_ns3__GetAssetListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetAssetList:
		((_ns3__GetAssetList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetStatusByTitleResponse:
		((_ns3__GetStatusByTitleResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetStatusByTitle:
		((_ns3__GetStatusByTitle *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetEditionsByTitleResponse:
		((_ns3__GetEditionsByTitleResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetEditionsByTitle:
		((_ns3__GetEditionsByTitle *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__CheckOutAssetResponse:
		((_ns3__CheckOutAssetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__CheckOutAsset:
		((_ns3__CheckOutAsset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetEditionTaskListResponse:
		((_ns3__GetEditionTaskListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetEditionTaskList:
		((_ns3__GetEditionTaskList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__RelinkAssetResponse:
		((_ns3__RelinkAssetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__RelinkAsset:
		((_ns3__RelinkAsset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__UnlinkAssetResponse:
		((_ns3__UnlinkAssetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__UnlinkAsset:
		((_ns3__UnlinkAsset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__UploadExportResponse:
		((_ns3__UploadExportResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__UploadExport:
		((_ns3__UploadExport *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__UploadVersionResponse:
		((_ns3__UploadVersionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__UploadVersion:
		((_ns3__UploadVersion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__UploadPageResponse:
		((_ns3__UploadPageResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__UploadPage:
		((_ns3__UploadPage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__UploadPDFResponse:
		((_ns3__UploadPDFResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__UploadPDF:
		((_ns3__UploadPDF *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetAssetResponse:
		((_ns3__GetAssetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetAsset:
		((_ns3__GetAsset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__CanUpdateAssetNameResponse:
		((_ns3__CanUpdateAssetNameResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__CanUpdateAssetName:
		((_ns3__CanUpdateAssetName *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__UpdateAssetNameResponse:
		((_ns3__UpdateAssetNameResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__UpdateAssetName:
		((_ns3__UpdateAssetName *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__CreateAssetResponse:
		((_ns3__CreateAssetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__CreateAsset:
		((_ns3__CreateAsset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__DeleteAssetResponse:
		((_ns3__DeleteAssetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__DeleteAsset:
		((_ns3__DeleteAsset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__UnlockAssetResponse:
		((_ns3__UnlockAssetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__UnlockAsset:
		((_ns3__UnlockAsset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__LockAssetResponse:
		((_ns3__LockAssetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__LockAsset:
		((_ns3__LockAsset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetThumbnailResponse:
		((_ns3__GetThumbnailResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetThumbnail:
		((_ns3__GetThumbnail *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetUserResponse:
		((_ns3__GetUserResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetUser:
		((_ns3__GetUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__LogoffResponse:
		((_ns3__LogoffResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__Logoff:
		((_ns3__Logoff *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetShelveListResponse:
		((_ns3__GetShelveListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetShelveList:
		((_ns3__GetShelveList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetTagsResponse:
		((_ns3__GetTagsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetTags:
		((_ns3__GetTags *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetCommentListResponse:
		((_ns3__GetCommentListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetCommentList:
		((_ns3__GetCommentList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetRoleResponse:
		((_ns3__GetRoleResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetRole:
		((_ns3__GetRole *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetTitleListResponse:
		((_ns3__GetTitleListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetTitleList:
		((_ns3__GetTitleList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__LoginResponse:
		((_ns3__LoginResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__Login:
		((_ns3__Login *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__DeleteTaskResponse:
		((_ns3__DeleteTaskResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__DeleteTask:
		((_ns3__DeleteTask *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetTaskHistoryResponse:
		((_ns3__GetTaskHistoryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetTaskHistory:
		((_ns3__GetTaskHistory *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__UpdateTaskResponse:
		((_ns3__UpdateTaskResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__UpdateTask:
		((_ns3__UpdateTask *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetTaskCategoryListResponse:
		((_ns3__GetTaskCategoryListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetTaskCategoryList:
		((_ns3__GetTaskCategoryList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__CreateTaskResponse:
		((_ns3__CreateTaskResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__CreateTask:
		((_ns3__CreateTask *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetTaskStatusListResponse:
		((_ns3__GetTaskStatusListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetTaskStatusList:
		((_ns3__GetTaskStatusList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetUsersForTitleResponse:
		((_ns3__GetUsersForTitleResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns3__GetUsersForTitle:
		((_ns3__GetUsersForTitle *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ArrayOfLockDTO:
		((ns3__ArrayOfLockDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__StatusDTO:
		((ns3__StatusDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ArrayOfStatusDTO:
		((ns3__ArrayOfStatusDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__TitleStatusDTO:
		((ns3__TitleStatusDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ArrayOfTitleStatusDTO:
		((ns3__ArrayOfTitleStatusDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__EditionTitlesDTO:
		((ns3__EditionTitlesDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ArrayOfEditionTitlesDTO:
		((ns3__ArrayOfEditionTitlesDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ArrayOfTaskDTO:
		((ns3__ArrayOfTaskDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__VersionDTO:
		((ns3__VersionDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ArrayOfAssetDTO:
		((ns3__ArrayOfAssetDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ArrayOfGuid:
		((ns3__ArrayOfGuid *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__VersionInfo:
		((ns3__VersionInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__AssetDTO:
		((ns3__AssetDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__LockDTO:
		((ns3__LockDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ShelveDTO:
		((ns3__ShelveDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ArrayOfShelveDTO:
		((ns3__ArrayOfShelveDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ArrayOfString:
		((ns3__ArrayOfString *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__CommentDTO:
		((ns3__CommentDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ArrayOfCommentDTO:
		((ns3__ArrayOfCommentDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ConstantDTO:
		((ns3__ConstantDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__TitleDTO:
		((ns3__TitleDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ArrayOfTitleDTO:
		((ns3__ArrayOfTitleDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__TaskUpdateInfo:
		((ns3__TaskUpdateInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__TaskDTO:
		((ns3__TaskDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__IdNameDTO:
		((ns3__IdNameDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ArrayOfIdNameDTO:
		((ns3__ArrayOfIdNameDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__UserDTO:
		((ns3__UserDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__ArrayOfUserDTO:
		((ns3__ArrayOfUserDTO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__DownloadVersion:
		soap_serialize___ns1__DownloadVersion(soap, (const struct __ns1__DownloadVersion *)ptr);
		break;
	case SOAP_TYPE___ns1__CheckInAsset:
		soap_serialize___ns1__CheckInAsset(soap, (const struct __ns1__CheckInAsset *)ptr);
		break;
	case SOAP_TYPE___ns1__GetLock:
		soap_serialize___ns1__GetLock(soap, (const struct __ns1__GetLock *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdateAssetStatus:
		soap_serialize___ns1__UpdateAssetStatus(soap, (const struct __ns1__UpdateAssetStatus *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdateAsset:
		soap_serialize___ns1__UpdateAsset(soap, (const struct __ns1__UpdateAsset *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAssetList:
		soap_serialize___ns1__GetAssetList(soap, (const struct __ns1__GetAssetList *)ptr);
		break;
	case SOAP_TYPE___ns1__GetStatusByTitle:
		soap_serialize___ns1__GetStatusByTitle(soap, (const struct __ns1__GetStatusByTitle *)ptr);
		break;
	case SOAP_TYPE___ns1__GetEditionsByTitle:
		soap_serialize___ns1__GetEditionsByTitle(soap, (const struct __ns1__GetEditionsByTitle *)ptr);
		break;
	case SOAP_TYPE___ns1__CheckOutAsset:
		soap_serialize___ns1__CheckOutAsset(soap, (const struct __ns1__CheckOutAsset *)ptr);
		break;
	case SOAP_TYPE___ns1__GetEditionTaskList:
		soap_serialize___ns1__GetEditionTaskList(soap, (const struct __ns1__GetEditionTaskList *)ptr);
		break;
	case SOAP_TYPE___ns1__RelinkAsset:
		soap_serialize___ns1__RelinkAsset(soap, (const struct __ns1__RelinkAsset *)ptr);
		break;
	case SOAP_TYPE___ns1__UnlinkAsset:
		soap_serialize___ns1__UnlinkAsset(soap, (const struct __ns1__UnlinkAsset *)ptr);
		break;
	case SOAP_TYPE___ns1__UploadExport:
		soap_serialize___ns1__UploadExport(soap, (const struct __ns1__UploadExport *)ptr);
		break;
	case SOAP_TYPE___ns1__UploadVersion:
		soap_serialize___ns1__UploadVersion(soap, (const struct __ns1__UploadVersion *)ptr);
		break;
	case SOAP_TYPE___ns1__UploadPage:
		soap_serialize___ns1__UploadPage(soap, (const struct __ns1__UploadPage *)ptr);
		break;
	case SOAP_TYPE___ns1__UploadPDF:
		soap_serialize___ns1__UploadPDF(soap, (const struct __ns1__UploadPDF *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAsset:
		soap_serialize___ns1__GetAsset(soap, (const struct __ns1__GetAsset *)ptr);
		break;
	case SOAP_TYPE___ns1__CanUpdateAssetName:
		soap_serialize___ns1__CanUpdateAssetName(soap, (const struct __ns1__CanUpdateAssetName *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdateAssetName:
		soap_serialize___ns1__UpdateAssetName(soap, (const struct __ns1__UpdateAssetName *)ptr);
		break;
	case SOAP_TYPE___ns1__CreateAsset:
		soap_serialize___ns1__CreateAsset(soap, (const struct __ns1__CreateAsset *)ptr);
		break;
	case SOAP_TYPE___ns1__DeleteAsset:
		soap_serialize___ns1__DeleteAsset(soap, (const struct __ns1__DeleteAsset *)ptr);
		break;
	case SOAP_TYPE___ns1__UnlockAsset:
		soap_serialize___ns1__UnlockAsset(soap, (const struct __ns1__UnlockAsset *)ptr);
		break;
	case SOAP_TYPE___ns1__LockAsset:
		soap_serialize___ns1__LockAsset(soap, (const struct __ns1__LockAsset *)ptr);
		break;
	case SOAP_TYPE___ns1__GetThumbnail:
		soap_serialize___ns1__GetThumbnail(soap, (const struct __ns1__GetThumbnail *)ptr);
		break;
	case SOAP_TYPE___ns1__GetUser:
		soap_serialize___ns1__GetUser(soap, (const struct __ns1__GetUser *)ptr);
		break;
	case SOAP_TYPE___ns1__Logoff:
		soap_serialize___ns1__Logoff(soap, (const struct __ns1__Logoff *)ptr);
		break;
	case SOAP_TYPE___ns1__GetShelveList:
		soap_serialize___ns1__GetShelveList(soap, (const struct __ns1__GetShelveList *)ptr);
		break;
	case SOAP_TYPE___ns1__GetTags:
		soap_serialize___ns1__GetTags(soap, (const struct __ns1__GetTags *)ptr);
		break;
	case SOAP_TYPE___ns1__GetCommentList:
		soap_serialize___ns1__GetCommentList(soap, (const struct __ns1__GetCommentList *)ptr);
		break;
	case SOAP_TYPE___ns1__GetRole:
		soap_serialize___ns1__GetRole(soap, (const struct __ns1__GetRole *)ptr);
		break;
	case SOAP_TYPE___ns1__GetTitleList:
		soap_serialize___ns1__GetTitleList(soap, (const struct __ns1__GetTitleList *)ptr);
		break;
	case SOAP_TYPE___ns1__Login:
		soap_serialize___ns1__Login(soap, (const struct __ns1__Login *)ptr);
		break;
	case SOAP_TYPE___ns1__DeleteTask:
		soap_serialize___ns1__DeleteTask(soap, (const struct __ns1__DeleteTask *)ptr);
		break;
	case SOAP_TYPE___ns1__GetTaskHistory:
		soap_serialize___ns1__GetTaskHistory(soap, (const struct __ns1__GetTaskHistory *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdateTask:
		soap_serialize___ns1__UpdateTask(soap, (const struct __ns1__UpdateTask *)ptr);
		break;
	case SOAP_TYPE___ns1__GetTaskCategoryList:
		soap_serialize___ns1__GetTaskCategoryList(soap, (const struct __ns1__GetTaskCategoryList *)ptr);
		break;
	case SOAP_TYPE___ns1__CreateTask:
		soap_serialize___ns1__CreateTask(soap, (const struct __ns1__CreateTask *)ptr);
		break;
	case SOAP_TYPE___ns1__GetTaskStatusList:
		soap_serialize___ns1__GetTaskStatusList(soap, (const struct __ns1__GetTaskStatusList *)ptr);
		break;
	case SOAP_TYPE___ns1__GetUsersForTitle:
		soap_serialize___ns1__GetUsersForTitle(soap, (const struct __ns1__GetUsersForTitle *)ptr);
		break;
	case SOAP_TYPE__xop__Include:
		soap_serialize__xop__Include(soap, (const struct _xop__Include *)ptr);
		break;
	case SOAP_TYPE__wsse__Security:
		soap_serialize__wsse__Security(soap, (const struct _wsse__Security *)ptr);
		break;
	case SOAP_TYPE_ds__RSAKeyValueType:
		soap_serialize_ds__RSAKeyValueType(soap, (const struct ds__RSAKeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__DSAKeyValueType:
		soap_serialize_ds__DSAKeyValueType(soap, (const struct ds__DSAKeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__X509IssuerSerialType:
		soap_serialize_ds__X509IssuerSerialType(soap, (const struct ds__X509IssuerSerialType *)ptr);
		break;
	case SOAP_TYPE_ds__X509DataType:
		soap_serialize_ds__X509DataType(soap, (const struct ds__X509DataType *)ptr);
		break;
	case SOAP_TYPE_ds__RetrievalMethodType:
		soap_serialize_ds__RetrievalMethodType(soap, (const struct ds__RetrievalMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__KeyValueType:
		soap_serialize_ds__KeyValueType(soap, (const struct ds__KeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__DigestMethodType:
		soap_serialize_ds__DigestMethodType(soap, (const struct ds__DigestMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__TransformType:
		soap_serialize_ds__TransformType(soap, (const struct ds__TransformType *)ptr);
		break;
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		soap_serialize__c14n__InclusiveNamespaces(soap, (const struct _c14n__InclusiveNamespaces *)ptr);
		break;
	case SOAP_TYPE_ds__TransformsType:
		soap_serialize_ds__TransformsType(soap, (const struct ds__TransformsType *)ptr);
		break;
	case SOAP_TYPE_ds__ReferenceType:
		soap_serialize_ds__ReferenceType(soap, (const struct ds__ReferenceType *)ptr);
		break;
	case SOAP_TYPE_ds__SignatureMethodType:
		soap_serialize_ds__SignatureMethodType(soap, (const struct ds__SignatureMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		soap_serialize_ds__CanonicalizationMethodType(soap, (const struct ds__CanonicalizationMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__KeyInfoType:
		soap_serialize_ds__KeyInfoType(soap, (const struct ds__KeyInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__SignedInfoType:
		soap_serialize_ds__SignedInfoType(soap, (const struct ds__SignedInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__SignatureType:
		soap_serialize_ds__SignatureType(soap, (const struct ds__SignatureType *)ptr);
		break;
	case SOAP_TYPE__wsse__SecurityTokenReference:
		soap_serialize__wsse__SecurityTokenReference(soap, (const struct _wsse__SecurityTokenReference *)ptr);
		break;
	case SOAP_TYPE__wsse__KeyIdentifier:
		soap_serialize__wsse__KeyIdentifier(soap, (const struct _wsse__KeyIdentifier *)ptr);
		break;
	case SOAP_TYPE__wsse__Embedded:
		soap_serialize__wsse__Embedded(soap, (const struct _wsse__Embedded *)ptr);
		break;
	case SOAP_TYPE__wsse__Reference:
		soap_serialize__wsse__Reference(soap, (const struct _wsse__Reference *)ptr);
		break;
	case SOAP_TYPE__wsse__BinarySecurityToken:
		soap_serialize__wsse__BinarySecurityToken(soap, (const struct _wsse__BinarySecurityToken *)ptr);
		break;
	case SOAP_TYPE__wsse__Password:
		soap_serialize__wsse__Password(soap, (const struct _wsse__Password *)ptr);
		break;
	case SOAP_TYPE__wsse__UsernameToken:
		soap_serialize__wsse__UsernameToken(soap, (const struct _wsse__UsernameToken *)ptr);
		break;
	case SOAP_TYPE__wsu__Timestamp:
		soap_serialize__wsu__Timestamp(soap, (const struct _wsu__Timestamp *)ptr);
		break;
	case SOAP_TYPE__wsa__FaultTo:
		soap_serialize__wsa__FaultTo(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa__ReplyTo:
		soap_serialize__wsa__ReplyTo(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa__From:
		soap_serialize__wsa__From(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa__RelatesTo:
		soap_serialize__wsa__RelatesTo(soap, (const struct wsa__Relationship *)ptr);
		break;
	case SOAP_TYPE__wsa__EndpointReference:
		soap_serialize__wsa__EndpointReference(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_wsa__Relationship:
		soap_serialize_wsa__Relationship(soap, (const struct wsa__Relationship *)ptr);
		break;
	case SOAP_TYPE_wsa__ServiceNameType:
		soap_serialize_wsa__ServiceNameType(soap, (const struct wsa__ServiceNameType *)ptr);
		break;
	case SOAP_TYPE_wsa__ReferenceParametersType:
		soap_serialize_wsa__ReferenceParametersType(soap, (const struct wsa__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE_wsa__ReferencePropertiesType:
		soap_serialize_wsa__ReferencePropertiesType(soap, (const struct wsa__ReferencePropertiesType *)ptr);
		break;
	case SOAP_TYPE_wsa__EndpointReferenceType:
		soap_serialize_wsa__EndpointReferenceType(soap, (const struct wsa__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsrp__via:
		soap_serialize__wsrp__via(soap, (const struct wsrp__via_USCOREt *)ptr);
		break;
	case SOAP_TYPE__wsrp__fault:
		soap_serialize__wsrp__fault(soap, (const struct wsrp__fault_USCOREt *)ptr);
		break;
	case SOAP_TYPE__wsrp__found:
		soap_serialize__wsrp__found(soap, (const struct wsrp__found_USCOREt *)ptr);
		break;
	case SOAP_TYPE__wsrp__rev:
		soap_serialize__wsrp__rev(soap, (const struct wsrp__rev_USCOREt *)ptr);
		break;
	case SOAP_TYPE__wsrp__fwd:
		soap_serialize__wsrp__fwd(soap, (const struct wsrp__fwd_USCOREt *)ptr);
		break;
	case SOAP_TYPE__wsrp__path:
		soap_serialize__wsrp__path(soap, (const struct wsrp__path_USCOREt *)ptr);
		break;
	case SOAP_TYPE_wsrp__fault_USCOREt:
		soap_serialize_wsrp__fault_USCOREt(soap, (const struct wsrp__fault_USCOREt *)ptr);
		break;
	case SOAP_TYPE_wsrp__found_USCOREt:
		soap_serialize_wsrp__found_USCOREt(soap, (const struct wsrp__found_USCOREt *)ptr);
		break;
	case SOAP_TYPE_wsrp__rev_USCOREt:
		soap_serialize_wsrp__rev_USCOREt(soap, (const struct wsrp__rev_USCOREt *)ptr);
		break;
	case SOAP_TYPE_wsrp__fwd_USCOREt:
		soap_serialize_wsrp__fwd_USCOREt(soap, (const struct wsrp__fwd_USCOREt *)ptr);
		break;
	case SOAP_TYPE_wsrp__via_USCOREt:
		soap_serialize_wsrp__via_USCOREt(soap, (const struct wsrp__via_USCOREt *)ptr);
		break;
	case SOAP_TYPE_wsrp__path_USCOREt:
		soap_serialize_wsrp__path_USCOREt(soap, (const struct wsrp__path_USCOREt *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__DownloadVersionResponse:
		soap_serialize_PointerTo_ns3__DownloadVersionResponse(soap, (_ns3__DownloadVersionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__DownloadVersion:
		soap_serialize_PointerTo_ns3__DownloadVersion(soap, (_ns3__DownloadVersion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__CheckInAssetResponse:
		soap_serialize_PointerTo_ns3__CheckInAssetResponse(soap, (_ns3__CheckInAssetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__CheckInAsset:
		soap_serialize_PointerTo_ns3__CheckInAsset(soap, (_ns3__CheckInAsset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetLockResponse:
		soap_serialize_PointerTo_ns3__GetLockResponse(soap, (_ns3__GetLockResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetLock:
		soap_serialize_PointerTo_ns3__GetLock(soap, (_ns3__GetLock *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__UpdateAssetStatusResponse:
		soap_serialize_PointerTo_ns3__UpdateAssetStatusResponse(soap, (_ns3__UpdateAssetStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__UpdateAssetStatus:
		soap_serialize_PointerTo_ns3__UpdateAssetStatus(soap, (_ns3__UpdateAssetStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__UpdateAssetResponse:
		soap_serialize_PointerTo_ns3__UpdateAssetResponse(soap, (_ns3__UpdateAssetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__UpdateAsset:
		soap_serialize_PointerTo_ns3__UpdateAsset(soap, (_ns3__UpdateAsset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetAssetListResponse:
		soap_serialize_PointerTo_ns3__GetAssetListResponse(soap, (_ns3__GetAssetListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetAssetList:
		soap_serialize_PointerTo_ns3__GetAssetList(soap, (_ns3__GetAssetList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetStatusByTitleResponse:
		soap_serialize_PointerTo_ns3__GetStatusByTitleResponse(soap, (_ns3__GetStatusByTitleResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetStatusByTitle:
		soap_serialize_PointerTo_ns3__GetStatusByTitle(soap, (_ns3__GetStatusByTitle *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetEditionsByTitleResponse:
		soap_serialize_PointerTo_ns3__GetEditionsByTitleResponse(soap, (_ns3__GetEditionsByTitleResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetEditionsByTitle:
		soap_serialize_PointerTo_ns3__GetEditionsByTitle(soap, (_ns3__GetEditionsByTitle *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__CheckOutAssetResponse:
		soap_serialize_PointerTo_ns3__CheckOutAssetResponse(soap, (_ns3__CheckOutAssetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__CheckOutAsset:
		soap_serialize_PointerTo_ns3__CheckOutAsset(soap, (_ns3__CheckOutAsset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetEditionTaskListResponse:
		soap_serialize_PointerTo_ns3__GetEditionTaskListResponse(soap, (_ns3__GetEditionTaskListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetEditionTaskList:
		soap_serialize_PointerTo_ns3__GetEditionTaskList(soap, (_ns3__GetEditionTaskList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__RelinkAssetResponse:
		soap_serialize_PointerTo_ns3__RelinkAssetResponse(soap, (_ns3__RelinkAssetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__RelinkAsset:
		soap_serialize_PointerTo_ns3__RelinkAsset(soap, (_ns3__RelinkAsset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__UnlinkAssetResponse:
		soap_serialize_PointerTo_ns3__UnlinkAssetResponse(soap, (_ns3__UnlinkAssetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__UnlinkAsset:
		soap_serialize_PointerTo_ns3__UnlinkAsset(soap, (_ns3__UnlinkAsset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__UploadExportResponse:
		soap_serialize_PointerTo_ns3__UploadExportResponse(soap, (_ns3__UploadExportResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__UploadExport:
		soap_serialize_PointerTo_ns3__UploadExport(soap, (_ns3__UploadExport *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__UploadVersionResponse:
		soap_serialize_PointerTo_ns3__UploadVersionResponse(soap, (_ns3__UploadVersionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__UploadVersion:
		soap_serialize_PointerTo_ns3__UploadVersion(soap, (_ns3__UploadVersion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__UploadPageResponse:
		soap_serialize_PointerTo_ns3__UploadPageResponse(soap, (_ns3__UploadPageResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__UploadPage:
		soap_serialize_PointerTo_ns3__UploadPage(soap, (_ns3__UploadPage *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__UploadPDFResponse:
		soap_serialize_PointerTo_ns3__UploadPDFResponse(soap, (_ns3__UploadPDFResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__UploadPDF:
		soap_serialize_PointerTo_ns3__UploadPDF(soap, (_ns3__UploadPDF *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetAssetResponse:
		soap_serialize_PointerTo_ns3__GetAssetResponse(soap, (_ns3__GetAssetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetAsset:
		soap_serialize_PointerTo_ns3__GetAsset(soap, (_ns3__GetAsset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__CanUpdateAssetNameResponse:
		soap_serialize_PointerTo_ns3__CanUpdateAssetNameResponse(soap, (_ns3__CanUpdateAssetNameResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__CanUpdateAssetName:
		soap_serialize_PointerTo_ns3__CanUpdateAssetName(soap, (_ns3__CanUpdateAssetName *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__UpdateAssetNameResponse:
		soap_serialize_PointerTo_ns3__UpdateAssetNameResponse(soap, (_ns3__UpdateAssetNameResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__UpdateAssetName:
		soap_serialize_PointerTo_ns3__UpdateAssetName(soap, (_ns3__UpdateAssetName *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__CreateAssetResponse:
		soap_serialize_PointerTo_ns3__CreateAssetResponse(soap, (_ns3__CreateAssetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__CreateAsset:
		soap_serialize_PointerTo_ns3__CreateAsset(soap, (_ns3__CreateAsset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__DeleteAssetResponse:
		soap_serialize_PointerTo_ns3__DeleteAssetResponse(soap, (_ns3__DeleteAssetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__DeleteAsset:
		soap_serialize_PointerTo_ns3__DeleteAsset(soap, (_ns3__DeleteAsset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__UnlockAssetResponse:
		soap_serialize_PointerTo_ns3__UnlockAssetResponse(soap, (_ns3__UnlockAssetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__UnlockAsset:
		soap_serialize_PointerTo_ns3__UnlockAsset(soap, (_ns3__UnlockAsset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__LockAssetResponse:
		soap_serialize_PointerTo_ns3__LockAssetResponse(soap, (_ns3__LockAssetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__LockAsset:
		soap_serialize_PointerTo_ns3__LockAsset(soap, (_ns3__LockAsset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetThumbnailResponse:
		soap_serialize_PointerTo_ns3__GetThumbnailResponse(soap, (_ns3__GetThumbnailResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetThumbnail:
		soap_serialize_PointerTo_ns3__GetThumbnail(soap, (_ns3__GetThumbnail *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetUserResponse:
		soap_serialize_PointerTo_ns3__GetUserResponse(soap, (_ns3__GetUserResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetUser:
		soap_serialize_PointerTo_ns3__GetUser(soap, (_ns3__GetUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__LogoffResponse:
		soap_serialize_PointerTo_ns3__LogoffResponse(soap, (_ns3__LogoffResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__Logoff:
		soap_serialize_PointerTo_ns3__Logoff(soap, (_ns3__Logoff *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetShelveListResponse:
		soap_serialize_PointerTo_ns3__GetShelveListResponse(soap, (_ns3__GetShelveListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetShelveList:
		soap_serialize_PointerTo_ns3__GetShelveList(soap, (_ns3__GetShelveList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetTagsResponse:
		soap_serialize_PointerTo_ns3__GetTagsResponse(soap, (_ns3__GetTagsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetTags:
		soap_serialize_PointerTo_ns3__GetTags(soap, (_ns3__GetTags *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetCommentListResponse:
		soap_serialize_PointerTo_ns3__GetCommentListResponse(soap, (_ns3__GetCommentListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetCommentList:
		soap_serialize_PointerTo_ns3__GetCommentList(soap, (_ns3__GetCommentList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetRoleResponse:
		soap_serialize_PointerTo_ns3__GetRoleResponse(soap, (_ns3__GetRoleResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetRole:
		soap_serialize_PointerTo_ns3__GetRole(soap, (_ns3__GetRole *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetTitleListResponse:
		soap_serialize_PointerTo_ns3__GetTitleListResponse(soap, (_ns3__GetTitleListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetTitleList:
		soap_serialize_PointerTo_ns3__GetTitleList(soap, (_ns3__GetTitleList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__LoginResponse:
		soap_serialize_PointerTo_ns3__LoginResponse(soap, (_ns3__LoginResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__Login:
		soap_serialize_PointerTo_ns3__Login(soap, (_ns3__Login *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__DeleteTaskResponse:
		soap_serialize_PointerTo_ns3__DeleteTaskResponse(soap, (_ns3__DeleteTaskResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__DeleteTask:
		soap_serialize_PointerTo_ns3__DeleteTask(soap, (_ns3__DeleteTask *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetTaskHistoryResponse:
		soap_serialize_PointerTo_ns3__GetTaskHistoryResponse(soap, (_ns3__GetTaskHistoryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetTaskHistory:
		soap_serialize_PointerTo_ns3__GetTaskHistory(soap, (_ns3__GetTaskHistory *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__UpdateTaskResponse:
		soap_serialize_PointerTo_ns3__UpdateTaskResponse(soap, (_ns3__UpdateTaskResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__UpdateTask:
		soap_serialize_PointerTo_ns3__UpdateTask(soap, (_ns3__UpdateTask *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetTaskCategoryListResponse:
		soap_serialize_PointerTo_ns3__GetTaskCategoryListResponse(soap, (_ns3__GetTaskCategoryListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetTaskCategoryList:
		soap_serialize_PointerTo_ns3__GetTaskCategoryList(soap, (_ns3__GetTaskCategoryList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__CreateTaskResponse:
		soap_serialize_PointerTo_ns3__CreateTaskResponse(soap, (_ns3__CreateTaskResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__CreateTask:
		soap_serialize_PointerTo_ns3__CreateTask(soap, (_ns3__CreateTask *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetTaskStatusListResponse:
		soap_serialize_PointerTo_ns3__GetTaskStatusListResponse(soap, (_ns3__GetTaskStatusListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetTaskStatusList:
		soap_serialize_PointerTo_ns3__GetTaskStatusList(soap, (_ns3__GetTaskStatusList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetUsersForTitleResponse:
		soap_serialize_PointerTo_ns3__GetUsersForTitleResponse(soap, (_ns3__GetUsersForTitleResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns3__GetUsersForTitle:
		soap_serialize_PointerTo_ns3__GetUsersForTitle(soap, (_ns3__GetUsersForTitle *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ArrayOfLockDTO:
		soap_serialize_PointerTons3__ArrayOfLockDTO(soap, (ns3__ArrayOfLockDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ArrayOfTitleStatusDTO:
		soap_serialize_PointerTons3__ArrayOfTitleStatusDTO(soap, (ns3__ArrayOfTitleStatusDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ArrayOfEditionTitlesDTO:
		soap_serialize_PointerTons3__ArrayOfEditionTitlesDTO(soap, (ns3__ArrayOfEditionTitlesDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ArrayOfTaskDTO:
		soap_serialize_PointerTons3__ArrayOfTaskDTO(soap, (ns3__ArrayOfTaskDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__VersionDTO:
		soap_serialize_PointerTons3__VersionDTO(soap, (ns3__VersionDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ArrayOfAssetDTO:
		soap_serialize_PointerTons3__ArrayOfAssetDTO(soap, (ns3__ArrayOfAssetDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ArrayOfGuid:
		soap_serialize_PointerTons3__ArrayOfGuid(soap, (ns3__ArrayOfGuid *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ArrayOfString:
		soap_serialize_PointerTons3__ArrayOfString(soap, (ns3__ArrayOfString *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ArrayOfCommentDTO:
		soap_serialize_PointerTons3__ArrayOfCommentDTO(soap, (ns3__ArrayOfCommentDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ArrayOfTitleDTO:
		soap_serialize_PointerTons3__ArrayOfTitleDTO(soap, (ns3__ArrayOfTitleDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ArrayOfIdNameDTO:
		soap_serialize_PointerTons3__ArrayOfIdNameDTO(soap, (ns3__ArrayOfIdNameDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ArrayOfUserDTO:
		soap_serialize_PointerTons3__ArrayOfUserDTO(soap, (ns3__ArrayOfUserDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__LockDTO:
		soap_serialize_PointerToPointerTons3__LockDTO(soap, (ns3__LockDTO **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__LockDTO:
		soap_serialize_PointerTons3__LockDTO(soap, (ns3__LockDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__StatusDTO:
		soap_serialize_PointerToPointerTons3__StatusDTO(soap, (ns3__StatusDTO **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__StatusDTO:
		soap_serialize_PointerTons3__StatusDTO(soap, (ns3__StatusDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ArrayOfStatusDTO:
		soap_serialize_PointerTons3__ArrayOfStatusDTO(soap, (ns3__ArrayOfStatusDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__TitleStatusDTO:
		soap_serialize_PointerToPointerTons3__TitleStatusDTO(soap, (ns3__TitleStatusDTO **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__TitleStatusDTO:
		soap_serialize_PointerTons3__TitleStatusDTO(soap, (ns3__TitleStatusDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ArrayOfShelveDTO:
		soap_serialize_PointerTons3__ArrayOfShelveDTO(soap, (ns3__ArrayOfShelveDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__EditionTitlesDTO:
		soap_serialize_PointerToPointerTons3__EditionTitlesDTO(soap, (ns3__EditionTitlesDTO **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__EditionTitlesDTO:
		soap_serialize_PointerTons3__EditionTitlesDTO(soap, (ns3__EditionTitlesDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__TaskDTO:
		soap_serialize_PointerToPointerTons3__TaskDTO(soap, (ns3__TaskDTO **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__TaskDTO:
		soap_serialize_PointerTons3__TaskDTO(soap, (ns3__TaskDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_serialize_PointerToxsd__base64Binary(soap, (xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__AssetDTO:
		soap_serialize_PointerToPointerTons3__AssetDTO(soap, (ns3__AssetDTO **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__AssetDTO:
		soap_serialize_PointerTons3__AssetDTO(soap, (ns3__AssetDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__guid:
		soap_serialize_PointerTons4__guid(soap, (wchar_t **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__VersionInfo:
		soap_serialize_PointerTons3__VersionInfo(soap, (ns3__VersionInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__ShelveDTO:
		soap_serialize_PointerToPointerTons3__ShelveDTO(soap, (ns3__ShelveDTO **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__ShelveDTO:
		soap_serialize_PointerTons3__ShelveDTO(soap, (ns3__ShelveDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstring:
		soap_serialize_PointerTowstring(soap, (wchar_t **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__CommentDTO:
		soap_serialize_PointerToPointerTons3__CommentDTO(soap, (ns3__CommentDTO **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__CommentDTO:
		soap_serialize_PointerTons3__CommentDTO(soap, (ns3__CommentDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__TitleDTO:
		soap_serialize_PointerToPointerTons3__TitleDTO(soap, (ns3__TitleDTO **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__TitleDTO:
		soap_serialize_PointerTons3__TitleDTO(soap, (ns3__TitleDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__TaskUpdateInfo:
		soap_serialize_PointerTons3__TaskUpdateInfo(soap, (ns3__TaskUpdateInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__IdNameDTO:
		soap_serialize_PointerToPointerTons3__IdNameDTO(soap, (ns3__IdNameDTO **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__IdNameDTO:
		soap_serialize_PointerTons3__IdNameDTO(soap, (ns3__IdNameDTO *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons3__UserDTO:
		soap_serialize_PointerToPointerTons3__UserDTO(soap, (ns3__UserDTO **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__UserDTO:
		soap_serialize_PointerTons3__UserDTO(soap, (ns3__UserDTO *const*)ptr);
		break;
	case SOAP_TYPE_ns4__guid:
		soap_serialize_wstring(soap, (wchar_t*const*)&ptr);
		break;
	case SOAP_TYPE_wstring:
		soap_serialize_wstring(soap, (wchar_t*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrp__path:
		soap_serialize_PointerTo_wsrp__path(soap, (struct wsrp__path_USCOREt *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Security:
		soap_serialize_PointerTo_wsse__Security(soap, (struct _wsse__Security *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignatureType:
		soap_serialize_PointerTods__SignatureType(soap, (struct ds__SignatureType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, (struct _wsse__BinarySecurityToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		soap_serialize_PointerTo_wsse__UsernameToken(soap, (struct _wsse__UsernameToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		soap_serialize_PointerTo_wsu__Timestamp(soap, (struct _wsu__Timestamp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		soap_serialize_PointerTods__X509IssuerSerialType(soap, (struct ds__X509IssuerSerialType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		soap_serialize_PointerTods__RSAKeyValueType(soap, (struct ds__RSAKeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		soap_serialize_PointerTods__DSAKeyValueType(soap, (struct ds__DSAKeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__TransformType:
		soap_serialize_PointerTods__TransformType(soap, (struct ds__TransformType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__DigestMethodType:
		soap_serialize_PointerTods__DigestMethodType(soap, (struct ds__DigestMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__TransformsType:
		soap_serialize_PointerTods__TransformsType(soap, (struct ds__TransformsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		soap_serialize_PointerToPointerTods__ReferenceType(soap, (struct ds__ReferenceType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__ReferenceType:
		soap_serialize_PointerTods__ReferenceType(soap, (struct ds__ReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		soap_serialize_PointerTods__SignatureMethodType(soap, (struct ds__SignatureMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		soap_serialize_PointerTods__CanonicalizationMethodType(soap, (struct ds__CanonicalizationMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, (struct _wsse__SecurityTokenReference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__X509DataType:
		soap_serialize_PointerTods__X509DataType(soap, (struct ds__X509DataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		soap_serialize_PointerTods__RetrievalMethodType(soap, (struct ds__RetrievalMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__KeyValueType:
		soap_serialize_PointerTods__KeyValueType(soap, (struct ds__KeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, (struct _c14n__InclusiveNamespaces *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__KeyInfoType:
		soap_serialize_PointerTods__KeyInfoType(soap, (struct ds__KeyInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignedInfoType:
		soap_serialize_PointerTods__SignedInfoType(soap, (struct ds__SignedInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		soap_serialize_PointerTo_wsse__Embedded(soap, (struct _wsse__Embedded *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		soap_serialize_PointerTo_wsse__KeyIdentifier(soap, (struct _wsse__KeyIdentifier *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Reference:
		soap_serialize_PointerTo_wsse__Reference(soap, (struct _wsse__Reference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Password:
		soap_serialize_PointerTo_wsse__Password(soap, (struct _wsse__Password *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__FaultTo:
		soap_serialize_PointerTo_wsa__FaultTo(soap, (struct wsa__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__ReplyTo:
		soap_serialize_PointerTo_wsa__ReplyTo(soap, (struct wsa__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__From:
		soap_serialize_PointerTo_wsa__From(soap, (struct wsa__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa__RelatesTo:
		soap_serialize_PointerTo_wsa__RelatesTo(soap, (struct wsa__Relationship *const*)ptr);
		break;
	case SOAP_TYPE__wsa__Action:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__wsa__To:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__wsa__MessageID:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTowsa__ServiceNameType:
		soap_serialize_PointerTowsa__ServiceNameType(soap, (struct wsa__ServiceNameType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_QName:
		soap_serialize_PointerTo_QName(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa__ReferenceParametersType:
		soap_serialize_PointerTowsa__ReferenceParametersType(soap, (struct wsa__ReferenceParametersType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa__ReferencePropertiesType:
		soap_serialize_PointerTowsa__ReferencePropertiesType(soap, (struct wsa__ReferencePropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrp__found_USCOREt:
		soap_serialize_PointerTowsrp__found_USCOREt(soap, (struct wsrp__found_USCOREt *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTowsrp__via_USCOREt:
		soap_serialize_PointerToPointerTowsrp__via_USCOREt(soap, (struct wsrp__via_USCOREt **const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrp__via_USCOREt:
		soap_serialize_PointerTowsrp__via_USCOREt(soap, (struct wsrp__via_USCOREt *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrp__fault_USCOREt:
		soap_serialize_PointerTowsrp__fault_USCOREt(soap, (struct wsrp__fault_USCOREt *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrp__rev_USCOREt:
		soap_serialize_PointerTowsrp__rev_USCOREt(soap, (struct wsrp__rev_USCOREt *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrp__fwd_USCOREt:
		soap_serialize_PointerTowsrp__fwd_USCOREt(soap, (struct wsrp__fwd_USCOREt *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_wsrp__path_USCOREt:
		return (void*)soap_instantiate_wsrp__path_USCOREt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrp__fwd_USCOREt:
		return (void*)soap_instantiate_wsrp__fwd_USCOREt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrp__rev_USCOREt:
		return (void*)soap_instantiate_wsrp__rev_USCOREt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrp__found_USCOREt:
		return (void*)soap_instantiate_wsrp__found_USCOREt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrp__fault_USCOREt:
		return (void*)soap_instantiate_wsrp__fault_USCOREt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrp__via_USCOREt:
		return (void*)soap_instantiate_wsrp__via_USCOREt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa__EndpointReferenceType:
		return (void*)soap_instantiate_wsa__EndpointReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa__ReferencePropertiesType:
		return (void*)soap_instantiate_wsa__ReferencePropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa__ReferenceParametersType:
		return (void*)soap_instantiate_wsa__ReferenceParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa__ServiceNameType:
		return (void*)soap_instantiate_wsa__ServiceNameType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa__Relationship:
		return (void*)soap_instantiate_wsa__Relationship(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE__wsu__Timestamp:
		return (void*)soap_instantiate__wsu__Timestamp(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__UsernameToken:
		return (void*)soap_instantiate__wsse__UsernameToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__BinarySecurityToken:
		return (void*)soap_instantiate__wsse__BinarySecurityToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Reference:
		return (void*)soap_instantiate__wsse__Reference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Embedded:
		return (void*)soap_instantiate__wsse__Embedded(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__KeyIdentifier:
		return (void*)soap_instantiate__wsse__KeyIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__SecurityTokenReference:
		return (void*)soap_instantiate__wsse__SecurityTokenReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__SignatureType:
		return (void*)soap_instantiate_ds__SignatureType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		return (void*)soap_instantiate__c14n__InclusiveNamespaces(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__TransformType:
		return (void*)soap_instantiate_ds__TransformType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__KeyInfoType:
		return (void*)soap_instantiate_ds__KeyInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__SignedInfoType:
		return (void*)soap_instantiate_ds__SignedInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return (void*)soap_instantiate_ds__CanonicalizationMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__SignatureMethodType:
		return (void*)soap_instantiate_ds__SignatureMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__ReferenceType:
		return (void*)soap_instantiate_ds__ReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__TransformsType:
		return (void*)soap_instantiate_ds__TransformsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__DigestMethodType:
		return (void*)soap_instantiate_ds__DigestMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__KeyValueType:
		return (void*)soap_instantiate_ds__KeyValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__RetrievalMethodType:
		return (void*)soap_instantiate_ds__RetrievalMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__X509DataType:
		return (void*)soap_instantiate_ds__X509DataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return (void*)soap_instantiate_ds__X509IssuerSerialType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__DSAKeyValueType:
		return (void*)soap_instantiate_ds__DSAKeyValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__RSAKeyValueType:
		return (void*)soap_instantiate_ds__RSAKeyValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Security:
		return (void*)soap_instantiate__wsse__Security(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Password:
		return (void*)soap_instantiate__wsse__Password(soap, -1, type, arrayType, n);
	case SOAP_TYPE__xop__Include:
		return (void*)soap_instantiate__xop__Include(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ArrayOfUserDTO:
		return (void*)soap_instantiate_ns3__ArrayOfUserDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__UserDTO:
		return (void*)soap_instantiate_ns3__UserDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ArrayOfIdNameDTO:
		return (void*)soap_instantiate_ns3__ArrayOfIdNameDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__IdNameDTO:
		return (void*)soap_instantiate_ns3__IdNameDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__TaskDTO:
		return (void*)soap_instantiate_ns3__TaskDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__TaskUpdateInfo:
		return (void*)soap_instantiate_ns3__TaskUpdateInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ArrayOfTitleDTO:
		return (void*)soap_instantiate_ns3__ArrayOfTitleDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ConstantDTO:
		return (void*)soap_instantiate_ns3__ConstantDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ArrayOfCommentDTO:
		return (void*)soap_instantiate_ns3__ArrayOfCommentDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__CommentDTO:
		return (void*)soap_instantiate_ns3__CommentDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ArrayOfString:
		return (void*)soap_instantiate_ns3__ArrayOfString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ArrayOfShelveDTO:
		return (void*)soap_instantiate_ns3__ArrayOfShelveDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ShelveDTO:
		return (void*)soap_instantiate_ns3__ShelveDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__LockDTO:
		return (void*)soap_instantiate_ns3__LockDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__AssetDTO:
		return (void*)soap_instantiate_ns3__AssetDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__VersionInfo:
		return (void*)soap_instantiate_ns3__VersionInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ArrayOfGuid:
		return (void*)soap_instantiate_ns3__ArrayOfGuid(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ArrayOfAssetDTO:
		return (void*)soap_instantiate_ns3__ArrayOfAssetDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__VersionDTO:
		return (void*)soap_instantiate_ns3__VersionDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ArrayOfTaskDTO:
		return (void*)soap_instantiate_ns3__ArrayOfTaskDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ArrayOfEditionTitlesDTO:
		return (void*)soap_instantiate_ns3__ArrayOfEditionTitlesDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__EditionTitlesDTO:
		return (void*)soap_instantiate_ns3__EditionTitlesDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ArrayOfTitleStatusDTO:
		return (void*)soap_instantiate_ns3__ArrayOfTitleStatusDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__TitleStatusDTO:
		return (void*)soap_instantiate_ns3__TitleStatusDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ArrayOfStatusDTO:
		return (void*)soap_instantiate_ns3__ArrayOfStatusDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__StatusDTO:
		return (void*)soap_instantiate_ns3__StatusDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__ArrayOfLockDTO:
		return (void*)soap_instantiate_ns3__ArrayOfLockDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetUsersForTitle:
		return (void*)soap_instantiate__ns3__GetUsersForTitle(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetUsersForTitleResponse:
		return (void*)soap_instantiate__ns3__GetUsersForTitleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetTaskStatusList:
		return (void*)soap_instantiate__ns3__GetTaskStatusList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetTaskStatusListResponse:
		return (void*)soap_instantiate__ns3__GetTaskStatusListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__CreateTask:
		return (void*)soap_instantiate__ns3__CreateTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__CreateTaskResponse:
		return (void*)soap_instantiate__ns3__CreateTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetTaskCategoryList:
		return (void*)soap_instantiate__ns3__GetTaskCategoryList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetTaskCategoryListResponse:
		return (void*)soap_instantiate__ns3__GetTaskCategoryListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__UpdateTask:
		return (void*)soap_instantiate__ns3__UpdateTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__UpdateTaskResponse:
		return (void*)soap_instantiate__ns3__UpdateTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetTaskHistory:
		return (void*)soap_instantiate__ns3__GetTaskHistory(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetTaskHistoryResponse:
		return (void*)soap_instantiate__ns3__GetTaskHistoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__DeleteTask:
		return (void*)soap_instantiate__ns3__DeleteTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__DeleteTaskResponse:
		return (void*)soap_instantiate__ns3__DeleteTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__Login:
		return (void*)soap_instantiate__ns3__Login(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__LoginResponse:
		return (void*)soap_instantiate__ns3__LoginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetTitleList:
		return (void*)soap_instantiate__ns3__GetTitleList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetTitleListResponse:
		return (void*)soap_instantiate__ns3__GetTitleListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetRole:
		return (void*)soap_instantiate__ns3__GetRole(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetRoleResponse:
		return (void*)soap_instantiate__ns3__GetRoleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetCommentList:
		return (void*)soap_instantiate__ns3__GetCommentList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetCommentListResponse:
		return (void*)soap_instantiate__ns3__GetCommentListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetTags:
		return (void*)soap_instantiate__ns3__GetTags(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetTagsResponse:
		return (void*)soap_instantiate__ns3__GetTagsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetShelveList:
		return (void*)soap_instantiate__ns3__GetShelveList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetShelveListResponse:
		return (void*)soap_instantiate__ns3__GetShelveListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__Logoff:
		return (void*)soap_instantiate__ns3__Logoff(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__LogoffResponse:
		return (void*)soap_instantiate__ns3__LogoffResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetUser:
		return (void*)soap_instantiate__ns3__GetUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetUserResponse:
		return (void*)soap_instantiate__ns3__GetUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetThumbnail:
		return (void*)soap_instantiate__ns3__GetThumbnail(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetThumbnailResponse:
		return (void*)soap_instantiate__ns3__GetThumbnailResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__LockAsset:
		return (void*)soap_instantiate__ns3__LockAsset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__LockAssetResponse:
		return (void*)soap_instantiate__ns3__LockAssetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__UnlockAsset:
		return (void*)soap_instantiate__ns3__UnlockAsset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__UnlockAssetResponse:
		return (void*)soap_instantiate__ns3__UnlockAssetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__DeleteAsset:
		return (void*)soap_instantiate__ns3__DeleteAsset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__DeleteAssetResponse:
		return (void*)soap_instantiate__ns3__DeleteAssetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__CreateAsset:
		return (void*)soap_instantiate__ns3__CreateAsset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__CreateAssetResponse:
		return (void*)soap_instantiate__ns3__CreateAssetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__UpdateAssetName:
		return (void*)soap_instantiate__ns3__UpdateAssetName(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__UpdateAssetNameResponse:
		return (void*)soap_instantiate__ns3__UpdateAssetNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__CanUpdateAssetName:
		return (void*)soap_instantiate__ns3__CanUpdateAssetName(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__CanUpdateAssetNameResponse:
		return (void*)soap_instantiate__ns3__CanUpdateAssetNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetAsset:
		return (void*)soap_instantiate__ns3__GetAsset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetAssetResponse:
		return (void*)soap_instantiate__ns3__GetAssetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__UploadPDF:
		return (void*)soap_instantiate__ns3__UploadPDF(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__UploadPDFResponse:
		return (void*)soap_instantiate__ns3__UploadPDFResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__UploadPage:
		return (void*)soap_instantiate__ns3__UploadPage(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__UploadPageResponse:
		return (void*)soap_instantiate__ns3__UploadPageResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__UploadVersion:
		return (void*)soap_instantiate__ns3__UploadVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__UploadVersionResponse:
		return (void*)soap_instantiate__ns3__UploadVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__UploadExport:
		return (void*)soap_instantiate__ns3__UploadExport(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__UploadExportResponse:
		return (void*)soap_instantiate__ns3__UploadExportResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__UnlinkAsset:
		return (void*)soap_instantiate__ns3__UnlinkAsset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__UnlinkAssetResponse:
		return (void*)soap_instantiate__ns3__UnlinkAssetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__RelinkAsset:
		return (void*)soap_instantiate__ns3__RelinkAsset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__RelinkAssetResponse:
		return (void*)soap_instantiate__ns3__RelinkAssetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetEditionTaskList:
		return (void*)soap_instantiate__ns3__GetEditionTaskList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetEditionTaskListResponse:
		return (void*)soap_instantiate__ns3__GetEditionTaskListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__CheckOutAsset:
		return (void*)soap_instantiate__ns3__CheckOutAsset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__CheckOutAssetResponse:
		return (void*)soap_instantiate__ns3__CheckOutAssetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetEditionsByTitle:
		return (void*)soap_instantiate__ns3__GetEditionsByTitle(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetEditionsByTitleResponse:
		return (void*)soap_instantiate__ns3__GetEditionsByTitleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetStatusByTitle:
		return (void*)soap_instantiate__ns3__GetStatusByTitle(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetStatusByTitleResponse:
		return (void*)soap_instantiate__ns3__GetStatusByTitleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetAssetList:
		return (void*)soap_instantiate__ns3__GetAssetList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetAssetListResponse:
		return (void*)soap_instantiate__ns3__GetAssetListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__UpdateAsset:
		return (void*)soap_instantiate__ns3__UpdateAsset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__UpdateAssetResponse:
		return (void*)soap_instantiate__ns3__UpdateAssetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__UpdateAssetStatus:
		return (void*)soap_instantiate__ns3__UpdateAssetStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__UpdateAssetStatusResponse:
		return (void*)soap_instantiate__ns3__UpdateAssetStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetLock:
		return (void*)soap_instantiate__ns3__GetLock(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__GetLockResponse:
		return (void*)soap_instantiate__ns3__GetLockResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__CheckInAsset:
		return (void*)soap_instantiate__ns3__CheckInAsset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__CheckInAssetResponse:
		return (void*)soap_instantiate__ns3__CheckInAssetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__DownloadVersion:
		return (void*)soap_instantiate__ns3__DownloadVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__DownloadVersionResponse:
		return (void*)soap_instantiate__ns3__DownloadVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__TitleDTO:
		return (void*)soap_instantiate_ns3__TitleDTO(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetUsersForTitle:
		return (void*)soap_instantiate___ns1__GetUsersForTitle(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetTaskStatusList:
		return (void*)soap_instantiate___ns1__GetTaskStatusList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CreateTask:
		return (void*)soap_instantiate___ns1__CreateTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetTaskCategoryList:
		return (void*)soap_instantiate___ns1__GetTaskCategoryList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdateTask:
		return (void*)soap_instantiate___ns1__UpdateTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetTaskHistory:
		return (void*)soap_instantiate___ns1__GetTaskHistory(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DeleteTask:
		return (void*)soap_instantiate___ns1__DeleteTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Login:
		return (void*)soap_instantiate___ns1__Login(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetTitleList:
		return (void*)soap_instantiate___ns1__GetTitleList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetRole:
		return (void*)soap_instantiate___ns1__GetRole(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetCommentList:
		return (void*)soap_instantiate___ns1__GetCommentList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetTags:
		return (void*)soap_instantiate___ns1__GetTags(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetShelveList:
		return (void*)soap_instantiate___ns1__GetShelveList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Logoff:
		return (void*)soap_instantiate___ns1__Logoff(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetUser:
		return (void*)soap_instantiate___ns1__GetUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetThumbnail:
		return (void*)soap_instantiate___ns1__GetThumbnail(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__LockAsset:
		return (void*)soap_instantiate___ns1__LockAsset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UnlockAsset:
		return (void*)soap_instantiate___ns1__UnlockAsset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DeleteAsset:
		return (void*)soap_instantiate___ns1__DeleteAsset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CreateAsset:
		return (void*)soap_instantiate___ns1__CreateAsset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdateAssetName:
		return (void*)soap_instantiate___ns1__UpdateAssetName(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CanUpdateAssetName:
		return (void*)soap_instantiate___ns1__CanUpdateAssetName(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAsset:
		return (void*)soap_instantiate___ns1__GetAsset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UploadPDF:
		return (void*)soap_instantiate___ns1__UploadPDF(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UploadPage:
		return (void*)soap_instantiate___ns1__UploadPage(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UploadVersion:
		return (void*)soap_instantiate___ns1__UploadVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UploadExport:
		return (void*)soap_instantiate___ns1__UploadExport(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UnlinkAsset:
		return (void*)soap_instantiate___ns1__UnlinkAsset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__RelinkAsset:
		return (void*)soap_instantiate___ns1__RelinkAsset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetEditionTaskList:
		return (void*)soap_instantiate___ns1__GetEditionTaskList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CheckOutAsset:
		return (void*)soap_instantiate___ns1__CheckOutAsset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetEditionsByTitle:
		return (void*)soap_instantiate___ns1__GetEditionsByTitle(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetStatusByTitle:
		return (void*)soap_instantiate___ns1__GetStatusByTitle(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAssetList:
		return (void*)soap_instantiate___ns1__GetAssetList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdateAsset:
		return (void*)soap_instantiate___ns1__UpdateAsset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdateAssetStatus:
		return (void*)soap_instantiate___ns1__UpdateAssetStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetLock:
		return (void*)soap_instantiate___ns1__GetLock(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CheckInAsset:
		return (void*)soap_instantiate___ns1__CheckInAsset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DownloadVersion:
		return (void*)soap_instantiate___ns1__DownloadVersion(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE__wsrp__path:
		return (void*)soap_instantiate__wsrp__path(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrp__fwd:
		return (void*)soap_instantiate__wsrp__fwd(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrp__rev:
		return (void*)soap_instantiate__wsrp__rev(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrp__found:
		return (void*)soap_instantiate__wsrp__found(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrp__fault:
		return (void*)soap_instantiate__wsrp__fault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrp__via:
		return (void*)soap_instantiate__wsrp__via(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa__EndpointReference:
		return (void*)soap_instantiate__wsa__EndpointReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa__RelatesTo:
		return (void*)soap_instantiate__wsa__RelatesTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa__From:
		return (void*)soap_instantiate__wsa__From(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa__ReplyTo:
		return (void*)soap_instantiate__wsa__ReplyTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa__FaultTo:
		return (void*)soap_instantiate__wsa__FaultTo(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_wsrp__path_USCOREt:
		if (p->size < 0)
			delete (struct wsrp__path_USCOREt*)p->ptr;
		else
			delete[] (struct wsrp__path_USCOREt*)p->ptr;
		break;
	case SOAP_TYPE_wsrp__fwd_USCOREt:
		if (p->size < 0)
			delete (struct wsrp__fwd_USCOREt*)p->ptr;
		else
			delete[] (struct wsrp__fwd_USCOREt*)p->ptr;
		break;
	case SOAP_TYPE_wsrp__rev_USCOREt:
		if (p->size < 0)
			delete (struct wsrp__rev_USCOREt*)p->ptr;
		else
			delete[] (struct wsrp__rev_USCOREt*)p->ptr;
		break;
	case SOAP_TYPE_wsrp__found_USCOREt:
		if (p->size < 0)
			delete (struct wsrp__found_USCOREt*)p->ptr;
		else
			delete[] (struct wsrp__found_USCOREt*)p->ptr;
		break;
	case SOAP_TYPE_wsrp__fault_USCOREt:
		if (p->size < 0)
			delete (struct wsrp__fault_USCOREt*)p->ptr;
		else
			delete[] (struct wsrp__fault_USCOREt*)p->ptr;
		break;
	case SOAP_TYPE_wsrp__via_USCOREt:
		if (p->size < 0)
			delete (struct wsrp__via_USCOREt*)p->ptr;
		else
			delete[] (struct wsrp__via_USCOREt*)p->ptr;
		break;
	case SOAP_TYPE_wsa__EndpointReferenceType:
		if (p->size < 0)
			delete (struct wsa__EndpointReferenceType*)p->ptr;
		else
			delete[] (struct wsa__EndpointReferenceType*)p->ptr;
		break;
	case SOAP_TYPE_wsa__ReferencePropertiesType:
		if (p->size < 0)
			delete (struct wsa__ReferencePropertiesType*)p->ptr;
		else
			delete[] (struct wsa__ReferencePropertiesType*)p->ptr;
		break;
	case SOAP_TYPE_wsa__ReferenceParametersType:
		if (p->size < 0)
			delete (struct wsa__ReferenceParametersType*)p->ptr;
		else
			delete[] (struct wsa__ReferenceParametersType*)p->ptr;
		break;
	case SOAP_TYPE_wsa__ServiceNameType:
		if (p->size < 0)
			delete (struct wsa__ServiceNameType*)p->ptr;
		else
			delete[] (struct wsa__ServiceNameType*)p->ptr;
		break;
	case SOAP_TYPE_wsa__Relationship:
		if (p->size < 0)
			delete (struct wsa__Relationship*)p->ptr;
		else
			delete[] (struct wsa__Relationship*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE__wsu__Timestamp:
		if (p->size < 0)
			delete (struct _wsu__Timestamp*)p->ptr;
		else
			delete[] (struct _wsu__Timestamp*)p->ptr;
		break;
	case SOAP_TYPE__wsse__UsernameToken:
		if (p->size < 0)
			delete (struct _wsse__UsernameToken*)p->ptr;
		else
			delete[] (struct _wsse__UsernameToken*)p->ptr;
		break;
	case SOAP_TYPE__wsse__BinarySecurityToken:
		if (p->size < 0)
			delete (struct _wsse__BinarySecurityToken*)p->ptr;
		else
			delete[] (struct _wsse__BinarySecurityToken*)p->ptr;
		break;
	case SOAP_TYPE__wsse__Reference:
		if (p->size < 0)
			delete (struct _wsse__Reference*)p->ptr;
		else
			delete[] (struct _wsse__Reference*)p->ptr;
		break;
	case SOAP_TYPE__wsse__Embedded:
		if (p->size < 0)
			delete (struct _wsse__Embedded*)p->ptr;
		else
			delete[] (struct _wsse__Embedded*)p->ptr;
		break;
	case SOAP_TYPE__wsse__KeyIdentifier:
		if (p->size < 0)
			delete (struct _wsse__KeyIdentifier*)p->ptr;
		else
			delete[] (struct _wsse__KeyIdentifier*)p->ptr;
		break;
	case SOAP_TYPE__wsse__SecurityTokenReference:
		if (p->size < 0)
			delete (struct _wsse__SecurityTokenReference*)p->ptr;
		else
			delete[] (struct _wsse__SecurityTokenReference*)p->ptr;
		break;
	case SOAP_TYPE_ds__SignatureType:
		if (p->size < 0)
			delete (struct ds__SignatureType*)p->ptr;
		else
			delete[] (struct ds__SignatureType*)p->ptr;
		break;
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		if (p->size < 0)
			delete (struct _c14n__InclusiveNamespaces*)p->ptr;
		else
			delete[] (struct _c14n__InclusiveNamespaces*)p->ptr;
		break;
	case SOAP_TYPE_ds__TransformType:
		if (p->size < 0)
			delete (struct ds__TransformType*)p->ptr;
		else
			delete[] (struct ds__TransformType*)p->ptr;
		break;
	case SOAP_TYPE_ds__KeyInfoType:
		if (p->size < 0)
			delete (struct ds__KeyInfoType*)p->ptr;
		else
			delete[] (struct ds__KeyInfoType*)p->ptr;
		break;
	case SOAP_TYPE_ds__SignedInfoType:
		if (p->size < 0)
			delete (struct ds__SignedInfoType*)p->ptr;
		else
			delete[] (struct ds__SignedInfoType*)p->ptr;
		break;
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		if (p->size < 0)
			delete (struct ds__CanonicalizationMethodType*)p->ptr;
		else
			delete[] (struct ds__CanonicalizationMethodType*)p->ptr;
		break;
	case SOAP_TYPE_ds__SignatureMethodType:
		if (p->size < 0)
			delete (struct ds__SignatureMethodType*)p->ptr;
		else
			delete[] (struct ds__SignatureMethodType*)p->ptr;
		break;
	case SOAP_TYPE_ds__ReferenceType:
		if (p->size < 0)
			delete (struct ds__ReferenceType*)p->ptr;
		else
			delete[] (struct ds__ReferenceType*)p->ptr;
		break;
	case SOAP_TYPE_ds__TransformsType:
		if (p->size < 0)
			delete (struct ds__TransformsType*)p->ptr;
		else
			delete[] (struct ds__TransformsType*)p->ptr;
		break;
	case SOAP_TYPE_ds__DigestMethodType:
		if (p->size < 0)
			delete (struct ds__DigestMethodType*)p->ptr;
		else
			delete[] (struct ds__DigestMethodType*)p->ptr;
		break;
	case SOAP_TYPE_ds__KeyValueType:
		if (p->size < 0)
			delete (struct ds__KeyValueType*)p->ptr;
		else
			delete[] (struct ds__KeyValueType*)p->ptr;
		break;
	case SOAP_TYPE_ds__RetrievalMethodType:
		if (p->size < 0)
			delete (struct ds__RetrievalMethodType*)p->ptr;
		else
			delete[] (struct ds__RetrievalMethodType*)p->ptr;
		break;
	case SOAP_TYPE_ds__X509DataType:
		if (p->size < 0)
			delete (struct ds__X509DataType*)p->ptr;
		else
			delete[] (struct ds__X509DataType*)p->ptr;
		break;
	case SOAP_TYPE_ds__X509IssuerSerialType:
		if (p->size < 0)
			delete (struct ds__X509IssuerSerialType*)p->ptr;
		else
			delete[] (struct ds__X509IssuerSerialType*)p->ptr;
		break;
	case SOAP_TYPE_ds__DSAKeyValueType:
		if (p->size < 0)
			delete (struct ds__DSAKeyValueType*)p->ptr;
		else
			delete[] (struct ds__DSAKeyValueType*)p->ptr;
		break;
	case SOAP_TYPE_ds__RSAKeyValueType:
		if (p->size < 0)
			delete (struct ds__RSAKeyValueType*)p->ptr;
		else
			delete[] (struct ds__RSAKeyValueType*)p->ptr;
		break;
	case SOAP_TYPE__wsse__Security:
		if (p->size < 0)
			delete (struct _wsse__Security*)p->ptr;
		else
			delete[] (struct _wsse__Security*)p->ptr;
		break;
	case SOAP_TYPE__wsse__Password:
		if (p->size < 0)
			delete (struct _wsse__Password*)p->ptr;
		else
			delete[] (struct _wsse__Password*)p->ptr;
		break;
	case SOAP_TYPE__xop__Include:
		if (p->size < 0)
			delete (struct _xop__Include*)p->ptr;
		else
			delete[] (struct _xop__Include*)p->ptr;
		break;
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			delete (xsd__base64Binary*)p->ptr;
		else
			delete[] (xsd__base64Binary*)p->ptr;
		break;
	case SOAP_TYPE_ns3__ArrayOfUserDTO:
		if (p->size < 0)
			delete (ns3__ArrayOfUserDTO*)p->ptr;
		else
			delete[] (ns3__ArrayOfUserDTO*)p->ptr;
		break;
	case SOAP_TYPE_ns3__UserDTO:
		if (p->size < 0)
			delete (ns3__UserDTO*)p->ptr;
		else
			delete[] (ns3__UserDTO*)p->ptr;
		break;
	case SOAP_TYPE_ns3__ArrayOfIdNameDTO:
		if (p->size < 0)
			delete (ns3__ArrayOfIdNameDTO*)p->ptr;
		else
			delete[] (ns3__ArrayOfIdNameDTO*)p->ptr;
		break;
	case SOAP_TYPE_ns3__IdNameDTO:
		if (p->size < 0)
			delete (ns3__IdNameDTO*)p->ptr;
		else
			delete[] (ns3__IdNameDTO*)p->ptr;
		break;
	case SOAP_TYPE_ns3__TaskDTO:
		if (p->size < 0)
			delete (ns3__TaskDTO*)p->ptr;
		else
			delete[] (ns3__TaskDTO*)p->ptr;
		break;
	case SOAP_TYPE_ns3__TaskUpdateInfo:
		if (p->size < 0)
			delete (ns3__TaskUpdateInfo*)p->ptr;
		else
			delete[] (ns3__TaskUpdateInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns3__ArrayOfTitleDTO:
		if (p->size < 0)
			delete (ns3__ArrayOfTitleDTO*)p->ptr;
		else
			delete[] (ns3__ArrayOfTitleDTO*)p->ptr;
		break;
	case SOAP_TYPE_ns3__ConstantDTO:
		if (p->size < 0)
			delete (ns3__ConstantDTO*)p->ptr;
		else
			delete[] (ns3__ConstantDTO*)p->ptr;
		break;
	case SOAP_TYPE_ns3__ArrayOfCommentDTO:
		if (p->size < 0)
			delete (ns3__ArrayOfCommentDTO*)p->ptr;
		else
			delete[] (ns3__ArrayOfCommentDTO*)p->ptr;
		break;
	case SOAP_TYPE_ns3__CommentDTO:
		if (p->size < 0)
			delete (ns3__CommentDTO*)p->ptr;
		else
			delete[] (ns3__CommentDTO*)p->ptr;
		break;
	case SOAP_TYPE_ns3__ArrayOfString:
		if (p->size < 0)
			delete (ns3__ArrayOfString*)p->ptr;
		else
			delete[] (ns3__ArrayOfString*)p->ptr;
		break;
	case SOAP_TYPE_ns3__ArrayOfShelveDTO:
		if (p->size < 0)
			delete (ns3__ArrayOfShelveDTO*)p->ptr;
		else
			delete[] (ns3__ArrayOfShelveDTO*)p->ptr;
		break;
	case SOAP_TYPE_ns3__ShelveDTO:
		if (p->size < 0)
			delete (ns3__ShelveDTO*)p->ptr;
		else
			delete[] (ns3__ShelveDTO*)p->ptr;
		break;
	case SOAP_TYPE_ns3__LockDTO:
		if (p->size < 0)
			delete (ns3__LockDTO*)p->ptr;
		else
			delete[] (ns3__LockDTO*)p->ptr;
		break;
	case SOAP_TYPE_ns3__AssetDTO:
		if (p->size < 0)
			delete (ns3__AssetDTO*)p->ptr;
		else
			delete[] (ns3__AssetDTO*)p->ptr;
		break;
	case SOAP_TYPE_ns3__VersionInfo:
		if (p->size < 0)
			delete (ns3__VersionInfo*)p->ptr;
		else
			delete[] (ns3__VersionInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns3__ArrayOfGuid:
		if (p->size < 0)
			delete (ns3__ArrayOfGuid*)p->ptr;
		else
			delete[] (ns3__ArrayOfGuid*)p->ptr;
		break;
	case SOAP_TYPE_ns3__ArrayOfAssetDTO:
		if (p->size < 0)
			delete (ns3__ArrayOfAssetDTO*)p->ptr;
		else
			delete[] (ns3__ArrayOfAssetDTO*)p->ptr;
		break;
	case SOAP_TYPE_ns3__VersionDTO:
		if (p->size < 0)
			delete (ns3__VersionDTO*)p->ptr;
		else
			delete[] (ns3__VersionDTO*)p->ptr;
		break;
	case SOAP_TYPE_ns3__ArrayOfTaskDTO:
		if (p->size < 0)
			delete (ns3__ArrayOfTaskDTO*)p->ptr;
		else
			delete[] (ns3__ArrayOfTaskDTO*)p->ptr;
		break;
	case SOAP_TYPE_ns3__ArrayOfEditionTitlesDTO:
		if (p->size < 0)
			delete (ns3__ArrayOfEditionTitlesDTO*)p->ptr;
		else
			delete[] (ns3__ArrayOfEditionTitlesDTO*)p->ptr;
		break;
	case SOAP_TYPE_ns3__EditionTitlesDTO:
		if (p->size < 0)
			delete (ns3__EditionTitlesDTO*)p->ptr;
		else
			delete[] (ns3__EditionTitlesDTO*)p->ptr;
		break;
	case SOAP_TYPE_ns3__ArrayOfTitleStatusDTO:
		if (p->size < 0)
			delete (ns3__ArrayOfTitleStatusDTO*)p->ptr;
		else
			delete[] (ns3__ArrayOfTitleStatusDTO*)p->ptr;
		break;
	case SOAP_TYPE_ns3__TitleStatusDTO:
		if (p->size < 0)
			delete (ns3__TitleStatusDTO*)p->ptr;
		else
			delete[] (ns3__TitleStatusDTO*)p->ptr;
		break;
	case SOAP_TYPE_ns3__ArrayOfStatusDTO:
		if (p->size < 0)
			delete (ns3__ArrayOfStatusDTO*)p->ptr;
		else
			delete[] (ns3__ArrayOfStatusDTO*)p->ptr;
		break;
	case SOAP_TYPE_ns3__StatusDTO:
		if (p->size < 0)
			delete (ns3__StatusDTO*)p->ptr;
		else
			delete[] (ns3__StatusDTO*)p->ptr;
		break;
	case SOAP_TYPE_ns3__ArrayOfLockDTO:
		if (p->size < 0)
			delete (ns3__ArrayOfLockDTO*)p->ptr;
		else
			delete[] (ns3__ArrayOfLockDTO*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetUsersForTitle:
		if (p->size < 0)
			delete (_ns3__GetUsersForTitle*)p->ptr;
		else
			delete[] (_ns3__GetUsersForTitle*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetUsersForTitleResponse:
		if (p->size < 0)
			delete (_ns3__GetUsersForTitleResponse*)p->ptr;
		else
			delete[] (_ns3__GetUsersForTitleResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetTaskStatusList:
		if (p->size < 0)
			delete (_ns3__GetTaskStatusList*)p->ptr;
		else
			delete[] (_ns3__GetTaskStatusList*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetTaskStatusListResponse:
		if (p->size < 0)
			delete (_ns3__GetTaskStatusListResponse*)p->ptr;
		else
			delete[] (_ns3__GetTaskStatusListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__CreateTask:
		if (p->size < 0)
			delete (_ns3__CreateTask*)p->ptr;
		else
			delete[] (_ns3__CreateTask*)p->ptr;
		break;
	case SOAP_TYPE__ns3__CreateTaskResponse:
		if (p->size < 0)
			delete (_ns3__CreateTaskResponse*)p->ptr;
		else
			delete[] (_ns3__CreateTaskResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetTaskCategoryList:
		if (p->size < 0)
			delete (_ns3__GetTaskCategoryList*)p->ptr;
		else
			delete[] (_ns3__GetTaskCategoryList*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetTaskCategoryListResponse:
		if (p->size < 0)
			delete (_ns3__GetTaskCategoryListResponse*)p->ptr;
		else
			delete[] (_ns3__GetTaskCategoryListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__UpdateTask:
		if (p->size < 0)
			delete (_ns3__UpdateTask*)p->ptr;
		else
			delete[] (_ns3__UpdateTask*)p->ptr;
		break;
	case SOAP_TYPE__ns3__UpdateTaskResponse:
		if (p->size < 0)
			delete (_ns3__UpdateTaskResponse*)p->ptr;
		else
			delete[] (_ns3__UpdateTaskResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetTaskHistory:
		if (p->size < 0)
			delete (_ns3__GetTaskHistory*)p->ptr;
		else
			delete[] (_ns3__GetTaskHistory*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetTaskHistoryResponse:
		if (p->size < 0)
			delete (_ns3__GetTaskHistoryResponse*)p->ptr;
		else
			delete[] (_ns3__GetTaskHistoryResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__DeleteTask:
		if (p->size < 0)
			delete (_ns3__DeleteTask*)p->ptr;
		else
			delete[] (_ns3__DeleteTask*)p->ptr;
		break;
	case SOAP_TYPE__ns3__DeleteTaskResponse:
		if (p->size < 0)
			delete (_ns3__DeleteTaskResponse*)p->ptr;
		else
			delete[] (_ns3__DeleteTaskResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__Login:
		if (p->size < 0)
			delete (_ns3__Login*)p->ptr;
		else
			delete[] (_ns3__Login*)p->ptr;
		break;
	case SOAP_TYPE__ns3__LoginResponse:
		if (p->size < 0)
			delete (_ns3__LoginResponse*)p->ptr;
		else
			delete[] (_ns3__LoginResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetTitleList:
		if (p->size < 0)
			delete (_ns3__GetTitleList*)p->ptr;
		else
			delete[] (_ns3__GetTitleList*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetTitleListResponse:
		if (p->size < 0)
			delete (_ns3__GetTitleListResponse*)p->ptr;
		else
			delete[] (_ns3__GetTitleListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetRole:
		if (p->size < 0)
			delete (_ns3__GetRole*)p->ptr;
		else
			delete[] (_ns3__GetRole*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetRoleResponse:
		if (p->size < 0)
			delete (_ns3__GetRoleResponse*)p->ptr;
		else
			delete[] (_ns3__GetRoleResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetCommentList:
		if (p->size < 0)
			delete (_ns3__GetCommentList*)p->ptr;
		else
			delete[] (_ns3__GetCommentList*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetCommentListResponse:
		if (p->size < 0)
			delete (_ns3__GetCommentListResponse*)p->ptr;
		else
			delete[] (_ns3__GetCommentListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetTags:
		if (p->size < 0)
			delete (_ns3__GetTags*)p->ptr;
		else
			delete[] (_ns3__GetTags*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetTagsResponse:
		if (p->size < 0)
			delete (_ns3__GetTagsResponse*)p->ptr;
		else
			delete[] (_ns3__GetTagsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetShelveList:
		if (p->size < 0)
			delete (_ns3__GetShelveList*)p->ptr;
		else
			delete[] (_ns3__GetShelveList*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetShelveListResponse:
		if (p->size < 0)
			delete (_ns3__GetShelveListResponse*)p->ptr;
		else
			delete[] (_ns3__GetShelveListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__Logoff:
		if (p->size < 0)
			delete (_ns3__Logoff*)p->ptr;
		else
			delete[] (_ns3__Logoff*)p->ptr;
		break;
	case SOAP_TYPE__ns3__LogoffResponse:
		if (p->size < 0)
			delete (_ns3__LogoffResponse*)p->ptr;
		else
			delete[] (_ns3__LogoffResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetUser:
		if (p->size < 0)
			delete (_ns3__GetUser*)p->ptr;
		else
			delete[] (_ns3__GetUser*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetUserResponse:
		if (p->size < 0)
			delete (_ns3__GetUserResponse*)p->ptr;
		else
			delete[] (_ns3__GetUserResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetThumbnail:
		if (p->size < 0)
			delete (_ns3__GetThumbnail*)p->ptr;
		else
			delete[] (_ns3__GetThumbnail*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetThumbnailResponse:
		if (p->size < 0)
			delete (_ns3__GetThumbnailResponse*)p->ptr;
		else
			delete[] (_ns3__GetThumbnailResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__LockAsset:
		if (p->size < 0)
			delete (_ns3__LockAsset*)p->ptr;
		else
			delete[] (_ns3__LockAsset*)p->ptr;
		break;
	case SOAP_TYPE__ns3__LockAssetResponse:
		if (p->size < 0)
			delete (_ns3__LockAssetResponse*)p->ptr;
		else
			delete[] (_ns3__LockAssetResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__UnlockAsset:
		if (p->size < 0)
			delete (_ns3__UnlockAsset*)p->ptr;
		else
			delete[] (_ns3__UnlockAsset*)p->ptr;
		break;
	case SOAP_TYPE__ns3__UnlockAssetResponse:
		if (p->size < 0)
			delete (_ns3__UnlockAssetResponse*)p->ptr;
		else
			delete[] (_ns3__UnlockAssetResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__DeleteAsset:
		if (p->size < 0)
			delete (_ns3__DeleteAsset*)p->ptr;
		else
			delete[] (_ns3__DeleteAsset*)p->ptr;
		break;
	case SOAP_TYPE__ns3__DeleteAssetResponse:
		if (p->size < 0)
			delete (_ns3__DeleteAssetResponse*)p->ptr;
		else
			delete[] (_ns3__DeleteAssetResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__CreateAsset:
		if (p->size < 0)
			delete (_ns3__CreateAsset*)p->ptr;
		else
			delete[] (_ns3__CreateAsset*)p->ptr;
		break;
	case SOAP_TYPE__ns3__CreateAssetResponse:
		if (p->size < 0)
			delete (_ns3__CreateAssetResponse*)p->ptr;
		else
			delete[] (_ns3__CreateAssetResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__UpdateAssetName:
		if (p->size < 0)
			delete (_ns3__UpdateAssetName*)p->ptr;
		else
			delete[] (_ns3__UpdateAssetName*)p->ptr;
		break;
	case SOAP_TYPE__ns3__UpdateAssetNameResponse:
		if (p->size < 0)
			delete (_ns3__UpdateAssetNameResponse*)p->ptr;
		else
			delete[] (_ns3__UpdateAssetNameResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__CanUpdateAssetName:
		if (p->size < 0)
			delete (_ns3__CanUpdateAssetName*)p->ptr;
		else
			delete[] (_ns3__CanUpdateAssetName*)p->ptr;
		break;
	case SOAP_TYPE__ns3__CanUpdateAssetNameResponse:
		if (p->size < 0)
			delete (_ns3__CanUpdateAssetNameResponse*)p->ptr;
		else
			delete[] (_ns3__CanUpdateAssetNameResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetAsset:
		if (p->size < 0)
			delete (_ns3__GetAsset*)p->ptr;
		else
			delete[] (_ns3__GetAsset*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetAssetResponse:
		if (p->size < 0)
			delete (_ns3__GetAssetResponse*)p->ptr;
		else
			delete[] (_ns3__GetAssetResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__UploadPDF:
		if (p->size < 0)
			delete (_ns3__UploadPDF*)p->ptr;
		else
			delete[] (_ns3__UploadPDF*)p->ptr;
		break;
	case SOAP_TYPE__ns3__UploadPDFResponse:
		if (p->size < 0)
			delete (_ns3__UploadPDFResponse*)p->ptr;
		else
			delete[] (_ns3__UploadPDFResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__UploadPage:
		if (p->size < 0)
			delete (_ns3__UploadPage*)p->ptr;
		else
			delete[] (_ns3__UploadPage*)p->ptr;
		break;
	case SOAP_TYPE__ns3__UploadPageResponse:
		if (p->size < 0)
			delete (_ns3__UploadPageResponse*)p->ptr;
		else
			delete[] (_ns3__UploadPageResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__UploadVersion:
		if (p->size < 0)
			delete (_ns3__UploadVersion*)p->ptr;
		else
			delete[] (_ns3__UploadVersion*)p->ptr;
		break;
	case SOAP_TYPE__ns3__UploadVersionResponse:
		if (p->size < 0)
			delete (_ns3__UploadVersionResponse*)p->ptr;
		else
			delete[] (_ns3__UploadVersionResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__UploadExport:
		if (p->size < 0)
			delete (_ns3__UploadExport*)p->ptr;
		else
			delete[] (_ns3__UploadExport*)p->ptr;
		break;
	case SOAP_TYPE__ns3__UploadExportResponse:
		if (p->size < 0)
			delete (_ns3__UploadExportResponse*)p->ptr;
		else
			delete[] (_ns3__UploadExportResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__UnlinkAsset:
		if (p->size < 0)
			delete (_ns3__UnlinkAsset*)p->ptr;
		else
			delete[] (_ns3__UnlinkAsset*)p->ptr;
		break;
	case SOAP_TYPE__ns3__UnlinkAssetResponse:
		if (p->size < 0)
			delete (_ns3__UnlinkAssetResponse*)p->ptr;
		else
			delete[] (_ns3__UnlinkAssetResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__RelinkAsset:
		if (p->size < 0)
			delete (_ns3__RelinkAsset*)p->ptr;
		else
			delete[] (_ns3__RelinkAsset*)p->ptr;
		break;
	case SOAP_TYPE__ns3__RelinkAssetResponse:
		if (p->size < 0)
			delete (_ns3__RelinkAssetResponse*)p->ptr;
		else
			delete[] (_ns3__RelinkAssetResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetEditionTaskList:
		if (p->size < 0)
			delete (_ns3__GetEditionTaskList*)p->ptr;
		else
			delete[] (_ns3__GetEditionTaskList*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetEditionTaskListResponse:
		if (p->size < 0)
			delete (_ns3__GetEditionTaskListResponse*)p->ptr;
		else
			delete[] (_ns3__GetEditionTaskListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__CheckOutAsset:
		if (p->size < 0)
			delete (_ns3__CheckOutAsset*)p->ptr;
		else
			delete[] (_ns3__CheckOutAsset*)p->ptr;
		break;
	case SOAP_TYPE__ns3__CheckOutAssetResponse:
		if (p->size < 0)
			delete (_ns3__CheckOutAssetResponse*)p->ptr;
		else
			delete[] (_ns3__CheckOutAssetResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetEditionsByTitle:
		if (p->size < 0)
			delete (_ns3__GetEditionsByTitle*)p->ptr;
		else
			delete[] (_ns3__GetEditionsByTitle*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetEditionsByTitleResponse:
		if (p->size < 0)
			delete (_ns3__GetEditionsByTitleResponse*)p->ptr;
		else
			delete[] (_ns3__GetEditionsByTitleResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetStatusByTitle:
		if (p->size < 0)
			delete (_ns3__GetStatusByTitle*)p->ptr;
		else
			delete[] (_ns3__GetStatusByTitle*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetStatusByTitleResponse:
		if (p->size < 0)
			delete (_ns3__GetStatusByTitleResponse*)p->ptr;
		else
			delete[] (_ns3__GetStatusByTitleResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetAssetList:
		if (p->size < 0)
			delete (_ns3__GetAssetList*)p->ptr;
		else
			delete[] (_ns3__GetAssetList*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetAssetListResponse:
		if (p->size < 0)
			delete (_ns3__GetAssetListResponse*)p->ptr;
		else
			delete[] (_ns3__GetAssetListResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__UpdateAsset:
		if (p->size < 0)
			delete (_ns3__UpdateAsset*)p->ptr;
		else
			delete[] (_ns3__UpdateAsset*)p->ptr;
		break;
	case SOAP_TYPE__ns3__UpdateAssetResponse:
		if (p->size < 0)
			delete (_ns3__UpdateAssetResponse*)p->ptr;
		else
			delete[] (_ns3__UpdateAssetResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__UpdateAssetStatus:
		if (p->size < 0)
			delete (_ns3__UpdateAssetStatus*)p->ptr;
		else
			delete[] (_ns3__UpdateAssetStatus*)p->ptr;
		break;
	case SOAP_TYPE__ns3__UpdateAssetStatusResponse:
		if (p->size < 0)
			delete (_ns3__UpdateAssetStatusResponse*)p->ptr;
		else
			delete[] (_ns3__UpdateAssetStatusResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetLock:
		if (p->size < 0)
			delete (_ns3__GetLock*)p->ptr;
		else
			delete[] (_ns3__GetLock*)p->ptr;
		break;
	case SOAP_TYPE__ns3__GetLockResponse:
		if (p->size < 0)
			delete (_ns3__GetLockResponse*)p->ptr;
		else
			delete[] (_ns3__GetLockResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__CheckInAsset:
		if (p->size < 0)
			delete (_ns3__CheckInAsset*)p->ptr;
		else
			delete[] (_ns3__CheckInAsset*)p->ptr;
		break;
	case SOAP_TYPE__ns3__CheckInAssetResponse:
		if (p->size < 0)
			delete (_ns3__CheckInAssetResponse*)p->ptr;
		else
			delete[] (_ns3__CheckInAssetResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns3__DownloadVersion:
		if (p->size < 0)
			delete (_ns3__DownloadVersion*)p->ptr;
		else
			delete[] (_ns3__DownloadVersion*)p->ptr;
		break;
	case SOAP_TYPE__ns3__DownloadVersionResponse:
		if (p->size < 0)
			delete (_ns3__DownloadVersionResponse*)p->ptr;
		else
			delete[] (_ns3__DownloadVersionResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns3__TitleDTO:
		if (p->size < 0)
			delete (ns3__TitleDTO*)p->ptr;
		else
			delete[] (ns3__TitleDTO*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetUsersForTitle:
		if (p->size < 0)
			delete (struct __ns1__GetUsersForTitle*)p->ptr;
		else
			delete[] (struct __ns1__GetUsersForTitle*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetTaskStatusList:
		if (p->size < 0)
			delete (struct __ns1__GetTaskStatusList*)p->ptr;
		else
			delete[] (struct __ns1__GetTaskStatusList*)p->ptr;
		break;
	case SOAP_TYPE___ns1__CreateTask:
		if (p->size < 0)
			delete (struct __ns1__CreateTask*)p->ptr;
		else
			delete[] (struct __ns1__CreateTask*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetTaskCategoryList:
		if (p->size < 0)
			delete (struct __ns1__GetTaskCategoryList*)p->ptr;
		else
			delete[] (struct __ns1__GetTaskCategoryList*)p->ptr;
		break;
	case SOAP_TYPE___ns1__UpdateTask:
		if (p->size < 0)
			delete (struct __ns1__UpdateTask*)p->ptr;
		else
			delete[] (struct __ns1__UpdateTask*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetTaskHistory:
		if (p->size < 0)
			delete (struct __ns1__GetTaskHistory*)p->ptr;
		else
			delete[] (struct __ns1__GetTaskHistory*)p->ptr;
		break;
	case SOAP_TYPE___ns1__DeleteTask:
		if (p->size < 0)
			delete (struct __ns1__DeleteTask*)p->ptr;
		else
			delete[] (struct __ns1__DeleteTask*)p->ptr;
		break;
	case SOAP_TYPE___ns1__Login:
		if (p->size < 0)
			delete (struct __ns1__Login*)p->ptr;
		else
			delete[] (struct __ns1__Login*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetTitleList:
		if (p->size < 0)
			delete (struct __ns1__GetTitleList*)p->ptr;
		else
			delete[] (struct __ns1__GetTitleList*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetRole:
		if (p->size < 0)
			delete (struct __ns1__GetRole*)p->ptr;
		else
			delete[] (struct __ns1__GetRole*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetCommentList:
		if (p->size < 0)
			delete (struct __ns1__GetCommentList*)p->ptr;
		else
			delete[] (struct __ns1__GetCommentList*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetTags:
		if (p->size < 0)
			delete (struct __ns1__GetTags*)p->ptr;
		else
			delete[] (struct __ns1__GetTags*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetShelveList:
		if (p->size < 0)
			delete (struct __ns1__GetShelveList*)p->ptr;
		else
			delete[] (struct __ns1__GetShelveList*)p->ptr;
		break;
	case SOAP_TYPE___ns1__Logoff:
		if (p->size < 0)
			delete (struct __ns1__Logoff*)p->ptr;
		else
			delete[] (struct __ns1__Logoff*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetUser:
		if (p->size < 0)
			delete (struct __ns1__GetUser*)p->ptr;
		else
			delete[] (struct __ns1__GetUser*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetThumbnail:
		if (p->size < 0)
			delete (struct __ns1__GetThumbnail*)p->ptr;
		else
			delete[] (struct __ns1__GetThumbnail*)p->ptr;
		break;
	case SOAP_TYPE___ns1__LockAsset:
		if (p->size < 0)
			delete (struct __ns1__LockAsset*)p->ptr;
		else
			delete[] (struct __ns1__LockAsset*)p->ptr;
		break;
	case SOAP_TYPE___ns1__UnlockAsset:
		if (p->size < 0)
			delete (struct __ns1__UnlockAsset*)p->ptr;
		else
			delete[] (struct __ns1__UnlockAsset*)p->ptr;
		break;
	case SOAP_TYPE___ns1__DeleteAsset:
		if (p->size < 0)
			delete (struct __ns1__DeleteAsset*)p->ptr;
		else
			delete[] (struct __ns1__DeleteAsset*)p->ptr;
		break;
	case SOAP_TYPE___ns1__CreateAsset:
		if (p->size < 0)
			delete (struct __ns1__CreateAsset*)p->ptr;
		else
			delete[] (struct __ns1__CreateAsset*)p->ptr;
		break;
	case SOAP_TYPE___ns1__UpdateAssetName:
		if (p->size < 0)
			delete (struct __ns1__UpdateAssetName*)p->ptr;
		else
			delete[] (struct __ns1__UpdateAssetName*)p->ptr;
		break;
	case SOAP_TYPE___ns1__CanUpdateAssetName:
		if (p->size < 0)
			delete (struct __ns1__CanUpdateAssetName*)p->ptr;
		else
			delete[] (struct __ns1__CanUpdateAssetName*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetAsset:
		if (p->size < 0)
			delete (struct __ns1__GetAsset*)p->ptr;
		else
			delete[] (struct __ns1__GetAsset*)p->ptr;
		break;
	case SOAP_TYPE___ns1__UploadPDF:
		if (p->size < 0)
			delete (struct __ns1__UploadPDF*)p->ptr;
		else
			delete[] (struct __ns1__UploadPDF*)p->ptr;
		break;
	case SOAP_TYPE___ns1__UploadPage:
		if (p->size < 0)
			delete (struct __ns1__UploadPage*)p->ptr;
		else
			delete[] (struct __ns1__UploadPage*)p->ptr;
		break;
	case SOAP_TYPE___ns1__UploadVersion:
		if (p->size < 0)
			delete (struct __ns1__UploadVersion*)p->ptr;
		else
			delete[] (struct __ns1__UploadVersion*)p->ptr;
		break;
	case SOAP_TYPE___ns1__UploadExport:
		if (p->size < 0)
			delete (struct __ns1__UploadExport*)p->ptr;
		else
			delete[] (struct __ns1__UploadExport*)p->ptr;
		break;
	case SOAP_TYPE___ns1__UnlinkAsset:
		if (p->size < 0)
			delete (struct __ns1__UnlinkAsset*)p->ptr;
		else
			delete[] (struct __ns1__UnlinkAsset*)p->ptr;
		break;
	case SOAP_TYPE___ns1__RelinkAsset:
		if (p->size < 0)
			delete (struct __ns1__RelinkAsset*)p->ptr;
		else
			delete[] (struct __ns1__RelinkAsset*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetEditionTaskList:
		if (p->size < 0)
			delete (struct __ns1__GetEditionTaskList*)p->ptr;
		else
			delete[] (struct __ns1__GetEditionTaskList*)p->ptr;
		break;
	case SOAP_TYPE___ns1__CheckOutAsset:
		if (p->size < 0)
			delete (struct __ns1__CheckOutAsset*)p->ptr;
		else
			delete[] (struct __ns1__CheckOutAsset*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetEditionsByTitle:
		if (p->size < 0)
			delete (struct __ns1__GetEditionsByTitle*)p->ptr;
		else
			delete[] (struct __ns1__GetEditionsByTitle*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetStatusByTitle:
		if (p->size < 0)
			delete (struct __ns1__GetStatusByTitle*)p->ptr;
		else
			delete[] (struct __ns1__GetStatusByTitle*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetAssetList:
		if (p->size < 0)
			delete (struct __ns1__GetAssetList*)p->ptr;
		else
			delete[] (struct __ns1__GetAssetList*)p->ptr;
		break;
	case SOAP_TYPE___ns1__UpdateAsset:
		if (p->size < 0)
			delete (struct __ns1__UpdateAsset*)p->ptr;
		else
			delete[] (struct __ns1__UpdateAsset*)p->ptr;
		break;
	case SOAP_TYPE___ns1__UpdateAssetStatus:
		if (p->size < 0)
			delete (struct __ns1__UpdateAssetStatus*)p->ptr;
		else
			delete[] (struct __ns1__UpdateAssetStatus*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetLock:
		if (p->size < 0)
			delete (struct __ns1__GetLock*)p->ptr;
		else
			delete[] (struct __ns1__GetLock*)p->ptr;
		break;
	case SOAP_TYPE___ns1__CheckInAsset:
		if (p->size < 0)
			delete (struct __ns1__CheckInAsset*)p->ptr;
		else
			delete[] (struct __ns1__CheckInAsset*)p->ptr;
		break;
	case SOAP_TYPE___ns1__DownloadVersion:
		if (p->size < 0)
			delete (struct __ns1__DownloadVersion*)p->ptr;
		else
			delete[] (struct __ns1__DownloadVersion*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE__wsrp__path:
		if (p->size < 0)
			delete (struct wsrp__path_USCOREt*)p->ptr;
		else
			delete[] (struct wsrp__path_USCOREt*)p->ptr;
		break;
	case SOAP_TYPE__wsrp__fwd:
		if (p->size < 0)
			delete (struct wsrp__fwd_USCOREt*)p->ptr;
		else
			delete[] (struct wsrp__fwd_USCOREt*)p->ptr;
		break;
	case SOAP_TYPE__wsrp__rev:
		if (p->size < 0)
			delete (struct wsrp__rev_USCOREt*)p->ptr;
		else
			delete[] (struct wsrp__rev_USCOREt*)p->ptr;
		break;
	case SOAP_TYPE__wsrp__found:
		if (p->size < 0)
			delete (struct wsrp__found_USCOREt*)p->ptr;
		else
			delete[] (struct wsrp__found_USCOREt*)p->ptr;
		break;
	case SOAP_TYPE__wsrp__fault:
		if (p->size < 0)
			delete (struct wsrp__fault_USCOREt*)p->ptr;
		else
			delete[] (struct wsrp__fault_USCOREt*)p->ptr;
		break;
	case SOAP_TYPE__wsrp__via:
		if (p->size < 0)
			delete (struct wsrp__via_USCOREt*)p->ptr;
		else
			delete[] (struct wsrp__via_USCOREt*)p->ptr;
		break;
	case SOAP_TYPE__wsa__EndpointReference:
		if (p->size < 0)
			delete (struct wsa__EndpointReferenceType*)p->ptr;
		else
			delete[] (struct wsa__EndpointReferenceType*)p->ptr;
		break;
	case SOAP_TYPE__wsa__RelatesTo:
		if (p->size < 0)
			delete (struct wsa__Relationship*)p->ptr;
		else
			delete[] (struct wsa__Relationship*)p->ptr;
		break;
	case SOAP_TYPE__wsa__From:
		if (p->size < 0)
			delete (struct wsa__EndpointReferenceType*)p->ptr;
		else
			delete[] (struct wsa__EndpointReferenceType*)p->ptr;
		break;
	case SOAP_TYPE__wsa__ReplyTo:
		if (p->size < 0)
			delete (struct wsa__EndpointReferenceType*)p->ptr;
		else
			delete[] (struct wsa__EndpointReferenceType*)p->ptr;
		break;
	case SOAP_TYPE__wsa__FaultTo:
		if (p->size < 0)
			delete (struct wsa__EndpointReferenceType*)p->ptr;
		else
			delete[] (struct wsa__EndpointReferenceType*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsse__FaultcodeEnum
	*a = SOAP_DEFAULT_wsse__FaultcodeEnum;
#else
	*a = (enum wsse__FaultcodeEnum)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsse__FaultcodeEnum(struct soap *soap, const enum wsse__FaultcodeEnum *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsse__FaultcodeEnum);
	if (soap_out_wsse__FaultcodeEnum(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wsse__FaultcodeEnum[] =
{	{ (long)wsse__UnsupportedSecurityToken, "wsse:UnsupportedSecurityToken" },
	{ (long)wsse__UnsupportedAlgorithm, "wsse:UnsupportedAlgorithm" },
	{ (long)wsse__InvalidSecurity, "wsse:InvalidSecurity" },
	{ (long)wsse__InvalidSecurityToken, "wsse:InvalidSecurityToken" },
	{ (long)wsse__FailedAuthentication, "wsse:FailedAuthentication" },
	{ (long)wsse__FailedCheck, "wsse:FailedCheck" },
	{ (long)wsse__SecurityTokenUnavailable, "wsse:SecurityTokenUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsse__FaultcodeEnum2s(struct soap *soap, enum wsse__FaultcodeEnum n)
{	const char *s = soap_code_str(soap_codes_wsse__FaultcodeEnum, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsse__FaultcodeEnum(struct soap *soap, const char *tag, int id, const enum wsse__FaultcodeEnum *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsse__FaultcodeEnum), type) || soap_send(soap, soap_wsse__FaultcodeEnum2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_get_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsse__FaultcodeEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsse__FaultcodeEnum(struct soap *soap, const char *s, enum wsse__FaultcodeEnum *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return SOAP_OK;
	soap_s2QName(soap, s, &t);
	map = soap_code(soap_codes_wsse__FaultcodeEnum, t);
	if (map)
		*a = (enum wsse__FaultcodeEnum)map->code;
	else
		return soap->error = SOAP_TYPE;
	return SOAP_OK;
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_in_wsse__FaultcodeEnum(struct soap *soap, const char *tag, enum wsse__FaultcodeEnum *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsse__FaultcodeEnum *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsse__FaultcodeEnum(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsse__FaultcodeEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsse__FaultcodeEnum, 0, sizeof(enum wsse__FaultcodeEnum), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsu__tTimestampFault
	*a = SOAP_DEFAULT_wsu__tTimestampFault;
#else
	*a = (enum wsu__tTimestampFault)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsu__tTimestampFault(struct soap *soap, const enum wsu__tTimestampFault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsu__tTimestampFault);
	if (soap_out_wsu__tTimestampFault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wsu__tTimestampFault[] =
{	{ (long)wsu__MessageExpired, "wsu:MessageExpired" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsu__tTimestampFault2s(struct soap *soap, enum wsu__tTimestampFault n)
{	const char *s = soap_code_str(soap_codes_wsu__tTimestampFault, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsu__tTimestampFault(struct soap *soap, const char *tag, int id, const enum wsu__tTimestampFault *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsu__tTimestampFault), type) || soap_send(soap, soap_wsu__tTimestampFault2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_get_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsu__tTimestampFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsu__tTimestampFault(struct soap *soap, const char *s, enum wsu__tTimestampFault *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return SOAP_OK;
	soap_s2QName(soap, s, &t);
	map = soap_code(soap_codes_wsu__tTimestampFault, t);
	if (map)
		*a = (enum wsu__tTimestampFault)map->code;
	else
		return soap->error = SOAP_TYPE;
	return SOAP_OK;
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_in_wsu__tTimestampFault(struct soap *soap, const char *tag, enum wsu__tTimestampFault *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsu__tTimestampFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsu__tTimestampFault(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsu__tTimestampFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsu__tTimestampFault, 0, sizeof(enum wsu__tTimestampFault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__FaultSubcodeValues(struct soap *soap, enum wsa__FaultSubcodeValues *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsa__FaultSubcodeValues
	*a = SOAP_DEFAULT_wsa__FaultSubcodeValues;
#else
	*a = (enum wsa__FaultSubcodeValues)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__FaultSubcodeValues(struct soap *soap, const enum wsa__FaultSubcodeValues *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__FaultSubcodeValues);
	if (soap_out_wsa__FaultSubcodeValues(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wsa__FaultSubcodeValues[] =
{	{ (long)wsa__InvalidMessageInformationHeader, "wsa:InvalidMessageInformationHeader" },
	{ (long)wsa__MessageInformationHeaderRequired, "wsa:MessageInformationHeaderRequired" },
	{ (long)wsa__DestinationUnreachable, "wsa:DestinationUnreachable" },
	{ (long)wsa__ActionNotSupported, "wsa:ActionNotSupported" },
	{ (long)wsa__EndpointUnavailable, "wsa:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa__FaultSubcodeValues2s(struct soap *soap, enum wsa__FaultSubcodeValues n)
{	const char *s = soap_code_str(soap_codes_wsa__FaultSubcodeValues, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__FaultSubcodeValues(struct soap *soap, const char *tag, int id, const enum wsa__FaultSubcodeValues *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__FaultSubcodeValues), type) || soap_send(soap, soap_wsa__FaultSubcodeValues2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wsa__FaultSubcodeValues * SOAP_FMAC4 soap_get_wsa__FaultSubcodeValues(struct soap *soap, enum wsa__FaultSubcodeValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__FaultSubcodeValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa__FaultSubcodeValues(struct soap *soap, const char *s, enum wsa__FaultSubcodeValues *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return SOAP_OK;
	soap_s2QName(soap, s, &t);
	map = soap_code(soap_codes_wsa__FaultSubcodeValues, t);
	if (map)
		*a = (enum wsa__FaultSubcodeValues)map->code;
	else
		return soap->error = SOAP_TYPE;
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa__FaultSubcodeValues * SOAP_FMAC4 soap_in_wsa__FaultSubcodeValues(struct soap *soap, const char *tag, enum wsa__FaultSubcodeValues *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa__FaultSubcodeValues *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__FaultSubcodeValues, sizeof(enum wsa__FaultSubcodeValues), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsa__FaultSubcodeValues(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsa__FaultSubcodeValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__FaultSubcodeValues, 0, sizeof(enum wsa__FaultSubcodeValues), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__RelationshipTypeValues(struct soap *soap, enum wsa__RelationshipTypeValues *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsa__RelationshipTypeValues
	*a = SOAP_DEFAULT_wsa__RelationshipTypeValues;
#else
	*a = (enum wsa__RelationshipTypeValues)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__RelationshipTypeValues(struct soap *soap, const enum wsa__RelationshipTypeValues *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__RelationshipTypeValues);
	if (soap_out_wsa__RelationshipTypeValues(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_wsa__RelationshipTypeValues[] =
{	{ (long)wsa__Reply, "wsa:Reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa__RelationshipTypeValues2s(struct soap *soap, enum wsa__RelationshipTypeValues n)
{	const char *s = soap_code_str(soap_codes_wsa__RelationshipTypeValues, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__RelationshipTypeValues(struct soap *soap, const char *tag, int id, const enum wsa__RelationshipTypeValues *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__RelationshipTypeValues), type) || soap_send(soap, soap_wsa__RelationshipTypeValues2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum wsa__RelationshipTypeValues * SOAP_FMAC4 soap_get_wsa__RelationshipTypeValues(struct soap *soap, enum wsa__RelationshipTypeValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__RelationshipTypeValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa__RelationshipTypeValues(struct soap *soap, const char *s, enum wsa__RelationshipTypeValues *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return SOAP_OK;
	soap_s2QName(soap, s, &t);
	map = soap_code(soap_codes_wsa__RelationshipTypeValues, t);
	if (map)
		*a = (enum wsa__RelationshipTypeValues)map->code;
	else
		return soap->error = SOAP_TYPE;
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa__RelationshipTypeValues * SOAP_FMAC4 soap_in_wsa__RelationshipTypeValues(struct soap *soap, const char *tag, enum wsa__RelationshipTypeValues *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa__RelationshipTypeValues *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__RelationshipTypeValues, sizeof(enum wsa__RelationshipTypeValues), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsa__RelationshipTypeValues(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsa__RelationshipTypeValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__RelationshipTypeValues, 0, sizeof(enum wsa__RelationshipTypeValues), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void _ns3__DownloadVersionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__DownloadVersionResponse::DownloadVersionResult = NULL;
	/* transient soap skipped */
}

void _ns3__DownloadVersionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__VersionDTO(soap, &this->_ns3__DownloadVersionResponse::DownloadVersionResult);
	/* transient soap skipped */
}

int _ns3__DownloadVersionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__DownloadVersionResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__DownloadVersionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__DownloadVersionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__DownloadVersionResponse(struct soap *soap, const char *tag, int id, const _ns3__DownloadVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__DownloadVersionResponse), type))
		return soap->error;
	if (a->DownloadVersionResult)
		soap_element_result(soap, "ns3:DownloadVersionResult");
	if (soap_out_PointerTons3__VersionDTO(soap, "ns3:DownloadVersionResult", -1, &(a->_ns3__DownloadVersionResponse::DownloadVersionResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__DownloadVersionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__DownloadVersionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__DownloadVersionResponse * SOAP_FMAC4 soap_get__ns3__DownloadVersionResponse(struct soap *soap, _ns3__DownloadVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__DownloadVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__DownloadVersionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__DownloadVersionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__DownloadVersionResponse * SOAP_FMAC4 soap_in__ns3__DownloadVersionResponse(struct soap *soap, const char *tag, _ns3__DownloadVersionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__DownloadVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__DownloadVersionResponse, sizeof(_ns3__DownloadVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__DownloadVersionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__DownloadVersionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_DownloadVersionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DownloadVersionResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__VersionDTO(soap, "ns3:DownloadVersionResult", &(a->_ns3__DownloadVersionResponse::DownloadVersionResult), "ns3:VersionDTO"))
				{	soap_flag_DownloadVersionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:DownloadVersionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__DownloadVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__DownloadVersionResponse, 0, sizeof(_ns3__DownloadVersionResponse), 0, soap_copy__ns3__DownloadVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__DownloadVersionResponse * SOAP_FMAC4 soap_instantiate__ns3__DownloadVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__DownloadVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__DownloadVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__DownloadVersionResponse;
		if (size)
			*size = sizeof(_ns3__DownloadVersionResponse);
		((_ns3__DownloadVersionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__DownloadVersionResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__DownloadVersionResponse);
		for (int i = 0; i < n; i++)
			((_ns3__DownloadVersionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__DownloadVersionResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__DownloadVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__DownloadVersionResponse %p -> %p\n", q, p));
	*(_ns3__DownloadVersionResponse*)p = *(_ns3__DownloadVersionResponse*)q;
}

void _ns3__DownloadVersion::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__DownloadVersion::versionid = NULL;
	/* transient soap skipped */
}

void _ns3__DownloadVersion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__DownloadVersion::versionid);
	/* transient soap skipped */
}

int _ns3__DownloadVersion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__DownloadVersion);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__DownloadVersion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__DownloadVersion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__DownloadVersion(struct soap *soap, const char *tag, int id, const _ns3__DownloadVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__DownloadVersion), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:versionid", -1, &(a->_ns3__DownloadVersion::versionid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__DownloadVersion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__DownloadVersion(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__DownloadVersion * SOAP_FMAC4 soap_get__ns3__DownloadVersion(struct soap *soap, _ns3__DownloadVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__DownloadVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__DownloadVersion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__DownloadVersion(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__DownloadVersion * SOAP_FMAC4 soap_in__ns3__DownloadVersion(struct soap *soap, const char *tag, _ns3__DownloadVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__DownloadVersion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__DownloadVersion, sizeof(_ns3__DownloadVersion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__DownloadVersion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__DownloadVersion *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_versionid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_versionid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:versionid", &(a->_ns3__DownloadVersion::versionid), "ns4:guid"))
				{	soap_flag_versionid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__DownloadVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__DownloadVersion, 0, sizeof(_ns3__DownloadVersion), 0, soap_copy__ns3__DownloadVersion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_versionid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__DownloadVersion * SOAP_FMAC4 soap_instantiate__ns3__DownloadVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__DownloadVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__DownloadVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__DownloadVersion;
		if (size)
			*size = sizeof(_ns3__DownloadVersion);
		((_ns3__DownloadVersion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__DownloadVersion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__DownloadVersion);
		for (int i = 0; i < n; i++)
			((_ns3__DownloadVersion*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__DownloadVersion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__DownloadVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__DownloadVersion %p -> %p\n", q, p));
	*(_ns3__DownloadVersion*)p = *(_ns3__DownloadVersion*)q;
}

void _ns3__CheckInAssetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__CheckInAssetResponse::CheckInAssetResult = NULL;
	/* transient soap skipped */
}

void _ns3__CheckInAssetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__AssetDTO(soap, &this->_ns3__CheckInAssetResponse::CheckInAssetResult);
	/* transient soap skipped */
}

int _ns3__CheckInAssetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__CheckInAssetResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__CheckInAssetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__CheckInAssetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__CheckInAssetResponse(struct soap *soap, const char *tag, int id, const _ns3__CheckInAssetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__CheckInAssetResponse), type))
		return soap->error;
	if (a->CheckInAssetResult)
		soap_element_result(soap, "ns3:CheckInAssetResult");
	if (soap_out_PointerTons3__AssetDTO(soap, "ns3:CheckInAssetResult", -1, &(a->_ns3__CheckInAssetResponse::CheckInAssetResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__CheckInAssetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__CheckInAssetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__CheckInAssetResponse * SOAP_FMAC4 soap_get__ns3__CheckInAssetResponse(struct soap *soap, _ns3__CheckInAssetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__CheckInAssetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__CheckInAssetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__CheckInAssetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__CheckInAssetResponse * SOAP_FMAC4 soap_in__ns3__CheckInAssetResponse(struct soap *soap, const char *tag, _ns3__CheckInAssetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__CheckInAssetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__CheckInAssetResponse, sizeof(_ns3__CheckInAssetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__CheckInAssetResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__CheckInAssetResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CheckInAssetResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CheckInAssetResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__AssetDTO(soap, "ns3:CheckInAssetResult", &(a->_ns3__CheckInAssetResponse::CheckInAssetResult), "ns3:AssetDTO"))
				{	soap_flag_CheckInAssetResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:CheckInAssetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__CheckInAssetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__CheckInAssetResponse, 0, sizeof(_ns3__CheckInAssetResponse), 0, soap_copy__ns3__CheckInAssetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__CheckInAssetResponse * SOAP_FMAC4 soap_instantiate__ns3__CheckInAssetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__CheckInAssetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__CheckInAssetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__CheckInAssetResponse;
		if (size)
			*size = sizeof(_ns3__CheckInAssetResponse);
		((_ns3__CheckInAssetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__CheckInAssetResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__CheckInAssetResponse);
		for (int i = 0; i < n; i++)
			((_ns3__CheckInAssetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__CheckInAssetResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__CheckInAssetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__CheckInAssetResponse %p -> %p\n", q, p));
	*(_ns3__CheckInAssetResponse*)p = *(_ns3__CheckInAssetResponse*)q;
}

void _ns3__CheckInAsset::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__CheckInAsset::assetid = NULL;
	this->_ns3__CheckInAsset::statusid = NULL;
	this->_ns3__CheckInAsset::comment = NULL;
	this->_ns3__CheckInAsset::versionId = NULL;
	soap_default_int(soap, &this->_ns3__CheckInAsset::headVersion);
	/* transient soap skipped */
}

void _ns3__CheckInAsset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__CheckInAsset::assetid);
	soap_serialize_ns4__guid(soap, &this->_ns3__CheckInAsset::statusid);
	soap_serialize_wstring(soap, &this->_ns3__CheckInAsset::comment);
	soap_serialize_ns4__guid(soap, &this->_ns3__CheckInAsset::versionId);
	soap_embedded(soap, &this->_ns3__CheckInAsset::headVersion, SOAP_TYPE_int);
	/* transient soap skipped */
}

int _ns3__CheckInAsset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__CheckInAsset);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__CheckInAsset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__CheckInAsset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__CheckInAsset(struct soap *soap, const char *tag, int id, const _ns3__CheckInAsset *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__CheckInAsset), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:assetid", -1, &(a->_ns3__CheckInAsset::assetid), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:statusid", -1, &(a->_ns3__CheckInAsset::statusid), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:comment", -1, &(a->_ns3__CheckInAsset::comment), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:versionId", -1, &(a->_ns3__CheckInAsset::versionId), ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:headVersion", -1, &(a->_ns3__CheckInAsset::headVersion), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__CheckInAsset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__CheckInAsset(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__CheckInAsset * SOAP_FMAC4 soap_get__ns3__CheckInAsset(struct soap *soap, _ns3__CheckInAsset *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__CheckInAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__CheckInAsset::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__CheckInAsset(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__CheckInAsset * SOAP_FMAC4 soap_in__ns3__CheckInAsset(struct soap *soap, const char *tag, _ns3__CheckInAsset *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__CheckInAsset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__CheckInAsset, sizeof(_ns3__CheckInAsset), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__CheckInAsset)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__CheckInAsset *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_assetid1 = 1;
	size_t soap_flag_statusid1 = 1;
	size_t soap_flag_comment1 = 1;
	size_t soap_flag_versionId1 = 1;
	size_t soap_flag_headVersion1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assetid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:assetid", &(a->_ns3__CheckInAsset::assetid), "ns4:guid"))
				{	soap_flag_assetid1--;
					continue;
				}
			if (soap_flag_statusid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:statusid", &(a->_ns3__CheckInAsset::statusid), "ns4:guid"))
				{	soap_flag_statusid1--;
					continue;
				}
			if (soap_flag_comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:comment", &(a->_ns3__CheckInAsset::comment), "xsd:string"))
				{	soap_flag_comment1--;
					continue;
				}
			if (soap_flag_versionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:versionId", &(a->_ns3__CheckInAsset::versionId), "ns4:guid"))
				{	soap_flag_versionId1--;
					continue;
				}
			if (soap_flag_headVersion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns3:headVersion", &(a->_ns3__CheckInAsset::headVersion), "xsd:int"))
				{	soap_flag_headVersion1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__CheckInAsset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__CheckInAsset, 0, sizeof(_ns3__CheckInAsset), 0, soap_copy__ns3__CheckInAsset);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_assetid1 > 0 || soap_flag_statusid1 > 0 || soap_flag_versionId1 > 0 || soap_flag_headVersion1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__CheckInAsset * SOAP_FMAC4 soap_instantiate__ns3__CheckInAsset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__CheckInAsset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__CheckInAsset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__CheckInAsset;
		if (size)
			*size = sizeof(_ns3__CheckInAsset);
		((_ns3__CheckInAsset*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__CheckInAsset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__CheckInAsset);
		for (int i = 0; i < n; i++)
			((_ns3__CheckInAsset*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__CheckInAsset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__CheckInAsset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__CheckInAsset %p -> %p\n", q, p));
	*(_ns3__CheckInAsset*)p = *(_ns3__CheckInAsset*)q;
}

void _ns3__GetLockResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetLockResponse::GetLockResult = NULL;
	/* transient soap skipped */
}

void _ns3__GetLockResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__ArrayOfLockDTO(soap, &this->_ns3__GetLockResponse::GetLockResult);
	/* transient soap skipped */
}

int _ns3__GetLockResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetLockResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetLockResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetLockResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetLockResponse(struct soap *soap, const char *tag, int id, const _ns3__GetLockResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetLockResponse), type))
		return soap->error;
	if (a->GetLockResult)
		soap_element_result(soap, "ns3:GetLockResult");
	if (soap_out_PointerTons3__ArrayOfLockDTO(soap, "ns3:GetLockResult", -1, &(a->_ns3__GetLockResponse::GetLockResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetLockResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetLockResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetLockResponse * SOAP_FMAC4 soap_get__ns3__GetLockResponse(struct soap *soap, _ns3__GetLockResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetLockResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetLockResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetLockResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetLockResponse * SOAP_FMAC4 soap_in__ns3__GetLockResponse(struct soap *soap, const char *tag, _ns3__GetLockResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetLockResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetLockResponse, sizeof(_ns3__GetLockResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetLockResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetLockResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetLockResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetLockResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfLockDTO(soap, "ns3:GetLockResult", &(a->_ns3__GetLockResponse::GetLockResult), "ns3:ArrayOfLockDTO"))
				{	soap_flag_GetLockResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:GetLockResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetLockResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetLockResponse, 0, sizeof(_ns3__GetLockResponse), 0, soap_copy__ns3__GetLockResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetLockResponse * SOAP_FMAC4 soap_instantiate__ns3__GetLockResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetLockResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetLockResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetLockResponse;
		if (size)
			*size = sizeof(_ns3__GetLockResponse);
		((_ns3__GetLockResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetLockResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetLockResponse);
		for (int i = 0; i < n; i++)
			((_ns3__GetLockResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetLockResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetLockResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetLockResponse %p -> %p\n", q, p));
	*(_ns3__GetLockResponse*)p = *(_ns3__GetLockResponse*)q;
}

void _ns3__GetLock::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetLock::assetids = NULL;
	/* transient soap skipped */
}

void _ns3__GetLock::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__ArrayOfGuid(soap, &this->_ns3__GetLock::assetids);
	/* transient soap skipped */
}

int _ns3__GetLock::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetLock);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetLock::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetLock(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetLock(struct soap *soap, const char *tag, int id, const _ns3__GetLock *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetLock), type))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfGuid(soap, "ns3:assetids", -1, &(a->_ns3__GetLock::assetids), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetLock::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetLock(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetLock * SOAP_FMAC4 soap_get__ns3__GetLock(struct soap *soap, _ns3__GetLock *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetLock(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetLock::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetLock(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetLock * SOAP_FMAC4 soap_in__ns3__GetLock(struct soap *soap, const char *tag, _ns3__GetLock *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetLock *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetLock, sizeof(_ns3__GetLock), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetLock)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetLock *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_assetids1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assetids1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfGuid(soap, "ns3:assetids", &(a->_ns3__GetLock::assetids), "ns3:ArrayOfGuid"))
				{	soap_flag_assetids1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetLock *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetLock, 0, sizeof(_ns3__GetLock), 0, soap_copy__ns3__GetLock);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetLock * SOAP_FMAC4 soap_instantiate__ns3__GetLock(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetLock(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetLock, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetLock;
		if (size)
			*size = sizeof(_ns3__GetLock);
		((_ns3__GetLock*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetLock[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetLock);
		for (int i = 0; i < n; i++)
			((_ns3__GetLock*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetLock*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetLock(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetLock %p -> %p\n", q, p));
	*(_ns3__GetLock*)p = *(_ns3__GetLock*)q;
}

void _ns3__UpdateAssetStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__UpdateAssetStatusResponse::UpdateAssetStatusResult = NULL;
	/* transient soap skipped */
}

void _ns3__UpdateAssetStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__AssetDTO(soap, &this->_ns3__UpdateAssetStatusResponse::UpdateAssetStatusResult);
	/* transient soap skipped */
}

int _ns3__UpdateAssetStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__UpdateAssetStatusResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__UpdateAssetStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__UpdateAssetStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UpdateAssetStatusResponse(struct soap *soap, const char *tag, int id, const _ns3__UpdateAssetStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UpdateAssetStatusResponse), type))
		return soap->error;
	if (a->UpdateAssetStatusResult)
		soap_element_result(soap, "ns3:UpdateAssetStatusResult");
	if (soap_out_PointerTons3__AssetDTO(soap, "ns3:UpdateAssetStatusResult", -1, &(a->_ns3__UpdateAssetStatusResponse::UpdateAssetStatusResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__UpdateAssetStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__UpdateAssetStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__UpdateAssetStatusResponse * SOAP_FMAC4 soap_get__ns3__UpdateAssetStatusResponse(struct soap *soap, _ns3__UpdateAssetStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UpdateAssetStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__UpdateAssetStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__UpdateAssetStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__UpdateAssetStatusResponse * SOAP_FMAC4 soap_in__ns3__UpdateAssetStatusResponse(struct soap *soap, const char *tag, _ns3__UpdateAssetStatusResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__UpdateAssetStatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UpdateAssetStatusResponse, sizeof(_ns3__UpdateAssetStatusResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__UpdateAssetStatusResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__UpdateAssetStatusResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UpdateAssetStatusResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdateAssetStatusResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__AssetDTO(soap, "ns3:UpdateAssetStatusResult", &(a->_ns3__UpdateAssetStatusResponse::UpdateAssetStatusResult), "ns3:AssetDTO"))
				{	soap_flag_UpdateAssetStatusResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:UpdateAssetStatusResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__UpdateAssetStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UpdateAssetStatusResponse, 0, sizeof(_ns3__UpdateAssetStatusResponse), 0, soap_copy__ns3__UpdateAssetStatusResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__UpdateAssetStatusResponse * SOAP_FMAC4 soap_instantiate__ns3__UpdateAssetStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__UpdateAssetStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__UpdateAssetStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__UpdateAssetStatusResponse;
		if (size)
			*size = sizeof(_ns3__UpdateAssetStatusResponse);
		((_ns3__UpdateAssetStatusResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__UpdateAssetStatusResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__UpdateAssetStatusResponse);
		for (int i = 0; i < n; i++)
			((_ns3__UpdateAssetStatusResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__UpdateAssetStatusResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__UpdateAssetStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__UpdateAssetStatusResponse %p -> %p\n", q, p));
	*(_ns3__UpdateAssetStatusResponse*)p = *(_ns3__UpdateAssetStatusResponse*)q;
}

void _ns3__UpdateAssetStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__UpdateAssetStatus::assetid = NULL;
	this->_ns3__UpdateAssetStatus::oldstatusid = NULL;
	this->_ns3__UpdateAssetStatus::newstatusid = NULL;
	/* transient soap skipped */
}

void _ns3__UpdateAssetStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__UpdateAssetStatus::assetid);
	soap_serialize_ns4__guid(soap, &this->_ns3__UpdateAssetStatus::oldstatusid);
	soap_serialize_ns4__guid(soap, &this->_ns3__UpdateAssetStatus::newstatusid);
	/* transient soap skipped */
}

int _ns3__UpdateAssetStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__UpdateAssetStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__UpdateAssetStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__UpdateAssetStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UpdateAssetStatus(struct soap *soap, const char *tag, int id, const _ns3__UpdateAssetStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UpdateAssetStatus), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:assetid", -1, &(a->_ns3__UpdateAssetStatus::assetid), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:oldstatusid", -1, &(a->_ns3__UpdateAssetStatus::oldstatusid), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:newstatusid", -1, &(a->_ns3__UpdateAssetStatus::newstatusid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__UpdateAssetStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__UpdateAssetStatus(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__UpdateAssetStatus * SOAP_FMAC4 soap_get__ns3__UpdateAssetStatus(struct soap *soap, _ns3__UpdateAssetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UpdateAssetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__UpdateAssetStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__UpdateAssetStatus(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__UpdateAssetStatus * SOAP_FMAC4 soap_in__ns3__UpdateAssetStatus(struct soap *soap, const char *tag, _ns3__UpdateAssetStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__UpdateAssetStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UpdateAssetStatus, sizeof(_ns3__UpdateAssetStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__UpdateAssetStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__UpdateAssetStatus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_assetid1 = 1;
	size_t soap_flag_oldstatusid1 = 1;
	size_t soap_flag_newstatusid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assetid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:assetid", &(a->_ns3__UpdateAssetStatus::assetid), "ns4:guid"))
				{	soap_flag_assetid1--;
					continue;
				}
			if (soap_flag_oldstatusid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:oldstatusid", &(a->_ns3__UpdateAssetStatus::oldstatusid), "ns4:guid"))
				{	soap_flag_oldstatusid1--;
					continue;
				}
			if (soap_flag_newstatusid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:newstatusid", &(a->_ns3__UpdateAssetStatus::newstatusid), "ns4:guid"))
				{	soap_flag_newstatusid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__UpdateAssetStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UpdateAssetStatus, 0, sizeof(_ns3__UpdateAssetStatus), 0, soap_copy__ns3__UpdateAssetStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_assetid1 > 0 || soap_flag_oldstatusid1 > 0 || soap_flag_newstatusid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__UpdateAssetStatus * SOAP_FMAC4 soap_instantiate__ns3__UpdateAssetStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__UpdateAssetStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__UpdateAssetStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__UpdateAssetStatus;
		if (size)
			*size = sizeof(_ns3__UpdateAssetStatus);
		((_ns3__UpdateAssetStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__UpdateAssetStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__UpdateAssetStatus);
		for (int i = 0; i < n; i++)
			((_ns3__UpdateAssetStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__UpdateAssetStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__UpdateAssetStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__UpdateAssetStatus %p -> %p\n", q, p));
	*(_ns3__UpdateAssetStatus*)p = *(_ns3__UpdateAssetStatus*)q;
}

void _ns3__UpdateAssetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__UpdateAssetResponse::UpdateAssetResult = NULL;
	/* transient soap skipped */
}

void _ns3__UpdateAssetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__AssetDTO(soap, &this->_ns3__UpdateAssetResponse::UpdateAssetResult);
	/* transient soap skipped */
}

int _ns3__UpdateAssetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__UpdateAssetResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__UpdateAssetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__UpdateAssetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UpdateAssetResponse(struct soap *soap, const char *tag, int id, const _ns3__UpdateAssetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UpdateAssetResponse), type))
		return soap->error;
	if (a->UpdateAssetResult)
		soap_element_result(soap, "ns3:UpdateAssetResult");
	if (soap_out_PointerTons3__AssetDTO(soap, "ns3:UpdateAssetResult", -1, &(a->_ns3__UpdateAssetResponse::UpdateAssetResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__UpdateAssetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__UpdateAssetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__UpdateAssetResponse * SOAP_FMAC4 soap_get__ns3__UpdateAssetResponse(struct soap *soap, _ns3__UpdateAssetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UpdateAssetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__UpdateAssetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__UpdateAssetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__UpdateAssetResponse * SOAP_FMAC4 soap_in__ns3__UpdateAssetResponse(struct soap *soap, const char *tag, _ns3__UpdateAssetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__UpdateAssetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UpdateAssetResponse, sizeof(_ns3__UpdateAssetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__UpdateAssetResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__UpdateAssetResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UpdateAssetResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdateAssetResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__AssetDTO(soap, "ns3:UpdateAssetResult", &(a->_ns3__UpdateAssetResponse::UpdateAssetResult), "ns3:AssetDTO"))
				{	soap_flag_UpdateAssetResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:UpdateAssetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__UpdateAssetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UpdateAssetResponse, 0, sizeof(_ns3__UpdateAssetResponse), 0, soap_copy__ns3__UpdateAssetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__UpdateAssetResponse * SOAP_FMAC4 soap_instantiate__ns3__UpdateAssetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__UpdateAssetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__UpdateAssetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__UpdateAssetResponse;
		if (size)
			*size = sizeof(_ns3__UpdateAssetResponse);
		((_ns3__UpdateAssetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__UpdateAssetResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__UpdateAssetResponse);
		for (int i = 0; i < n; i++)
			((_ns3__UpdateAssetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__UpdateAssetResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__UpdateAssetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__UpdateAssetResponse %p -> %p\n", q, p));
	*(_ns3__UpdateAssetResponse*)p = *(_ns3__UpdateAssetResponse*)q;
}

void _ns3__UpdateAsset::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__UpdateAsset::assetid = NULL;
	this->_ns3__UpdateAsset::assetdto = NULL;
	/* transient soap skipped */
}

void _ns3__UpdateAsset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__UpdateAsset::assetid);
	soap_serialize_PointerTons3__AssetDTO(soap, &this->_ns3__UpdateAsset::assetdto);
	/* transient soap skipped */
}

int _ns3__UpdateAsset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__UpdateAsset);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__UpdateAsset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__UpdateAsset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UpdateAsset(struct soap *soap, const char *tag, int id, const _ns3__UpdateAsset *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UpdateAsset), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:assetid", -1, &(a->_ns3__UpdateAsset::assetid), ""))
		return soap->error;
	if (soap_out_PointerTons3__AssetDTO(soap, "ns3:assetdto", -1, &(a->_ns3__UpdateAsset::assetdto), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__UpdateAsset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__UpdateAsset(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__UpdateAsset * SOAP_FMAC4 soap_get__ns3__UpdateAsset(struct soap *soap, _ns3__UpdateAsset *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UpdateAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__UpdateAsset::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__UpdateAsset(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__UpdateAsset * SOAP_FMAC4 soap_in__ns3__UpdateAsset(struct soap *soap, const char *tag, _ns3__UpdateAsset *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__UpdateAsset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UpdateAsset, sizeof(_ns3__UpdateAsset), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__UpdateAsset)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__UpdateAsset *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_assetid1 = 1;
	size_t soap_flag_assetdto1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assetid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:assetid", &(a->_ns3__UpdateAsset::assetid), "ns4:guid"))
				{	soap_flag_assetid1--;
					continue;
				}
			if (soap_flag_assetdto1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__AssetDTO(soap, "ns3:assetdto", &(a->_ns3__UpdateAsset::assetdto), "ns3:AssetDTO"))
				{	soap_flag_assetdto1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__UpdateAsset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UpdateAsset, 0, sizeof(_ns3__UpdateAsset), 0, soap_copy__ns3__UpdateAsset);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_assetid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__UpdateAsset * SOAP_FMAC4 soap_instantiate__ns3__UpdateAsset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__UpdateAsset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__UpdateAsset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__UpdateAsset;
		if (size)
			*size = sizeof(_ns3__UpdateAsset);
		((_ns3__UpdateAsset*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__UpdateAsset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__UpdateAsset);
		for (int i = 0; i < n; i++)
			((_ns3__UpdateAsset*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__UpdateAsset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__UpdateAsset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__UpdateAsset %p -> %p\n", q, p));
	*(_ns3__UpdateAsset*)p = *(_ns3__UpdateAsset*)q;
}

void _ns3__GetAssetListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetAssetListResponse::GetAssetListResult = NULL;
	/* transient soap skipped */
}

void _ns3__GetAssetListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__ArrayOfAssetDTO(soap, &this->_ns3__GetAssetListResponse::GetAssetListResult);
	/* transient soap skipped */
}

int _ns3__GetAssetListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetAssetListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetAssetListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetAssetListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetAssetListResponse(struct soap *soap, const char *tag, int id, const _ns3__GetAssetListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetAssetListResponse), type))
		return soap->error;
	if (a->GetAssetListResult)
		soap_element_result(soap, "ns3:GetAssetListResult");
	if (soap_out_PointerTons3__ArrayOfAssetDTO(soap, "ns3:GetAssetListResult", -1, &(a->_ns3__GetAssetListResponse::GetAssetListResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetAssetListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetAssetListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetAssetListResponse * SOAP_FMAC4 soap_get__ns3__GetAssetListResponse(struct soap *soap, _ns3__GetAssetListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetAssetListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetAssetListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetAssetListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetAssetListResponse * SOAP_FMAC4 soap_in__ns3__GetAssetListResponse(struct soap *soap, const char *tag, _ns3__GetAssetListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetAssetListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetAssetListResponse, sizeof(_ns3__GetAssetListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetAssetListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetAssetListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetAssetListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAssetListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfAssetDTO(soap, "ns3:GetAssetListResult", &(a->_ns3__GetAssetListResponse::GetAssetListResult), "ns3:ArrayOfAssetDTO"))
				{	soap_flag_GetAssetListResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:GetAssetListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetAssetListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetAssetListResponse, 0, sizeof(_ns3__GetAssetListResponse), 0, soap_copy__ns3__GetAssetListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetAssetListResponse * SOAP_FMAC4 soap_instantiate__ns3__GetAssetListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetAssetListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetAssetListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetAssetListResponse;
		if (size)
			*size = sizeof(_ns3__GetAssetListResponse);
		((_ns3__GetAssetListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetAssetListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetAssetListResponse);
		for (int i = 0; i < n; i++)
			((_ns3__GetAssetListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetAssetListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetAssetListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetAssetListResponse %p -> %p\n", q, p));
	*(_ns3__GetAssetListResponse*)p = *(_ns3__GetAssetListResponse*)q;
}

void _ns3__GetAssetList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetAssetList::shelveid = NULL;
	this->_ns3__GetAssetList::types = NULL;
	/* transient soap skipped */
}

void _ns3__GetAssetList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__GetAssetList::shelveid);
	soap_serialize_PointerTons3__ArrayOfGuid(soap, &this->_ns3__GetAssetList::types);
	/* transient soap skipped */
}

int _ns3__GetAssetList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetAssetList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetAssetList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetAssetList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetAssetList(struct soap *soap, const char *tag, int id, const _ns3__GetAssetList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetAssetList), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:shelveid", -1, &(a->_ns3__GetAssetList::shelveid), ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfGuid(soap, "ns3:types", -1, &(a->_ns3__GetAssetList::types), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetAssetList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetAssetList(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetAssetList * SOAP_FMAC4 soap_get__ns3__GetAssetList(struct soap *soap, _ns3__GetAssetList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetAssetList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetAssetList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetAssetList(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetAssetList * SOAP_FMAC4 soap_in__ns3__GetAssetList(struct soap *soap, const char *tag, _ns3__GetAssetList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetAssetList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetAssetList, sizeof(_ns3__GetAssetList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetAssetList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetAssetList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_shelveid1 = 1;
	size_t soap_flag_types1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_shelveid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:shelveid", &(a->_ns3__GetAssetList::shelveid), "ns4:guid"))
				{	soap_flag_shelveid1--;
					continue;
				}
			if (soap_flag_types1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfGuid(soap, "ns3:types", &(a->_ns3__GetAssetList::types), "ns3:ArrayOfGuid"))
				{	soap_flag_types1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetAssetList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetAssetList, 0, sizeof(_ns3__GetAssetList), 0, soap_copy__ns3__GetAssetList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_shelveid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetAssetList * SOAP_FMAC4 soap_instantiate__ns3__GetAssetList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetAssetList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetAssetList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetAssetList;
		if (size)
			*size = sizeof(_ns3__GetAssetList);
		((_ns3__GetAssetList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetAssetList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetAssetList);
		for (int i = 0; i < n; i++)
			((_ns3__GetAssetList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetAssetList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetAssetList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetAssetList %p -> %p\n", q, p));
	*(_ns3__GetAssetList*)p = *(_ns3__GetAssetList*)q;
}

void _ns3__GetStatusByTitleResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetStatusByTitleResponse::GetStatusByTitleResult = NULL;
	/* transient soap skipped */
}

void _ns3__GetStatusByTitleResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__ArrayOfTitleStatusDTO(soap, &this->_ns3__GetStatusByTitleResponse::GetStatusByTitleResult);
	/* transient soap skipped */
}

int _ns3__GetStatusByTitleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetStatusByTitleResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetStatusByTitleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetStatusByTitleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetStatusByTitleResponse(struct soap *soap, const char *tag, int id, const _ns3__GetStatusByTitleResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetStatusByTitleResponse), type))
		return soap->error;
	if (a->GetStatusByTitleResult)
		soap_element_result(soap, "ns3:GetStatusByTitleResult");
	if (soap_out_PointerTons3__ArrayOfTitleStatusDTO(soap, "ns3:GetStatusByTitleResult", -1, &(a->_ns3__GetStatusByTitleResponse::GetStatusByTitleResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetStatusByTitleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetStatusByTitleResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetStatusByTitleResponse * SOAP_FMAC4 soap_get__ns3__GetStatusByTitleResponse(struct soap *soap, _ns3__GetStatusByTitleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetStatusByTitleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetStatusByTitleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetStatusByTitleResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetStatusByTitleResponse * SOAP_FMAC4 soap_in__ns3__GetStatusByTitleResponse(struct soap *soap, const char *tag, _ns3__GetStatusByTitleResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetStatusByTitleResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetStatusByTitleResponse, sizeof(_ns3__GetStatusByTitleResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetStatusByTitleResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetStatusByTitleResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetStatusByTitleResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetStatusByTitleResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfTitleStatusDTO(soap, "ns3:GetStatusByTitleResult", &(a->_ns3__GetStatusByTitleResponse::GetStatusByTitleResult), "ns3:ArrayOfTitleStatusDTO"))
				{	soap_flag_GetStatusByTitleResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:GetStatusByTitleResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetStatusByTitleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetStatusByTitleResponse, 0, sizeof(_ns3__GetStatusByTitleResponse), 0, soap_copy__ns3__GetStatusByTitleResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetStatusByTitleResponse * SOAP_FMAC4 soap_instantiate__ns3__GetStatusByTitleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetStatusByTitleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetStatusByTitleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetStatusByTitleResponse;
		if (size)
			*size = sizeof(_ns3__GetStatusByTitleResponse);
		((_ns3__GetStatusByTitleResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetStatusByTitleResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetStatusByTitleResponse);
		for (int i = 0; i < n; i++)
			((_ns3__GetStatusByTitleResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetStatusByTitleResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetStatusByTitleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetStatusByTitleResponse %p -> %p\n", q, p));
	*(_ns3__GetStatusByTitleResponse*)p = *(_ns3__GetStatusByTitleResponse*)q;
}

void _ns3__GetStatusByTitle::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetStatusByTitle::titleid = NULL;
	/* transient soap skipped */
}

void _ns3__GetStatusByTitle::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__GetStatusByTitle::titleid);
	/* transient soap skipped */
}

int _ns3__GetStatusByTitle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetStatusByTitle);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetStatusByTitle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetStatusByTitle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetStatusByTitle(struct soap *soap, const char *tag, int id, const _ns3__GetStatusByTitle *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetStatusByTitle), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:titleid", -1, &(a->_ns3__GetStatusByTitle::titleid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetStatusByTitle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetStatusByTitle(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetStatusByTitle * SOAP_FMAC4 soap_get__ns3__GetStatusByTitle(struct soap *soap, _ns3__GetStatusByTitle *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetStatusByTitle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetStatusByTitle::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetStatusByTitle(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetStatusByTitle * SOAP_FMAC4 soap_in__ns3__GetStatusByTitle(struct soap *soap, const char *tag, _ns3__GetStatusByTitle *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetStatusByTitle *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetStatusByTitle, sizeof(_ns3__GetStatusByTitle), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetStatusByTitle)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetStatusByTitle *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_titleid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_titleid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:titleid", &(a->_ns3__GetStatusByTitle::titleid), "ns4:guid"))
				{	soap_flag_titleid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetStatusByTitle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetStatusByTitle, 0, sizeof(_ns3__GetStatusByTitle), 0, soap_copy__ns3__GetStatusByTitle);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_titleid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetStatusByTitle * SOAP_FMAC4 soap_instantiate__ns3__GetStatusByTitle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetStatusByTitle(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetStatusByTitle, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetStatusByTitle;
		if (size)
			*size = sizeof(_ns3__GetStatusByTitle);
		((_ns3__GetStatusByTitle*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetStatusByTitle[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetStatusByTitle);
		for (int i = 0; i < n; i++)
			((_ns3__GetStatusByTitle*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetStatusByTitle*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetStatusByTitle(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetStatusByTitle %p -> %p\n", q, p));
	*(_ns3__GetStatusByTitle*)p = *(_ns3__GetStatusByTitle*)q;
}

void _ns3__GetEditionsByTitleResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetEditionsByTitleResponse::GetEditionsByTitleResult = NULL;
	/* transient soap skipped */
}

void _ns3__GetEditionsByTitleResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__ArrayOfEditionTitlesDTO(soap, &this->_ns3__GetEditionsByTitleResponse::GetEditionsByTitleResult);
	/* transient soap skipped */
}

int _ns3__GetEditionsByTitleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetEditionsByTitleResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetEditionsByTitleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetEditionsByTitleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetEditionsByTitleResponse(struct soap *soap, const char *tag, int id, const _ns3__GetEditionsByTitleResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetEditionsByTitleResponse), type))
		return soap->error;
	if (a->GetEditionsByTitleResult)
		soap_element_result(soap, "ns3:GetEditionsByTitleResult");
	if (soap_out_PointerTons3__ArrayOfEditionTitlesDTO(soap, "ns3:GetEditionsByTitleResult", -1, &(a->_ns3__GetEditionsByTitleResponse::GetEditionsByTitleResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetEditionsByTitleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetEditionsByTitleResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetEditionsByTitleResponse * SOAP_FMAC4 soap_get__ns3__GetEditionsByTitleResponse(struct soap *soap, _ns3__GetEditionsByTitleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetEditionsByTitleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetEditionsByTitleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetEditionsByTitleResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetEditionsByTitleResponse * SOAP_FMAC4 soap_in__ns3__GetEditionsByTitleResponse(struct soap *soap, const char *tag, _ns3__GetEditionsByTitleResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetEditionsByTitleResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetEditionsByTitleResponse, sizeof(_ns3__GetEditionsByTitleResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetEditionsByTitleResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetEditionsByTitleResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetEditionsByTitleResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetEditionsByTitleResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfEditionTitlesDTO(soap, "ns3:GetEditionsByTitleResult", &(a->_ns3__GetEditionsByTitleResponse::GetEditionsByTitleResult), "ns3:ArrayOfEditionTitlesDTO"))
				{	soap_flag_GetEditionsByTitleResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:GetEditionsByTitleResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetEditionsByTitleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetEditionsByTitleResponse, 0, sizeof(_ns3__GetEditionsByTitleResponse), 0, soap_copy__ns3__GetEditionsByTitleResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetEditionsByTitleResponse * SOAP_FMAC4 soap_instantiate__ns3__GetEditionsByTitleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetEditionsByTitleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetEditionsByTitleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetEditionsByTitleResponse;
		if (size)
			*size = sizeof(_ns3__GetEditionsByTitleResponse);
		((_ns3__GetEditionsByTitleResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetEditionsByTitleResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetEditionsByTitleResponse);
		for (int i = 0; i < n; i++)
			((_ns3__GetEditionsByTitleResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetEditionsByTitleResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetEditionsByTitleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetEditionsByTitleResponse %p -> %p\n", q, p));
	*(_ns3__GetEditionsByTitleResponse*)p = *(_ns3__GetEditionsByTitleResponse*)q;
}

void _ns3__GetEditionsByTitle::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetEditionsByTitle::titleid = NULL;
	/* transient soap skipped */
}

void _ns3__GetEditionsByTitle::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__GetEditionsByTitle::titleid);
	/* transient soap skipped */
}

int _ns3__GetEditionsByTitle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetEditionsByTitle);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetEditionsByTitle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetEditionsByTitle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetEditionsByTitle(struct soap *soap, const char *tag, int id, const _ns3__GetEditionsByTitle *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetEditionsByTitle), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:titleid", -1, &(a->_ns3__GetEditionsByTitle::titleid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetEditionsByTitle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetEditionsByTitle(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetEditionsByTitle * SOAP_FMAC4 soap_get__ns3__GetEditionsByTitle(struct soap *soap, _ns3__GetEditionsByTitle *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetEditionsByTitle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetEditionsByTitle::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetEditionsByTitle(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetEditionsByTitle * SOAP_FMAC4 soap_in__ns3__GetEditionsByTitle(struct soap *soap, const char *tag, _ns3__GetEditionsByTitle *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetEditionsByTitle *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetEditionsByTitle, sizeof(_ns3__GetEditionsByTitle), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetEditionsByTitle)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetEditionsByTitle *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_titleid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_titleid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:titleid", &(a->_ns3__GetEditionsByTitle::titleid), "ns4:guid"))
				{	soap_flag_titleid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetEditionsByTitle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetEditionsByTitle, 0, sizeof(_ns3__GetEditionsByTitle), 0, soap_copy__ns3__GetEditionsByTitle);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_titleid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetEditionsByTitle * SOAP_FMAC4 soap_instantiate__ns3__GetEditionsByTitle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetEditionsByTitle(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetEditionsByTitle, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetEditionsByTitle;
		if (size)
			*size = sizeof(_ns3__GetEditionsByTitle);
		((_ns3__GetEditionsByTitle*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetEditionsByTitle[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetEditionsByTitle);
		for (int i = 0; i < n; i++)
			((_ns3__GetEditionsByTitle*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetEditionsByTitle*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetEditionsByTitle(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetEditionsByTitle %p -> %p\n", q, p));
	*(_ns3__GetEditionsByTitle*)p = *(_ns3__GetEditionsByTitle*)q;
}

void _ns3__CheckOutAssetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__CheckOutAssetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns3__CheckOutAssetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__CheckOutAssetResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__CheckOutAssetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__CheckOutAssetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__CheckOutAssetResponse(struct soap *soap, const char *tag, int id, const _ns3__CheckOutAssetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__CheckOutAssetResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__CheckOutAssetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__CheckOutAssetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__CheckOutAssetResponse * SOAP_FMAC4 soap_get__ns3__CheckOutAssetResponse(struct soap *soap, _ns3__CheckOutAssetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__CheckOutAssetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__CheckOutAssetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__CheckOutAssetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__CheckOutAssetResponse * SOAP_FMAC4 soap_in__ns3__CheckOutAssetResponse(struct soap *soap, const char *tag, _ns3__CheckOutAssetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__CheckOutAssetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__CheckOutAssetResponse, sizeof(_ns3__CheckOutAssetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__CheckOutAssetResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__CheckOutAssetResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__CheckOutAssetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__CheckOutAssetResponse, 0, sizeof(_ns3__CheckOutAssetResponse), 0, soap_copy__ns3__CheckOutAssetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__CheckOutAssetResponse * SOAP_FMAC4 soap_instantiate__ns3__CheckOutAssetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__CheckOutAssetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__CheckOutAssetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__CheckOutAssetResponse;
		if (size)
			*size = sizeof(_ns3__CheckOutAssetResponse);
		((_ns3__CheckOutAssetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__CheckOutAssetResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__CheckOutAssetResponse);
		for (int i = 0; i < n; i++)
			((_ns3__CheckOutAssetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__CheckOutAssetResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__CheckOutAssetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__CheckOutAssetResponse %p -> %p\n", q, p));
	*(_ns3__CheckOutAssetResponse*)p = *(_ns3__CheckOutAssetResponse*)q;
}

void _ns3__CheckOutAsset::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__CheckOutAsset::assetid = NULL;
	/* transient soap skipped */
}

void _ns3__CheckOutAsset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->_ns3__CheckOutAsset::assetid);
	/* transient soap skipped */
}

int _ns3__CheckOutAsset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__CheckOutAsset);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__CheckOutAsset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__CheckOutAsset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__CheckOutAsset(struct soap *soap, const char *tag, int id, const _ns3__CheckOutAsset *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__CheckOutAsset), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:assetid", -1, &(a->_ns3__CheckOutAsset::assetid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__CheckOutAsset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__CheckOutAsset(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__CheckOutAsset * SOAP_FMAC4 soap_get__ns3__CheckOutAsset(struct soap *soap, _ns3__CheckOutAsset *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__CheckOutAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__CheckOutAsset::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__CheckOutAsset(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__CheckOutAsset * SOAP_FMAC4 soap_in__ns3__CheckOutAsset(struct soap *soap, const char *tag, _ns3__CheckOutAsset *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__CheckOutAsset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__CheckOutAsset, sizeof(_ns3__CheckOutAsset), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__CheckOutAsset)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__CheckOutAsset *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_assetid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assetid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:assetid", &(a->_ns3__CheckOutAsset::assetid), "xsd:string"))
				{	soap_flag_assetid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__CheckOutAsset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__CheckOutAsset, 0, sizeof(_ns3__CheckOutAsset), 0, soap_copy__ns3__CheckOutAsset);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__CheckOutAsset * SOAP_FMAC4 soap_instantiate__ns3__CheckOutAsset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__CheckOutAsset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__CheckOutAsset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__CheckOutAsset;
		if (size)
			*size = sizeof(_ns3__CheckOutAsset);
		((_ns3__CheckOutAsset*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__CheckOutAsset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__CheckOutAsset);
		for (int i = 0; i < n; i++)
			((_ns3__CheckOutAsset*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__CheckOutAsset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__CheckOutAsset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__CheckOutAsset %p -> %p\n", q, p));
	*(_ns3__CheckOutAsset*)p = *(_ns3__CheckOutAsset*)q;
}

void _ns3__GetEditionTaskListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetEditionTaskListResponse::GetEditionTaskListResult = NULL;
	/* transient soap skipped */
}

void _ns3__GetEditionTaskListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__ArrayOfTaskDTO(soap, &this->_ns3__GetEditionTaskListResponse::GetEditionTaskListResult);
	/* transient soap skipped */
}

int _ns3__GetEditionTaskListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetEditionTaskListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetEditionTaskListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetEditionTaskListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetEditionTaskListResponse(struct soap *soap, const char *tag, int id, const _ns3__GetEditionTaskListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetEditionTaskListResponse), type))
		return soap->error;
	if (a->GetEditionTaskListResult)
		soap_element_result(soap, "ns3:GetEditionTaskListResult");
	if (soap_out_PointerTons3__ArrayOfTaskDTO(soap, "ns3:GetEditionTaskListResult", -1, &(a->_ns3__GetEditionTaskListResponse::GetEditionTaskListResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetEditionTaskListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetEditionTaskListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetEditionTaskListResponse * SOAP_FMAC4 soap_get__ns3__GetEditionTaskListResponse(struct soap *soap, _ns3__GetEditionTaskListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetEditionTaskListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetEditionTaskListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetEditionTaskListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetEditionTaskListResponse * SOAP_FMAC4 soap_in__ns3__GetEditionTaskListResponse(struct soap *soap, const char *tag, _ns3__GetEditionTaskListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetEditionTaskListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetEditionTaskListResponse, sizeof(_ns3__GetEditionTaskListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetEditionTaskListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetEditionTaskListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetEditionTaskListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetEditionTaskListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfTaskDTO(soap, "ns3:GetEditionTaskListResult", &(a->_ns3__GetEditionTaskListResponse::GetEditionTaskListResult), "ns3:ArrayOfTaskDTO"))
				{	soap_flag_GetEditionTaskListResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:GetEditionTaskListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetEditionTaskListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetEditionTaskListResponse, 0, sizeof(_ns3__GetEditionTaskListResponse), 0, soap_copy__ns3__GetEditionTaskListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetEditionTaskListResponse * SOAP_FMAC4 soap_instantiate__ns3__GetEditionTaskListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetEditionTaskListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetEditionTaskListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetEditionTaskListResponse;
		if (size)
			*size = sizeof(_ns3__GetEditionTaskListResponse);
		((_ns3__GetEditionTaskListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetEditionTaskListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetEditionTaskListResponse);
		for (int i = 0; i < n; i++)
			((_ns3__GetEditionTaskListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetEditionTaskListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetEditionTaskListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetEditionTaskListResponse %p -> %p\n", q, p));
	*(_ns3__GetEditionTaskListResponse*)p = *(_ns3__GetEditionTaskListResponse*)q;
}

void _ns3__GetEditionTaskList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetEditionTaskList::editionId = NULL;
	/* transient soap skipped */
}

void _ns3__GetEditionTaskList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__GetEditionTaskList::editionId);
	/* transient soap skipped */
}

int _ns3__GetEditionTaskList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetEditionTaskList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetEditionTaskList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetEditionTaskList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetEditionTaskList(struct soap *soap, const char *tag, int id, const _ns3__GetEditionTaskList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetEditionTaskList), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:editionId", -1, &(a->_ns3__GetEditionTaskList::editionId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetEditionTaskList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetEditionTaskList(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetEditionTaskList * SOAP_FMAC4 soap_get__ns3__GetEditionTaskList(struct soap *soap, _ns3__GetEditionTaskList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetEditionTaskList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetEditionTaskList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetEditionTaskList(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetEditionTaskList * SOAP_FMAC4 soap_in__ns3__GetEditionTaskList(struct soap *soap, const char *tag, _ns3__GetEditionTaskList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetEditionTaskList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetEditionTaskList, sizeof(_ns3__GetEditionTaskList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetEditionTaskList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetEditionTaskList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_editionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_editionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:editionId", &(a->_ns3__GetEditionTaskList::editionId), "ns4:guid"))
				{	soap_flag_editionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetEditionTaskList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetEditionTaskList, 0, sizeof(_ns3__GetEditionTaskList), 0, soap_copy__ns3__GetEditionTaskList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_editionId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetEditionTaskList * SOAP_FMAC4 soap_instantiate__ns3__GetEditionTaskList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetEditionTaskList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetEditionTaskList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetEditionTaskList;
		if (size)
			*size = sizeof(_ns3__GetEditionTaskList);
		((_ns3__GetEditionTaskList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetEditionTaskList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetEditionTaskList);
		for (int i = 0; i < n; i++)
			((_ns3__GetEditionTaskList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetEditionTaskList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetEditionTaskList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetEditionTaskList %p -> %p\n", q, p));
	*(_ns3__GetEditionTaskList*)p = *(_ns3__GetEditionTaskList*)q;
}

void _ns3__RelinkAssetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__RelinkAssetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns3__RelinkAssetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__RelinkAssetResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__RelinkAssetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__RelinkAssetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__RelinkAssetResponse(struct soap *soap, const char *tag, int id, const _ns3__RelinkAssetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__RelinkAssetResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__RelinkAssetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__RelinkAssetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__RelinkAssetResponse * SOAP_FMAC4 soap_get__ns3__RelinkAssetResponse(struct soap *soap, _ns3__RelinkAssetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__RelinkAssetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__RelinkAssetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__RelinkAssetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__RelinkAssetResponse * SOAP_FMAC4 soap_in__ns3__RelinkAssetResponse(struct soap *soap, const char *tag, _ns3__RelinkAssetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__RelinkAssetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__RelinkAssetResponse, sizeof(_ns3__RelinkAssetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__RelinkAssetResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__RelinkAssetResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__RelinkAssetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__RelinkAssetResponse, 0, sizeof(_ns3__RelinkAssetResponse), 0, soap_copy__ns3__RelinkAssetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__RelinkAssetResponse * SOAP_FMAC4 soap_instantiate__ns3__RelinkAssetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__RelinkAssetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__RelinkAssetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__RelinkAssetResponse;
		if (size)
			*size = sizeof(_ns3__RelinkAssetResponse);
		((_ns3__RelinkAssetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__RelinkAssetResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__RelinkAssetResponse);
		for (int i = 0; i < n; i++)
			((_ns3__RelinkAssetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__RelinkAssetResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__RelinkAssetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__RelinkAssetResponse %p -> %p\n", q, p));
	*(_ns3__RelinkAssetResponse*)p = *(_ns3__RelinkAssetResponse*)q;
}

void _ns3__RelinkAsset::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__RelinkAsset::documentid = NULL;
	this->_ns3__RelinkAsset::assetid = NULL;
	/* transient soap skipped */
}

void _ns3__RelinkAsset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__RelinkAsset::documentid);
	soap_serialize_ns4__guid(soap, &this->_ns3__RelinkAsset::assetid);
	/* transient soap skipped */
}

int _ns3__RelinkAsset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__RelinkAsset);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__RelinkAsset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__RelinkAsset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__RelinkAsset(struct soap *soap, const char *tag, int id, const _ns3__RelinkAsset *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__RelinkAsset), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:documentid", -1, &(a->_ns3__RelinkAsset::documentid), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:assetid", -1, &(a->_ns3__RelinkAsset::assetid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__RelinkAsset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__RelinkAsset(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__RelinkAsset * SOAP_FMAC4 soap_get__ns3__RelinkAsset(struct soap *soap, _ns3__RelinkAsset *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__RelinkAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__RelinkAsset::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__RelinkAsset(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__RelinkAsset * SOAP_FMAC4 soap_in__ns3__RelinkAsset(struct soap *soap, const char *tag, _ns3__RelinkAsset *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__RelinkAsset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__RelinkAsset, sizeof(_ns3__RelinkAsset), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__RelinkAsset)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__RelinkAsset *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_documentid1 = 1;
	size_t soap_flag_assetid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:documentid", &(a->_ns3__RelinkAsset::documentid), "ns4:guid"))
				{	soap_flag_documentid1--;
					continue;
				}
			if (soap_flag_assetid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:assetid", &(a->_ns3__RelinkAsset::assetid), "ns4:guid"))
				{	soap_flag_assetid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__RelinkAsset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__RelinkAsset, 0, sizeof(_ns3__RelinkAsset), 0, soap_copy__ns3__RelinkAsset);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_documentid1 > 0 || soap_flag_assetid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__RelinkAsset * SOAP_FMAC4 soap_instantiate__ns3__RelinkAsset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__RelinkAsset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__RelinkAsset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__RelinkAsset;
		if (size)
			*size = sizeof(_ns3__RelinkAsset);
		((_ns3__RelinkAsset*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__RelinkAsset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__RelinkAsset);
		for (int i = 0; i < n; i++)
			((_ns3__RelinkAsset*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__RelinkAsset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__RelinkAsset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__RelinkAsset %p -> %p\n", q, p));
	*(_ns3__RelinkAsset*)p = *(_ns3__RelinkAsset*)q;
}

void _ns3__UnlinkAssetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__UnlinkAssetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns3__UnlinkAssetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__UnlinkAssetResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__UnlinkAssetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__UnlinkAssetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UnlinkAssetResponse(struct soap *soap, const char *tag, int id, const _ns3__UnlinkAssetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UnlinkAssetResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__UnlinkAssetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__UnlinkAssetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__UnlinkAssetResponse * SOAP_FMAC4 soap_get__ns3__UnlinkAssetResponse(struct soap *soap, _ns3__UnlinkAssetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UnlinkAssetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__UnlinkAssetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__UnlinkAssetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__UnlinkAssetResponse * SOAP_FMAC4 soap_in__ns3__UnlinkAssetResponse(struct soap *soap, const char *tag, _ns3__UnlinkAssetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__UnlinkAssetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UnlinkAssetResponse, sizeof(_ns3__UnlinkAssetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__UnlinkAssetResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__UnlinkAssetResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__UnlinkAssetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UnlinkAssetResponse, 0, sizeof(_ns3__UnlinkAssetResponse), 0, soap_copy__ns3__UnlinkAssetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__UnlinkAssetResponse * SOAP_FMAC4 soap_instantiate__ns3__UnlinkAssetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__UnlinkAssetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__UnlinkAssetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__UnlinkAssetResponse;
		if (size)
			*size = sizeof(_ns3__UnlinkAssetResponse);
		((_ns3__UnlinkAssetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__UnlinkAssetResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__UnlinkAssetResponse);
		for (int i = 0; i < n; i++)
			((_ns3__UnlinkAssetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__UnlinkAssetResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__UnlinkAssetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__UnlinkAssetResponse %p -> %p\n", q, p));
	*(_ns3__UnlinkAssetResponse*)p = *(_ns3__UnlinkAssetResponse*)q;
}

void _ns3__UnlinkAsset::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__UnlinkAsset::assetid = NULL;
	/* transient soap skipped */
}

void _ns3__UnlinkAsset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__UnlinkAsset::assetid);
	/* transient soap skipped */
}

int _ns3__UnlinkAsset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__UnlinkAsset);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__UnlinkAsset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__UnlinkAsset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UnlinkAsset(struct soap *soap, const char *tag, int id, const _ns3__UnlinkAsset *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UnlinkAsset), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:assetid", -1, &(a->_ns3__UnlinkAsset::assetid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__UnlinkAsset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__UnlinkAsset(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__UnlinkAsset * SOAP_FMAC4 soap_get__ns3__UnlinkAsset(struct soap *soap, _ns3__UnlinkAsset *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UnlinkAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__UnlinkAsset::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__UnlinkAsset(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__UnlinkAsset * SOAP_FMAC4 soap_in__ns3__UnlinkAsset(struct soap *soap, const char *tag, _ns3__UnlinkAsset *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__UnlinkAsset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UnlinkAsset, sizeof(_ns3__UnlinkAsset), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__UnlinkAsset)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__UnlinkAsset *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_assetid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assetid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:assetid", &(a->_ns3__UnlinkAsset::assetid), "ns4:guid"))
				{	soap_flag_assetid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__UnlinkAsset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UnlinkAsset, 0, sizeof(_ns3__UnlinkAsset), 0, soap_copy__ns3__UnlinkAsset);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_assetid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__UnlinkAsset * SOAP_FMAC4 soap_instantiate__ns3__UnlinkAsset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__UnlinkAsset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__UnlinkAsset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__UnlinkAsset;
		if (size)
			*size = sizeof(_ns3__UnlinkAsset);
		((_ns3__UnlinkAsset*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__UnlinkAsset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__UnlinkAsset);
		for (int i = 0; i < n; i++)
			((_ns3__UnlinkAsset*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__UnlinkAsset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__UnlinkAsset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__UnlinkAsset %p -> %p\n", q, p));
	*(_ns3__UnlinkAsset*)p = *(_ns3__UnlinkAsset*)q;
}

void _ns3__UploadExportResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__UploadExportResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns3__UploadExportResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__UploadExportResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__UploadExportResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__UploadExportResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UploadExportResponse(struct soap *soap, const char *tag, int id, const _ns3__UploadExportResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UploadExportResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__UploadExportResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__UploadExportResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__UploadExportResponse * SOAP_FMAC4 soap_get__ns3__UploadExportResponse(struct soap *soap, _ns3__UploadExportResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UploadExportResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__UploadExportResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__UploadExportResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__UploadExportResponse * SOAP_FMAC4 soap_in__ns3__UploadExportResponse(struct soap *soap, const char *tag, _ns3__UploadExportResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__UploadExportResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UploadExportResponse, sizeof(_ns3__UploadExportResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__UploadExportResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__UploadExportResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__UploadExportResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UploadExportResponse, 0, sizeof(_ns3__UploadExportResponse), 0, soap_copy__ns3__UploadExportResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__UploadExportResponse * SOAP_FMAC4 soap_instantiate__ns3__UploadExportResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__UploadExportResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__UploadExportResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__UploadExportResponse;
		if (size)
			*size = sizeof(_ns3__UploadExportResponse);
		((_ns3__UploadExportResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__UploadExportResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__UploadExportResponse);
		for (int i = 0; i < n; i++)
			((_ns3__UploadExportResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__UploadExportResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__UploadExportResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__UploadExportResponse %p -> %p\n", q, p));
	*(_ns3__UploadExportResponse*)p = *(_ns3__UploadExportResponse*)q;
}

void _ns3__UploadExport::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__UploadExport::assetid = NULL;
	this->_ns3__UploadExport::versionid = NULL;
	soap_default_bool(soap, &this->_ns3__UploadExport::isXML);
	this->_ns3__UploadExport::imageFileName = NULL;
	soap_default_bool(soap, &this->_ns3__UploadExport::isHighRes);
	soap_default_bool(soap, &this->_ns3__UploadExport::isCompressed);
	this->_ns3__UploadExport::data = NULL;
	/* transient soap skipped */
}

void _ns3__UploadExport::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__UploadExport::assetid);
	soap_serialize_ns4__guid(soap, &this->_ns3__UploadExport::versionid);
	soap_serialize_wstring(soap, &this->_ns3__UploadExport::imageFileName);
	soap_serialize_PointerToxsd__base64Binary(soap, &this->_ns3__UploadExport::data);
	/* transient soap skipped */
}

int _ns3__UploadExport::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__UploadExport);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__UploadExport::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__UploadExport(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UploadExport(struct soap *soap, const char *tag, int id, const _ns3__UploadExport *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UploadExport), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:assetid", -1, &(a->_ns3__UploadExport::assetid), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:versionid", -1, &(a->_ns3__UploadExport::versionid), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns3:isXML", -1, &(a->_ns3__UploadExport::isXML), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:imageFileName", -1, &(a->_ns3__UploadExport::imageFileName), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns3:isHighRes", -1, &(a->_ns3__UploadExport::isHighRes), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns3:isCompressed", -1, &(a->_ns3__UploadExport::isCompressed), ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "ns3:data", -1, &(a->_ns3__UploadExport::data), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__UploadExport::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__UploadExport(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__UploadExport * SOAP_FMAC4 soap_get__ns3__UploadExport(struct soap *soap, _ns3__UploadExport *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UploadExport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__UploadExport::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__UploadExport(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__UploadExport * SOAP_FMAC4 soap_in__ns3__UploadExport(struct soap *soap, const char *tag, _ns3__UploadExport *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__UploadExport *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UploadExport, sizeof(_ns3__UploadExport), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__UploadExport)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__UploadExport *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_assetid1 = 1;
	size_t soap_flag_versionid1 = 1;
	size_t soap_flag_isXML1 = 1;
	size_t soap_flag_imageFileName1 = 1;
	size_t soap_flag_isHighRes1 = 1;
	size_t soap_flag_isCompressed1 = 1;
	size_t soap_flag_data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assetid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:assetid", &(a->_ns3__UploadExport::assetid), "ns4:guid"))
				{	soap_flag_assetid1--;
					continue;
				}
			if (soap_flag_versionid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:versionid", &(a->_ns3__UploadExport::versionid), "ns4:guid"))
				{	soap_flag_versionid1--;
					continue;
				}
			if (soap_flag_isXML1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns3:isXML", &(a->_ns3__UploadExport::isXML), "xsd:boolean"))
				{	soap_flag_isXML1--;
					continue;
				}
			if (soap_flag_imageFileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:imageFileName", &(a->_ns3__UploadExport::imageFileName), "xsd:string"))
				{	soap_flag_imageFileName1--;
					continue;
				}
			if (soap_flag_isHighRes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns3:isHighRes", &(a->_ns3__UploadExport::isHighRes), "xsd:boolean"))
				{	soap_flag_isHighRes1--;
					continue;
				}
			if (soap_flag_isCompressed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns3:isCompressed", &(a->_ns3__UploadExport::isCompressed), "xsd:boolean"))
				{	soap_flag_isCompressed1--;
					continue;
				}
			if (soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "ns3:data", &(a->_ns3__UploadExport::data), "xsd:base64Binary"))
				{	soap_flag_data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__UploadExport *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UploadExport, 0, sizeof(_ns3__UploadExport), 0, soap_copy__ns3__UploadExport);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_assetid1 > 0 || soap_flag_versionid1 > 0 || soap_flag_isXML1 > 0 || soap_flag_isHighRes1 > 0 || soap_flag_isCompressed1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__UploadExport * SOAP_FMAC4 soap_instantiate__ns3__UploadExport(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__UploadExport(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__UploadExport, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__UploadExport;
		if (size)
			*size = sizeof(_ns3__UploadExport);
		((_ns3__UploadExport*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__UploadExport[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__UploadExport);
		for (int i = 0; i < n; i++)
			((_ns3__UploadExport*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__UploadExport*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__UploadExport(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__UploadExport %p -> %p\n", q, p));
	*(_ns3__UploadExport*)p = *(_ns3__UploadExport*)q;
}

void _ns3__UploadVersionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__UploadVersionResponse::UploadVersionResult = NULL;
	/* transient soap skipped */
}

void _ns3__UploadVersionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__UploadVersionResponse::UploadVersionResult);
	/* transient soap skipped */
}

int _ns3__UploadVersionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__UploadVersionResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__UploadVersionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__UploadVersionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UploadVersionResponse(struct soap *soap, const char *tag, int id, const _ns3__UploadVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UploadVersionResponse), type))
		return soap->error;
	if (a->UploadVersionResult)
		soap_element_result(soap, "ns3:UploadVersionResult");
	if (soap_out_ns4__guid(soap, "ns3:UploadVersionResult", -1, &(a->_ns3__UploadVersionResponse::UploadVersionResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__UploadVersionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__UploadVersionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__UploadVersionResponse * SOAP_FMAC4 soap_get__ns3__UploadVersionResponse(struct soap *soap, _ns3__UploadVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UploadVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__UploadVersionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__UploadVersionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__UploadVersionResponse * SOAP_FMAC4 soap_in__ns3__UploadVersionResponse(struct soap *soap, const char *tag, _ns3__UploadVersionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__UploadVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UploadVersionResponse, sizeof(_ns3__UploadVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__UploadVersionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__UploadVersionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UploadVersionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadVersionResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:UploadVersionResult", &(a->_ns3__UploadVersionResponse::UploadVersionResult), "ns4:guid"))
				{	soap_flag_UploadVersionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:UploadVersionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__UploadVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UploadVersionResponse, 0, sizeof(_ns3__UploadVersionResponse), 0, soap_copy__ns3__UploadVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_UploadVersionResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__UploadVersionResponse * SOAP_FMAC4 soap_instantiate__ns3__UploadVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__UploadVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__UploadVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__UploadVersionResponse;
		if (size)
			*size = sizeof(_ns3__UploadVersionResponse);
		((_ns3__UploadVersionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__UploadVersionResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__UploadVersionResponse);
		for (int i = 0; i < n; i++)
			((_ns3__UploadVersionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__UploadVersionResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__UploadVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__UploadVersionResponse %p -> %p\n", q, p));
	*(_ns3__UploadVersionResponse*)p = *(_ns3__UploadVersionResponse*)q;
}

void _ns3__UploadVersion::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__UploadVersion::assetid = NULL;
	this->_ns3__UploadVersion::versionDto = NULL;
	/* transient soap skipped */
}

void _ns3__UploadVersion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__UploadVersion::assetid);
	soap_serialize_PointerTons3__VersionDTO(soap, &this->_ns3__UploadVersion::versionDto);
	/* transient soap skipped */
}

int _ns3__UploadVersion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__UploadVersion);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__UploadVersion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__UploadVersion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UploadVersion(struct soap *soap, const char *tag, int id, const _ns3__UploadVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UploadVersion), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:assetid", -1, &(a->_ns3__UploadVersion::assetid), ""))
		return soap->error;
	if (soap_out_PointerTons3__VersionDTO(soap, "ns3:versionDto", -1, &(a->_ns3__UploadVersion::versionDto), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__UploadVersion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__UploadVersion(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__UploadVersion * SOAP_FMAC4 soap_get__ns3__UploadVersion(struct soap *soap, _ns3__UploadVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UploadVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__UploadVersion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__UploadVersion(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__UploadVersion * SOAP_FMAC4 soap_in__ns3__UploadVersion(struct soap *soap, const char *tag, _ns3__UploadVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__UploadVersion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UploadVersion, sizeof(_ns3__UploadVersion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__UploadVersion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__UploadVersion *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_assetid1 = 1;
	size_t soap_flag_versionDto1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assetid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:assetid", &(a->_ns3__UploadVersion::assetid), "ns4:guid"))
				{	soap_flag_assetid1--;
					continue;
				}
			if (soap_flag_versionDto1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__VersionDTO(soap, "ns3:versionDto", &(a->_ns3__UploadVersion::versionDto), "ns3:VersionDTO"))
				{	soap_flag_versionDto1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__UploadVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UploadVersion, 0, sizeof(_ns3__UploadVersion), 0, soap_copy__ns3__UploadVersion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_assetid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__UploadVersion * SOAP_FMAC4 soap_instantiate__ns3__UploadVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__UploadVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__UploadVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__UploadVersion;
		if (size)
			*size = sizeof(_ns3__UploadVersion);
		((_ns3__UploadVersion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__UploadVersion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__UploadVersion);
		for (int i = 0; i < n; i++)
			((_ns3__UploadVersion*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__UploadVersion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__UploadVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__UploadVersion %p -> %p\n", q, p));
	*(_ns3__UploadVersion*)p = *(_ns3__UploadVersion*)q;
}

void _ns3__UploadPageResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__UploadPageResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns3__UploadPageResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__UploadPageResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__UploadPageResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__UploadPageResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UploadPageResponse(struct soap *soap, const char *tag, int id, const _ns3__UploadPageResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UploadPageResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__UploadPageResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__UploadPageResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__UploadPageResponse * SOAP_FMAC4 soap_get__ns3__UploadPageResponse(struct soap *soap, _ns3__UploadPageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UploadPageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__UploadPageResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__UploadPageResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__UploadPageResponse * SOAP_FMAC4 soap_in__ns3__UploadPageResponse(struct soap *soap, const char *tag, _ns3__UploadPageResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__UploadPageResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UploadPageResponse, sizeof(_ns3__UploadPageResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__UploadPageResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__UploadPageResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__UploadPageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UploadPageResponse, 0, sizeof(_ns3__UploadPageResponse), 0, soap_copy__ns3__UploadPageResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__UploadPageResponse * SOAP_FMAC4 soap_instantiate__ns3__UploadPageResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__UploadPageResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__UploadPageResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__UploadPageResponse;
		if (size)
			*size = sizeof(_ns3__UploadPageResponse);
		((_ns3__UploadPageResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__UploadPageResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__UploadPageResponse);
		for (int i = 0; i < n; i++)
			((_ns3__UploadPageResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__UploadPageResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__UploadPageResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__UploadPageResponse %p -> %p\n", q, p));
	*(_ns3__UploadPageResponse*)p = *(_ns3__UploadPageResponse*)q;
}

void _ns3__UploadPage::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__UploadPage::pageid = NULL;
	this->_ns3__UploadPage::versionid = NULL;
	soap_default_int(soap, &this->_ns3__UploadPage::number);
	this->_ns3__UploadPage::pagetypeid = NULL;
	this->_ns3__UploadPage::data = NULL;
	soap_default_bool(soap, &this->_ns3__UploadPage::isCompressed);
	/* transient soap skipped */
}

void _ns3__UploadPage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__UploadPage::pageid);
	soap_serialize_ns4__guid(soap, &this->_ns3__UploadPage::versionid);
	soap_embedded(soap, &this->_ns3__UploadPage::number, SOAP_TYPE_int);
	soap_serialize_ns4__guid(soap, &this->_ns3__UploadPage::pagetypeid);
	soap_serialize_PointerToxsd__base64Binary(soap, &this->_ns3__UploadPage::data);
	/* transient soap skipped */
}

int _ns3__UploadPage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__UploadPage);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__UploadPage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__UploadPage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UploadPage(struct soap *soap, const char *tag, int id, const _ns3__UploadPage *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UploadPage), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:pageid", -1, &(a->_ns3__UploadPage::pageid), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:versionid", -1, &(a->_ns3__UploadPage::versionid), ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:number", -1, &(a->_ns3__UploadPage::number), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:pagetypeid", -1, &(a->_ns3__UploadPage::pagetypeid), ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "ns3:data", -1, &(a->_ns3__UploadPage::data), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns3:isCompressed", -1, &(a->_ns3__UploadPage::isCompressed), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__UploadPage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__UploadPage(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__UploadPage * SOAP_FMAC4 soap_get__ns3__UploadPage(struct soap *soap, _ns3__UploadPage *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UploadPage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__UploadPage::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__UploadPage(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__UploadPage * SOAP_FMAC4 soap_in__ns3__UploadPage(struct soap *soap, const char *tag, _ns3__UploadPage *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__UploadPage *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UploadPage, sizeof(_ns3__UploadPage), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__UploadPage)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__UploadPage *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_pageid1 = 1;
	size_t soap_flag_versionid1 = 1;
	size_t soap_flag_number1 = 1;
	size_t soap_flag_pagetypeid1 = 1;
	size_t soap_flag_data1 = 1;
	size_t soap_flag_isCompressed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pageid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:pageid", &(a->_ns3__UploadPage::pageid), "ns4:guid"))
				{	soap_flag_pageid1--;
					continue;
				}
			if (soap_flag_versionid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:versionid", &(a->_ns3__UploadPage::versionid), "ns4:guid"))
				{	soap_flag_versionid1--;
					continue;
				}
			if (soap_flag_number1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns3:number", &(a->_ns3__UploadPage::number), "xsd:int"))
				{	soap_flag_number1--;
					continue;
				}
			if (soap_flag_pagetypeid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:pagetypeid", &(a->_ns3__UploadPage::pagetypeid), "ns4:guid"))
				{	soap_flag_pagetypeid1--;
					continue;
				}
			if (soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "ns3:data", &(a->_ns3__UploadPage::data), "xsd:base64Binary"))
				{	soap_flag_data1--;
					continue;
				}
			if (soap_flag_isCompressed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns3:isCompressed", &(a->_ns3__UploadPage::isCompressed), "xsd:boolean"))
				{	soap_flag_isCompressed1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__UploadPage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UploadPage, 0, sizeof(_ns3__UploadPage), 0, soap_copy__ns3__UploadPage);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_pageid1 > 0 || soap_flag_versionid1 > 0 || soap_flag_number1 > 0 || soap_flag_pagetypeid1 > 0 || soap_flag_isCompressed1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__UploadPage * SOAP_FMAC4 soap_instantiate__ns3__UploadPage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__UploadPage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__UploadPage, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__UploadPage;
		if (size)
			*size = sizeof(_ns3__UploadPage);
		((_ns3__UploadPage*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__UploadPage[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__UploadPage);
		for (int i = 0; i < n; i++)
			((_ns3__UploadPage*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__UploadPage*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__UploadPage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__UploadPage %p -> %p\n", q, p));
	*(_ns3__UploadPage*)p = *(_ns3__UploadPage*)q;
}

void _ns3__UploadPDFResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__UploadPDFResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns3__UploadPDFResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__UploadPDFResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__UploadPDFResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__UploadPDFResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UploadPDFResponse(struct soap *soap, const char *tag, int id, const _ns3__UploadPDFResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UploadPDFResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__UploadPDFResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__UploadPDFResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__UploadPDFResponse * SOAP_FMAC4 soap_get__ns3__UploadPDFResponse(struct soap *soap, _ns3__UploadPDFResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UploadPDFResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__UploadPDFResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__UploadPDFResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__UploadPDFResponse * SOAP_FMAC4 soap_in__ns3__UploadPDFResponse(struct soap *soap, const char *tag, _ns3__UploadPDFResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__UploadPDFResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UploadPDFResponse, sizeof(_ns3__UploadPDFResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__UploadPDFResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__UploadPDFResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__UploadPDFResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UploadPDFResponse, 0, sizeof(_ns3__UploadPDFResponse), 0, soap_copy__ns3__UploadPDFResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__UploadPDFResponse * SOAP_FMAC4 soap_instantiate__ns3__UploadPDFResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__UploadPDFResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__UploadPDFResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__UploadPDFResponse;
		if (size)
			*size = sizeof(_ns3__UploadPDFResponse);
		((_ns3__UploadPDFResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__UploadPDFResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__UploadPDFResponse);
		for (int i = 0; i < n; i++)
			((_ns3__UploadPDFResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__UploadPDFResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__UploadPDFResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__UploadPDFResponse %p -> %p\n", q, p));
	*(_ns3__UploadPDFResponse*)p = *(_ns3__UploadPDFResponse*)q;
}

void _ns3__UploadPDF::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__UploadPDF::assetid = NULL;
	this->_ns3__UploadPDF::versionid = NULL;
	this->_ns3__UploadPDF::data = NULL;
	/* transient soap skipped */
}

void _ns3__UploadPDF::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__UploadPDF::assetid);
	soap_serialize_ns4__guid(soap, &this->_ns3__UploadPDF::versionid);
	soap_serialize_PointerToxsd__base64Binary(soap, &this->_ns3__UploadPDF::data);
	/* transient soap skipped */
}

int _ns3__UploadPDF::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__UploadPDF);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__UploadPDF::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__UploadPDF(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UploadPDF(struct soap *soap, const char *tag, int id, const _ns3__UploadPDF *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UploadPDF), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:assetid", -1, &(a->_ns3__UploadPDF::assetid), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:versionid", -1, &(a->_ns3__UploadPDF::versionid), ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "ns3:data", -1, &(a->_ns3__UploadPDF::data), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__UploadPDF::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__UploadPDF(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__UploadPDF * SOAP_FMAC4 soap_get__ns3__UploadPDF(struct soap *soap, _ns3__UploadPDF *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UploadPDF(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__UploadPDF::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__UploadPDF(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__UploadPDF * SOAP_FMAC4 soap_in__ns3__UploadPDF(struct soap *soap, const char *tag, _ns3__UploadPDF *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__UploadPDF *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UploadPDF, sizeof(_ns3__UploadPDF), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__UploadPDF)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__UploadPDF *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_assetid1 = 1;
	size_t soap_flag_versionid1 = 1;
	size_t soap_flag_data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assetid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:assetid", &(a->_ns3__UploadPDF::assetid), "ns4:guid"))
				{	soap_flag_assetid1--;
					continue;
				}
			if (soap_flag_versionid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:versionid", &(a->_ns3__UploadPDF::versionid), "ns4:guid"))
				{	soap_flag_versionid1--;
					continue;
				}
			if (soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "ns3:data", &(a->_ns3__UploadPDF::data), "xsd:base64Binary"))
				{	soap_flag_data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__UploadPDF *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UploadPDF, 0, sizeof(_ns3__UploadPDF), 0, soap_copy__ns3__UploadPDF);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_assetid1 > 0 || soap_flag_versionid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__UploadPDF * SOAP_FMAC4 soap_instantiate__ns3__UploadPDF(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__UploadPDF(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__UploadPDF, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__UploadPDF;
		if (size)
			*size = sizeof(_ns3__UploadPDF);
		((_ns3__UploadPDF*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__UploadPDF[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__UploadPDF);
		for (int i = 0; i < n; i++)
			((_ns3__UploadPDF*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__UploadPDF*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__UploadPDF(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__UploadPDF %p -> %p\n", q, p));
	*(_ns3__UploadPDF*)p = *(_ns3__UploadPDF*)q;
}

void _ns3__GetAssetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetAssetResponse::GetAssetResult = NULL;
	/* transient soap skipped */
}

void _ns3__GetAssetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__ArrayOfAssetDTO(soap, &this->_ns3__GetAssetResponse::GetAssetResult);
	/* transient soap skipped */
}

int _ns3__GetAssetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetAssetResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetAssetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetAssetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetAssetResponse(struct soap *soap, const char *tag, int id, const _ns3__GetAssetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetAssetResponse), type))
		return soap->error;
	if (a->GetAssetResult)
		soap_element_result(soap, "ns3:GetAssetResult");
	if (soap_out_PointerTons3__ArrayOfAssetDTO(soap, "ns3:GetAssetResult", -1, &(a->_ns3__GetAssetResponse::GetAssetResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetAssetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetAssetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetAssetResponse * SOAP_FMAC4 soap_get__ns3__GetAssetResponse(struct soap *soap, _ns3__GetAssetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetAssetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetAssetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetAssetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetAssetResponse * SOAP_FMAC4 soap_in__ns3__GetAssetResponse(struct soap *soap, const char *tag, _ns3__GetAssetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetAssetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetAssetResponse, sizeof(_ns3__GetAssetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetAssetResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetAssetResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetAssetResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAssetResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfAssetDTO(soap, "ns3:GetAssetResult", &(a->_ns3__GetAssetResponse::GetAssetResult), "ns3:ArrayOfAssetDTO"))
				{	soap_flag_GetAssetResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:GetAssetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetAssetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetAssetResponse, 0, sizeof(_ns3__GetAssetResponse), 0, soap_copy__ns3__GetAssetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetAssetResponse * SOAP_FMAC4 soap_instantiate__ns3__GetAssetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetAssetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetAssetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetAssetResponse;
		if (size)
			*size = sizeof(_ns3__GetAssetResponse);
		((_ns3__GetAssetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetAssetResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetAssetResponse);
		for (int i = 0; i < n; i++)
			((_ns3__GetAssetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetAssetResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetAssetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetAssetResponse %p -> %p\n", q, p));
	*(_ns3__GetAssetResponse*)p = *(_ns3__GetAssetResponse*)q;
}

void _ns3__GetAsset::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetAsset::assetid = NULL;
	/* transient soap skipped */
}

void _ns3__GetAsset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__ArrayOfGuid(soap, &this->_ns3__GetAsset::assetid);
	/* transient soap skipped */
}

int _ns3__GetAsset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetAsset);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetAsset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetAsset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetAsset(struct soap *soap, const char *tag, int id, const _ns3__GetAsset *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetAsset), type))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfGuid(soap, "ns3:assetid", -1, &(a->_ns3__GetAsset::assetid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetAsset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetAsset(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetAsset * SOAP_FMAC4 soap_get__ns3__GetAsset(struct soap *soap, _ns3__GetAsset *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetAsset::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetAsset(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetAsset * SOAP_FMAC4 soap_in__ns3__GetAsset(struct soap *soap, const char *tag, _ns3__GetAsset *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetAsset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetAsset, sizeof(_ns3__GetAsset), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetAsset)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetAsset *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_assetid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assetid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfGuid(soap, "ns3:assetid", &(a->_ns3__GetAsset::assetid), "ns3:ArrayOfGuid"))
				{	soap_flag_assetid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetAsset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetAsset, 0, sizeof(_ns3__GetAsset), 0, soap_copy__ns3__GetAsset);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetAsset * SOAP_FMAC4 soap_instantiate__ns3__GetAsset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetAsset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetAsset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetAsset;
		if (size)
			*size = sizeof(_ns3__GetAsset);
		((_ns3__GetAsset*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetAsset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetAsset);
		for (int i = 0; i < n; i++)
			((_ns3__GetAsset*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetAsset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetAsset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetAsset %p -> %p\n", q, p));
	*(_ns3__GetAsset*)p = *(_ns3__GetAsset*)q;
}

void _ns3__CanUpdateAssetNameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns3__CanUpdateAssetNameResponse::CanUpdateAssetNameResult);
	/* transient soap skipped */
}

void _ns3__CanUpdateAssetNameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns3__CanUpdateAssetNameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__CanUpdateAssetNameResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__CanUpdateAssetNameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__CanUpdateAssetNameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__CanUpdateAssetNameResponse(struct soap *soap, const char *tag, int id, const _ns3__CanUpdateAssetNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__CanUpdateAssetNameResponse), type))
		return soap->error;
	soap_element_result(soap, "ns3:CanUpdateAssetNameResult");
	if (soap_out_bool(soap, "ns3:CanUpdateAssetNameResult", -1, &(a->_ns3__CanUpdateAssetNameResponse::CanUpdateAssetNameResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__CanUpdateAssetNameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__CanUpdateAssetNameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__CanUpdateAssetNameResponse * SOAP_FMAC4 soap_get__ns3__CanUpdateAssetNameResponse(struct soap *soap, _ns3__CanUpdateAssetNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__CanUpdateAssetNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__CanUpdateAssetNameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__CanUpdateAssetNameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__CanUpdateAssetNameResponse * SOAP_FMAC4 soap_in__ns3__CanUpdateAssetNameResponse(struct soap *soap, const char *tag, _ns3__CanUpdateAssetNameResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__CanUpdateAssetNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__CanUpdateAssetNameResponse, sizeof(_ns3__CanUpdateAssetNameResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__CanUpdateAssetNameResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__CanUpdateAssetNameResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CanUpdateAssetNameResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CanUpdateAssetNameResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns3:CanUpdateAssetNameResult", &(a->_ns3__CanUpdateAssetNameResponse::CanUpdateAssetNameResult), "xsd:boolean"))
				{	soap_flag_CanUpdateAssetNameResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:CanUpdateAssetNameResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__CanUpdateAssetNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__CanUpdateAssetNameResponse, 0, sizeof(_ns3__CanUpdateAssetNameResponse), 0, soap_copy__ns3__CanUpdateAssetNameResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_CanUpdateAssetNameResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__CanUpdateAssetNameResponse * SOAP_FMAC4 soap_instantiate__ns3__CanUpdateAssetNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__CanUpdateAssetNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__CanUpdateAssetNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__CanUpdateAssetNameResponse;
		if (size)
			*size = sizeof(_ns3__CanUpdateAssetNameResponse);
		((_ns3__CanUpdateAssetNameResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__CanUpdateAssetNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__CanUpdateAssetNameResponse);
		for (int i = 0; i < n; i++)
			((_ns3__CanUpdateAssetNameResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__CanUpdateAssetNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__CanUpdateAssetNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__CanUpdateAssetNameResponse %p -> %p\n", q, p));
	*(_ns3__CanUpdateAssetNameResponse*)p = *(_ns3__CanUpdateAssetNameResponse*)q;
}

void _ns3__CanUpdateAssetName::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__CanUpdateAssetName::assetId = NULL;
	this->_ns3__CanUpdateAssetName::editionId = NULL;
	this->_ns3__CanUpdateAssetName::typeId = NULL;
	this->_ns3__CanUpdateAssetName::parentId = NULL;
	this->_ns3__CanUpdateAssetName::name = NULL;
	/* transient soap skipped */
}

void _ns3__CanUpdateAssetName::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__CanUpdateAssetName::assetId);
	soap_serialize_ns4__guid(soap, &this->_ns3__CanUpdateAssetName::editionId);
	soap_serialize_ns4__guid(soap, &this->_ns3__CanUpdateAssetName::typeId);
	soap_serialize_ns4__guid(soap, &this->_ns3__CanUpdateAssetName::parentId);
	soap_serialize_wstring(soap, &this->_ns3__CanUpdateAssetName::name);
	/* transient soap skipped */
}

int _ns3__CanUpdateAssetName::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__CanUpdateAssetName);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__CanUpdateAssetName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__CanUpdateAssetName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__CanUpdateAssetName(struct soap *soap, const char *tag, int id, const _ns3__CanUpdateAssetName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__CanUpdateAssetName), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:assetId", -1, &(a->_ns3__CanUpdateAssetName::assetId), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:editionId", -1, &(a->_ns3__CanUpdateAssetName::editionId), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:typeId", -1, &(a->_ns3__CanUpdateAssetName::typeId), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:parentId", -1, &(a->_ns3__CanUpdateAssetName::parentId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:name", -1, &(a->_ns3__CanUpdateAssetName::name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__CanUpdateAssetName::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__CanUpdateAssetName(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__CanUpdateAssetName * SOAP_FMAC4 soap_get__ns3__CanUpdateAssetName(struct soap *soap, _ns3__CanUpdateAssetName *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__CanUpdateAssetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__CanUpdateAssetName::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__CanUpdateAssetName(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__CanUpdateAssetName * SOAP_FMAC4 soap_in__ns3__CanUpdateAssetName(struct soap *soap, const char *tag, _ns3__CanUpdateAssetName *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__CanUpdateAssetName *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__CanUpdateAssetName, sizeof(_ns3__CanUpdateAssetName), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__CanUpdateAssetName)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__CanUpdateAssetName *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_assetId1 = 1;
	size_t soap_flag_editionId1 = 1;
	size_t soap_flag_typeId1 = 1;
	size_t soap_flag_parentId1 = 1;
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assetId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:assetId", &(a->_ns3__CanUpdateAssetName::assetId), "ns4:guid"))
				{	soap_flag_assetId1--;
					continue;
				}
			if (soap_flag_editionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:editionId", &(a->_ns3__CanUpdateAssetName::editionId), "ns4:guid"))
				{	soap_flag_editionId1--;
					continue;
				}
			if (soap_flag_typeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:typeId", &(a->_ns3__CanUpdateAssetName::typeId), "ns4:guid"))
				{	soap_flag_typeId1--;
					continue;
				}
			if (soap_flag_parentId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:parentId", &(a->_ns3__CanUpdateAssetName::parentId), "ns4:guid"))
				{	soap_flag_parentId1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:name", &(a->_ns3__CanUpdateAssetName::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__CanUpdateAssetName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__CanUpdateAssetName, 0, sizeof(_ns3__CanUpdateAssetName), 0, soap_copy__ns3__CanUpdateAssetName);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_assetId1 > 0 || soap_flag_editionId1 > 0 || soap_flag_typeId1 > 0 || soap_flag_parentId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__CanUpdateAssetName * SOAP_FMAC4 soap_instantiate__ns3__CanUpdateAssetName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__CanUpdateAssetName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__CanUpdateAssetName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__CanUpdateAssetName;
		if (size)
			*size = sizeof(_ns3__CanUpdateAssetName);
		((_ns3__CanUpdateAssetName*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__CanUpdateAssetName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__CanUpdateAssetName);
		for (int i = 0; i < n; i++)
			((_ns3__CanUpdateAssetName*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__CanUpdateAssetName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__CanUpdateAssetName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__CanUpdateAssetName %p -> %p\n", q, p));
	*(_ns3__CanUpdateAssetName*)p = *(_ns3__CanUpdateAssetName*)q;
}

void _ns3__UpdateAssetNameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__UpdateAssetNameResponse::UpdateAssetNameResult = NULL;
	/* transient soap skipped */
}

void _ns3__UpdateAssetNameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__AssetDTO(soap, &this->_ns3__UpdateAssetNameResponse::UpdateAssetNameResult);
	/* transient soap skipped */
}

int _ns3__UpdateAssetNameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__UpdateAssetNameResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__UpdateAssetNameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__UpdateAssetNameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UpdateAssetNameResponse(struct soap *soap, const char *tag, int id, const _ns3__UpdateAssetNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UpdateAssetNameResponse), type))
		return soap->error;
	if (a->UpdateAssetNameResult)
		soap_element_result(soap, "ns3:UpdateAssetNameResult");
	if (soap_out_PointerTons3__AssetDTO(soap, "ns3:UpdateAssetNameResult", -1, &(a->_ns3__UpdateAssetNameResponse::UpdateAssetNameResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__UpdateAssetNameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__UpdateAssetNameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__UpdateAssetNameResponse * SOAP_FMAC4 soap_get__ns3__UpdateAssetNameResponse(struct soap *soap, _ns3__UpdateAssetNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UpdateAssetNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__UpdateAssetNameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__UpdateAssetNameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__UpdateAssetNameResponse * SOAP_FMAC4 soap_in__ns3__UpdateAssetNameResponse(struct soap *soap, const char *tag, _ns3__UpdateAssetNameResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__UpdateAssetNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UpdateAssetNameResponse, sizeof(_ns3__UpdateAssetNameResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__UpdateAssetNameResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__UpdateAssetNameResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UpdateAssetNameResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdateAssetNameResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__AssetDTO(soap, "ns3:UpdateAssetNameResult", &(a->_ns3__UpdateAssetNameResponse::UpdateAssetNameResult), "ns3:AssetDTO"))
				{	soap_flag_UpdateAssetNameResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:UpdateAssetNameResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__UpdateAssetNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UpdateAssetNameResponse, 0, sizeof(_ns3__UpdateAssetNameResponse), 0, soap_copy__ns3__UpdateAssetNameResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__UpdateAssetNameResponse * SOAP_FMAC4 soap_instantiate__ns3__UpdateAssetNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__UpdateAssetNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__UpdateAssetNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__UpdateAssetNameResponse;
		if (size)
			*size = sizeof(_ns3__UpdateAssetNameResponse);
		((_ns3__UpdateAssetNameResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__UpdateAssetNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__UpdateAssetNameResponse);
		for (int i = 0; i < n; i++)
			((_ns3__UpdateAssetNameResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__UpdateAssetNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__UpdateAssetNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__UpdateAssetNameResponse %p -> %p\n", q, p));
	*(_ns3__UpdateAssetNameResponse*)p = *(_ns3__UpdateAssetNameResponse*)q;
}

void _ns3__UpdateAssetName::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__UpdateAssetName::assetid = NULL;
	this->_ns3__UpdateAssetName::name = NULL;
	/* transient soap skipped */
}

void _ns3__UpdateAssetName::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__UpdateAssetName::assetid);
	soap_serialize_wstring(soap, &this->_ns3__UpdateAssetName::name);
	/* transient soap skipped */
}

int _ns3__UpdateAssetName::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__UpdateAssetName);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__UpdateAssetName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__UpdateAssetName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UpdateAssetName(struct soap *soap, const char *tag, int id, const _ns3__UpdateAssetName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UpdateAssetName), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:assetid", -1, &(a->_ns3__UpdateAssetName::assetid), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:name", -1, &(a->_ns3__UpdateAssetName::name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__UpdateAssetName::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__UpdateAssetName(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__UpdateAssetName * SOAP_FMAC4 soap_get__ns3__UpdateAssetName(struct soap *soap, _ns3__UpdateAssetName *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UpdateAssetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__UpdateAssetName::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__UpdateAssetName(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__UpdateAssetName * SOAP_FMAC4 soap_in__ns3__UpdateAssetName(struct soap *soap, const char *tag, _ns3__UpdateAssetName *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__UpdateAssetName *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UpdateAssetName, sizeof(_ns3__UpdateAssetName), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__UpdateAssetName)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__UpdateAssetName *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_assetid1 = 1;
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assetid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:assetid", &(a->_ns3__UpdateAssetName::assetid), "ns4:guid"))
				{	soap_flag_assetid1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:name", &(a->_ns3__UpdateAssetName::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__UpdateAssetName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UpdateAssetName, 0, sizeof(_ns3__UpdateAssetName), 0, soap_copy__ns3__UpdateAssetName);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_assetid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__UpdateAssetName * SOAP_FMAC4 soap_instantiate__ns3__UpdateAssetName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__UpdateAssetName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__UpdateAssetName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__UpdateAssetName;
		if (size)
			*size = sizeof(_ns3__UpdateAssetName);
		((_ns3__UpdateAssetName*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__UpdateAssetName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__UpdateAssetName);
		for (int i = 0; i < n; i++)
			((_ns3__UpdateAssetName*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__UpdateAssetName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__UpdateAssetName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__UpdateAssetName %p -> %p\n", q, p));
	*(_ns3__UpdateAssetName*)p = *(_ns3__UpdateAssetName*)q;
}

void _ns3__CreateAssetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__CreateAssetResponse::CreateAssetResult = NULL;
	/* transient soap skipped */
}

void _ns3__CreateAssetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__AssetDTO(soap, &this->_ns3__CreateAssetResponse::CreateAssetResult);
	/* transient soap skipped */
}

int _ns3__CreateAssetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__CreateAssetResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__CreateAssetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__CreateAssetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__CreateAssetResponse(struct soap *soap, const char *tag, int id, const _ns3__CreateAssetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__CreateAssetResponse), type))
		return soap->error;
	if (a->CreateAssetResult)
		soap_element_result(soap, "ns3:CreateAssetResult");
	if (soap_out_PointerTons3__AssetDTO(soap, "ns3:CreateAssetResult", -1, &(a->_ns3__CreateAssetResponse::CreateAssetResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__CreateAssetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__CreateAssetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__CreateAssetResponse * SOAP_FMAC4 soap_get__ns3__CreateAssetResponse(struct soap *soap, _ns3__CreateAssetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__CreateAssetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__CreateAssetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__CreateAssetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__CreateAssetResponse * SOAP_FMAC4 soap_in__ns3__CreateAssetResponse(struct soap *soap, const char *tag, _ns3__CreateAssetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__CreateAssetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__CreateAssetResponse, sizeof(_ns3__CreateAssetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__CreateAssetResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__CreateAssetResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CreateAssetResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CreateAssetResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__AssetDTO(soap, "ns3:CreateAssetResult", &(a->_ns3__CreateAssetResponse::CreateAssetResult), "ns3:AssetDTO"))
				{	soap_flag_CreateAssetResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:CreateAssetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__CreateAssetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__CreateAssetResponse, 0, sizeof(_ns3__CreateAssetResponse), 0, soap_copy__ns3__CreateAssetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__CreateAssetResponse * SOAP_FMAC4 soap_instantiate__ns3__CreateAssetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__CreateAssetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__CreateAssetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__CreateAssetResponse;
		if (size)
			*size = sizeof(_ns3__CreateAssetResponse);
		((_ns3__CreateAssetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__CreateAssetResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__CreateAssetResponse);
		for (int i = 0; i < n; i++)
			((_ns3__CreateAssetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__CreateAssetResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__CreateAssetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__CreateAssetResponse %p -> %p\n", q, p));
	*(_ns3__CreateAssetResponse*)p = *(_ns3__CreateAssetResponse*)q;
}

void _ns3__CreateAsset::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__CreateAsset::assetDTO = NULL;
	/* transient soap skipped */
}

void _ns3__CreateAsset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__AssetDTO(soap, &this->_ns3__CreateAsset::assetDTO);
	/* transient soap skipped */
}

int _ns3__CreateAsset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__CreateAsset);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__CreateAsset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__CreateAsset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__CreateAsset(struct soap *soap, const char *tag, int id, const _ns3__CreateAsset *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__CreateAsset), type))
		return soap->error;
	if (soap_out_PointerTons3__AssetDTO(soap, "ns3:assetDTO", -1, &(a->_ns3__CreateAsset::assetDTO), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__CreateAsset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__CreateAsset(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__CreateAsset * SOAP_FMAC4 soap_get__ns3__CreateAsset(struct soap *soap, _ns3__CreateAsset *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__CreateAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__CreateAsset::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__CreateAsset(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__CreateAsset * SOAP_FMAC4 soap_in__ns3__CreateAsset(struct soap *soap, const char *tag, _ns3__CreateAsset *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__CreateAsset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__CreateAsset, sizeof(_ns3__CreateAsset), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__CreateAsset)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__CreateAsset *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_assetDTO1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assetDTO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__AssetDTO(soap, "ns3:assetDTO", &(a->_ns3__CreateAsset::assetDTO), "ns3:AssetDTO"))
				{	soap_flag_assetDTO1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__CreateAsset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__CreateAsset, 0, sizeof(_ns3__CreateAsset), 0, soap_copy__ns3__CreateAsset);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__CreateAsset * SOAP_FMAC4 soap_instantiate__ns3__CreateAsset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__CreateAsset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__CreateAsset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__CreateAsset;
		if (size)
			*size = sizeof(_ns3__CreateAsset);
		((_ns3__CreateAsset*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__CreateAsset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__CreateAsset);
		for (int i = 0; i < n; i++)
			((_ns3__CreateAsset*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__CreateAsset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__CreateAsset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__CreateAsset %p -> %p\n", q, p));
	*(_ns3__CreateAsset*)p = *(_ns3__CreateAsset*)q;
}

void _ns3__DeleteAssetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__DeleteAssetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns3__DeleteAssetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__DeleteAssetResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__DeleteAssetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__DeleteAssetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__DeleteAssetResponse(struct soap *soap, const char *tag, int id, const _ns3__DeleteAssetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__DeleteAssetResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__DeleteAssetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__DeleteAssetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__DeleteAssetResponse * SOAP_FMAC4 soap_get__ns3__DeleteAssetResponse(struct soap *soap, _ns3__DeleteAssetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__DeleteAssetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__DeleteAssetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__DeleteAssetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__DeleteAssetResponse * SOAP_FMAC4 soap_in__ns3__DeleteAssetResponse(struct soap *soap, const char *tag, _ns3__DeleteAssetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__DeleteAssetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__DeleteAssetResponse, sizeof(_ns3__DeleteAssetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__DeleteAssetResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__DeleteAssetResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__DeleteAssetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__DeleteAssetResponse, 0, sizeof(_ns3__DeleteAssetResponse), 0, soap_copy__ns3__DeleteAssetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__DeleteAssetResponse * SOAP_FMAC4 soap_instantiate__ns3__DeleteAssetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__DeleteAssetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__DeleteAssetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__DeleteAssetResponse;
		if (size)
			*size = sizeof(_ns3__DeleteAssetResponse);
		((_ns3__DeleteAssetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__DeleteAssetResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__DeleteAssetResponse);
		for (int i = 0; i < n; i++)
			((_ns3__DeleteAssetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__DeleteAssetResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__DeleteAssetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__DeleteAssetResponse %p -> %p\n", q, p));
	*(_ns3__DeleteAssetResponse*)p = *(_ns3__DeleteAssetResponse*)q;
}

void _ns3__DeleteAsset::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__DeleteAsset::assetid = NULL;
	/* transient soap skipped */
}

void _ns3__DeleteAsset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__DeleteAsset::assetid);
	/* transient soap skipped */
}

int _ns3__DeleteAsset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__DeleteAsset);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__DeleteAsset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__DeleteAsset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__DeleteAsset(struct soap *soap, const char *tag, int id, const _ns3__DeleteAsset *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__DeleteAsset), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:assetid", -1, &(a->_ns3__DeleteAsset::assetid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__DeleteAsset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__DeleteAsset(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__DeleteAsset * SOAP_FMAC4 soap_get__ns3__DeleteAsset(struct soap *soap, _ns3__DeleteAsset *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__DeleteAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__DeleteAsset::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__DeleteAsset(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__DeleteAsset * SOAP_FMAC4 soap_in__ns3__DeleteAsset(struct soap *soap, const char *tag, _ns3__DeleteAsset *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__DeleteAsset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__DeleteAsset, sizeof(_ns3__DeleteAsset), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__DeleteAsset)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__DeleteAsset *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_assetid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assetid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:assetid", &(a->_ns3__DeleteAsset::assetid), "ns4:guid"))
				{	soap_flag_assetid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__DeleteAsset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__DeleteAsset, 0, sizeof(_ns3__DeleteAsset), 0, soap_copy__ns3__DeleteAsset);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_assetid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__DeleteAsset * SOAP_FMAC4 soap_instantiate__ns3__DeleteAsset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__DeleteAsset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__DeleteAsset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__DeleteAsset;
		if (size)
			*size = sizeof(_ns3__DeleteAsset);
		((_ns3__DeleteAsset*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__DeleteAsset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__DeleteAsset);
		for (int i = 0; i < n; i++)
			((_ns3__DeleteAsset*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__DeleteAsset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__DeleteAsset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__DeleteAsset %p -> %p\n", q, p));
	*(_ns3__DeleteAsset*)p = *(_ns3__DeleteAsset*)q;
}

void _ns3__UnlockAssetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns3__UnlockAssetResponse::UnlockAssetResult);
	/* transient soap skipped */
}

void _ns3__UnlockAssetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns3__UnlockAssetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__UnlockAssetResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__UnlockAssetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__UnlockAssetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UnlockAssetResponse(struct soap *soap, const char *tag, int id, const _ns3__UnlockAssetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UnlockAssetResponse), type))
		return soap->error;
	soap_element_result(soap, "ns3:UnlockAssetResult");
	if (soap_out_bool(soap, "ns3:UnlockAssetResult", -1, &(a->_ns3__UnlockAssetResponse::UnlockAssetResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__UnlockAssetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__UnlockAssetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__UnlockAssetResponse * SOAP_FMAC4 soap_get__ns3__UnlockAssetResponse(struct soap *soap, _ns3__UnlockAssetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UnlockAssetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__UnlockAssetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__UnlockAssetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__UnlockAssetResponse * SOAP_FMAC4 soap_in__ns3__UnlockAssetResponse(struct soap *soap, const char *tag, _ns3__UnlockAssetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__UnlockAssetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UnlockAssetResponse, sizeof(_ns3__UnlockAssetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__UnlockAssetResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__UnlockAssetResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UnlockAssetResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UnlockAssetResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns3:UnlockAssetResult", &(a->_ns3__UnlockAssetResponse::UnlockAssetResult), "xsd:boolean"))
				{	soap_flag_UnlockAssetResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:UnlockAssetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__UnlockAssetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UnlockAssetResponse, 0, sizeof(_ns3__UnlockAssetResponse), 0, soap_copy__ns3__UnlockAssetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_UnlockAssetResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__UnlockAssetResponse * SOAP_FMAC4 soap_instantiate__ns3__UnlockAssetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__UnlockAssetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__UnlockAssetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__UnlockAssetResponse;
		if (size)
			*size = sizeof(_ns3__UnlockAssetResponse);
		((_ns3__UnlockAssetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__UnlockAssetResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__UnlockAssetResponse);
		for (int i = 0; i < n; i++)
			((_ns3__UnlockAssetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__UnlockAssetResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__UnlockAssetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__UnlockAssetResponse %p -> %p\n", q, p));
	*(_ns3__UnlockAssetResponse*)p = *(_ns3__UnlockAssetResponse*)q;
}

void _ns3__UnlockAsset::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__UnlockAsset::assetid = NULL;
	soap_default_bool(soap, &this->_ns3__UnlockAsset::forceUnlock);
	/* transient soap skipped */
}

void _ns3__UnlockAsset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__UnlockAsset::assetid);
	/* transient soap skipped */
}

int _ns3__UnlockAsset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__UnlockAsset);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__UnlockAsset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__UnlockAsset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UnlockAsset(struct soap *soap, const char *tag, int id, const _ns3__UnlockAsset *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UnlockAsset), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:assetid", -1, &(a->_ns3__UnlockAsset::assetid), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns3:forceUnlock", -1, &(a->_ns3__UnlockAsset::forceUnlock), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__UnlockAsset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__UnlockAsset(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__UnlockAsset * SOAP_FMAC4 soap_get__ns3__UnlockAsset(struct soap *soap, _ns3__UnlockAsset *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UnlockAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__UnlockAsset::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__UnlockAsset(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__UnlockAsset * SOAP_FMAC4 soap_in__ns3__UnlockAsset(struct soap *soap, const char *tag, _ns3__UnlockAsset *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__UnlockAsset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UnlockAsset, sizeof(_ns3__UnlockAsset), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__UnlockAsset)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__UnlockAsset *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_assetid1 = 1;
	size_t soap_flag_forceUnlock1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assetid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:assetid", &(a->_ns3__UnlockAsset::assetid), "ns4:guid"))
				{	soap_flag_assetid1--;
					continue;
				}
			if (soap_flag_forceUnlock1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns3:forceUnlock", &(a->_ns3__UnlockAsset::forceUnlock), "xsd:boolean"))
				{	soap_flag_forceUnlock1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__UnlockAsset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UnlockAsset, 0, sizeof(_ns3__UnlockAsset), 0, soap_copy__ns3__UnlockAsset);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_assetid1 > 0 || soap_flag_forceUnlock1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__UnlockAsset * SOAP_FMAC4 soap_instantiate__ns3__UnlockAsset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__UnlockAsset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__UnlockAsset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__UnlockAsset;
		if (size)
			*size = sizeof(_ns3__UnlockAsset);
		((_ns3__UnlockAsset*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__UnlockAsset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__UnlockAsset);
		for (int i = 0; i < n; i++)
			((_ns3__UnlockAsset*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__UnlockAsset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__UnlockAsset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__UnlockAsset %p -> %p\n", q, p));
	*(_ns3__UnlockAsset*)p = *(_ns3__UnlockAsset*)q;
}

void _ns3__LockAssetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__LockAssetResponse::LockAssetResult = NULL;
	/* transient soap skipped */
}

void _ns3__LockAssetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__LockDTO(soap, &this->_ns3__LockAssetResponse::LockAssetResult);
	/* transient soap skipped */
}

int _ns3__LockAssetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__LockAssetResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__LockAssetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__LockAssetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__LockAssetResponse(struct soap *soap, const char *tag, int id, const _ns3__LockAssetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__LockAssetResponse), type))
		return soap->error;
	if (a->LockAssetResult)
		soap_element_result(soap, "ns3:LockAssetResult");
	if (soap_out_PointerTons3__LockDTO(soap, "ns3:LockAssetResult", -1, &(a->_ns3__LockAssetResponse::LockAssetResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__LockAssetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__LockAssetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__LockAssetResponse * SOAP_FMAC4 soap_get__ns3__LockAssetResponse(struct soap *soap, _ns3__LockAssetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__LockAssetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__LockAssetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__LockAssetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__LockAssetResponse * SOAP_FMAC4 soap_in__ns3__LockAssetResponse(struct soap *soap, const char *tag, _ns3__LockAssetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__LockAssetResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__LockAssetResponse, sizeof(_ns3__LockAssetResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__LockAssetResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__LockAssetResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LockAssetResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LockAssetResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__LockDTO(soap, "ns3:LockAssetResult", &(a->_ns3__LockAssetResponse::LockAssetResult), "ns3:LockDTO"))
				{	soap_flag_LockAssetResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:LockAssetResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__LockAssetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__LockAssetResponse, 0, sizeof(_ns3__LockAssetResponse), 0, soap_copy__ns3__LockAssetResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__LockAssetResponse * SOAP_FMAC4 soap_instantiate__ns3__LockAssetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__LockAssetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__LockAssetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__LockAssetResponse;
		if (size)
			*size = sizeof(_ns3__LockAssetResponse);
		((_ns3__LockAssetResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__LockAssetResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__LockAssetResponse);
		for (int i = 0; i < n; i++)
			((_ns3__LockAssetResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__LockAssetResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__LockAssetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__LockAssetResponse %p -> %p\n", q, p));
	*(_ns3__LockAssetResponse*)p = *(_ns3__LockAssetResponse*)q;
}

void _ns3__LockAsset::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__LockAsset::assetid = NULL;
	this->_ns3__LockAsset::lockDTO = NULL;
	/* transient soap skipped */
}

void _ns3__LockAsset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__LockAsset::assetid);
	soap_serialize_PointerTons3__LockDTO(soap, &this->_ns3__LockAsset::lockDTO);
	/* transient soap skipped */
}

int _ns3__LockAsset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__LockAsset);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__LockAsset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__LockAsset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__LockAsset(struct soap *soap, const char *tag, int id, const _ns3__LockAsset *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__LockAsset), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:assetid", -1, &(a->_ns3__LockAsset::assetid), ""))
		return soap->error;
	if (soap_out_PointerTons3__LockDTO(soap, "ns3:lockDTO", -1, &(a->_ns3__LockAsset::lockDTO), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__LockAsset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__LockAsset(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__LockAsset * SOAP_FMAC4 soap_get__ns3__LockAsset(struct soap *soap, _ns3__LockAsset *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__LockAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__LockAsset::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__LockAsset(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__LockAsset * SOAP_FMAC4 soap_in__ns3__LockAsset(struct soap *soap, const char *tag, _ns3__LockAsset *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__LockAsset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__LockAsset, sizeof(_ns3__LockAsset), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__LockAsset)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__LockAsset *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_assetid1 = 1;
	size_t soap_flag_lockDTO1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assetid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:assetid", &(a->_ns3__LockAsset::assetid), "ns4:guid"))
				{	soap_flag_assetid1--;
					continue;
				}
			if (soap_flag_lockDTO1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__LockDTO(soap, "ns3:lockDTO", &(a->_ns3__LockAsset::lockDTO), "ns3:LockDTO"))
				{	soap_flag_lockDTO1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__LockAsset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__LockAsset, 0, sizeof(_ns3__LockAsset), 0, soap_copy__ns3__LockAsset);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_assetid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__LockAsset * SOAP_FMAC4 soap_instantiate__ns3__LockAsset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__LockAsset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__LockAsset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__LockAsset;
		if (size)
			*size = sizeof(_ns3__LockAsset);
		((_ns3__LockAsset*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__LockAsset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__LockAsset);
		for (int i = 0; i < n; i++)
			((_ns3__LockAsset*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__LockAsset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__LockAsset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__LockAsset %p -> %p\n", q, p));
	*(_ns3__LockAsset*)p = *(_ns3__LockAsset*)q;
}

void _ns3__GetThumbnailResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetThumbnailResponse::GetThumbnailResult = NULL;
	/* transient soap skipped */
}

void _ns3__GetThumbnailResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &this->_ns3__GetThumbnailResponse::GetThumbnailResult);
	/* transient soap skipped */
}

int _ns3__GetThumbnailResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetThumbnailResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetThumbnailResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetThumbnailResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetThumbnailResponse(struct soap *soap, const char *tag, int id, const _ns3__GetThumbnailResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetThumbnailResponse), type))
		return soap->error;
	if (a->GetThumbnailResult)
		soap_element_result(soap, "ns3:GetThumbnailResult");
	if (soap_out_PointerToxsd__base64Binary(soap, "ns3:GetThumbnailResult", -1, &(a->_ns3__GetThumbnailResponse::GetThumbnailResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetThumbnailResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetThumbnailResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetThumbnailResponse * SOAP_FMAC4 soap_get__ns3__GetThumbnailResponse(struct soap *soap, _ns3__GetThumbnailResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetThumbnailResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetThumbnailResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetThumbnailResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetThumbnailResponse * SOAP_FMAC4 soap_in__ns3__GetThumbnailResponse(struct soap *soap, const char *tag, _ns3__GetThumbnailResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetThumbnailResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetThumbnailResponse, sizeof(_ns3__GetThumbnailResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetThumbnailResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetThumbnailResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetThumbnailResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetThumbnailResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "ns3:GetThumbnailResult", &(a->_ns3__GetThumbnailResponse::GetThumbnailResult), "xsd:base64Binary"))
				{	soap_flag_GetThumbnailResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:GetThumbnailResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetThumbnailResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetThumbnailResponse, 0, sizeof(_ns3__GetThumbnailResponse), 0, soap_copy__ns3__GetThumbnailResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetThumbnailResponse * SOAP_FMAC4 soap_instantiate__ns3__GetThumbnailResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetThumbnailResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetThumbnailResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetThumbnailResponse;
		if (size)
			*size = sizeof(_ns3__GetThumbnailResponse);
		((_ns3__GetThumbnailResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetThumbnailResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetThumbnailResponse);
		for (int i = 0; i < n; i++)
			((_ns3__GetThumbnailResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetThumbnailResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetThumbnailResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetThumbnailResponse %p -> %p\n", q, p));
	*(_ns3__GetThumbnailResponse*)p = *(_ns3__GetThumbnailResponse*)q;
}

void _ns3__GetThumbnail::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetThumbnail::assetid = NULL;
	/* transient soap skipped */
}

void _ns3__GetThumbnail::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__GetThumbnail::assetid);
	/* transient soap skipped */
}

int _ns3__GetThumbnail::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetThumbnail);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetThumbnail::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetThumbnail(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetThumbnail(struct soap *soap, const char *tag, int id, const _ns3__GetThumbnail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetThumbnail), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:assetid", -1, &(a->_ns3__GetThumbnail::assetid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetThumbnail::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetThumbnail(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetThumbnail * SOAP_FMAC4 soap_get__ns3__GetThumbnail(struct soap *soap, _ns3__GetThumbnail *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetThumbnail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetThumbnail::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetThumbnail(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetThumbnail * SOAP_FMAC4 soap_in__ns3__GetThumbnail(struct soap *soap, const char *tag, _ns3__GetThumbnail *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetThumbnail *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetThumbnail, sizeof(_ns3__GetThumbnail), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetThumbnail)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetThumbnail *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_assetid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assetid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:assetid", &(a->_ns3__GetThumbnail::assetid), "ns4:guid"))
				{	soap_flag_assetid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetThumbnail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetThumbnail, 0, sizeof(_ns3__GetThumbnail), 0, soap_copy__ns3__GetThumbnail);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_assetid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetThumbnail * SOAP_FMAC4 soap_instantiate__ns3__GetThumbnail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetThumbnail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetThumbnail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetThumbnail;
		if (size)
			*size = sizeof(_ns3__GetThumbnail);
		((_ns3__GetThumbnail*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetThumbnail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetThumbnail);
		for (int i = 0; i < n; i++)
			((_ns3__GetThumbnail*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetThumbnail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetThumbnail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetThumbnail %p -> %p\n", q, p));
	*(_ns3__GetThumbnail*)p = *(_ns3__GetThumbnail*)q;
}

void _ns3__GetUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetUserResponse::GetUserResult = NULL;
	/* transient soap skipped */
}

void _ns3__GetUserResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__UserDTO(soap, &this->_ns3__GetUserResponse::GetUserResult);
	/* transient soap skipped */
}

int _ns3__GetUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetUserResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetUserResponse(struct soap *soap, const char *tag, int id, const _ns3__GetUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetUserResponse), type))
		return soap->error;
	if (a->GetUserResult)
		soap_element_result(soap, "ns3:GetUserResult");
	if (soap_out_PointerTons3__UserDTO(soap, "ns3:GetUserResult", -1, &(a->_ns3__GetUserResponse::GetUserResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetUserResponse * SOAP_FMAC4 soap_get__ns3__GetUserResponse(struct soap *soap, _ns3__GetUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetUserResponse * SOAP_FMAC4 soap_in__ns3__GetUserResponse(struct soap *soap, const char *tag, _ns3__GetUserResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetUserResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetUserResponse, sizeof(_ns3__GetUserResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetUserResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetUserResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetUserResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetUserResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__UserDTO(soap, "ns3:GetUserResult", &(a->_ns3__GetUserResponse::GetUserResult), "ns3:UserDTO"))
				{	soap_flag_GetUserResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:GetUserResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetUserResponse, 0, sizeof(_ns3__GetUserResponse), 0, soap_copy__ns3__GetUserResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetUserResponse * SOAP_FMAC4 soap_instantiate__ns3__GetUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetUserResponse;
		if (size)
			*size = sizeof(_ns3__GetUserResponse);
		((_ns3__GetUserResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetUserResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetUserResponse);
		for (int i = 0; i < n; i++)
			((_ns3__GetUserResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetUserResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetUserResponse %p -> %p\n", q, p));
	*(_ns3__GetUserResponse*)p = *(_ns3__GetUserResponse*)q;
}

void _ns3__GetUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__GetUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns3__GetUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetUser);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetUser(struct soap *soap, const char *tag, int id, const _ns3__GetUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetUser), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetUser(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetUser * SOAP_FMAC4 soap_get__ns3__GetUser(struct soap *soap, _ns3__GetUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetUser(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetUser * SOAP_FMAC4 soap_in__ns3__GetUser(struct soap *soap, const char *tag, _ns3__GetUser *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetUser, sizeof(_ns3__GetUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetUser)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetUser *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetUser, 0, sizeof(_ns3__GetUser), 0, soap_copy__ns3__GetUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetUser * SOAP_FMAC4 soap_instantiate__ns3__GetUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetUser;
		if (size)
			*size = sizeof(_ns3__GetUser);
		((_ns3__GetUser*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetUser[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetUser);
		for (int i = 0; i < n; i++)
			((_ns3__GetUser*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetUser*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetUser %p -> %p\n", q, p));
	*(_ns3__GetUser*)p = *(_ns3__GetUser*)q;
}

void _ns3__LogoffResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns3__LogoffResponse::LogoffResult);
	/* transient soap skipped */
}

void _ns3__LogoffResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns3__LogoffResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__LogoffResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__LogoffResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__LogoffResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__LogoffResponse(struct soap *soap, const char *tag, int id, const _ns3__LogoffResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__LogoffResponse), type))
		return soap->error;
	soap_element_result(soap, "ns3:LogoffResult");
	if (soap_out_bool(soap, "ns3:LogoffResult", -1, &(a->_ns3__LogoffResponse::LogoffResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__LogoffResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__LogoffResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__LogoffResponse * SOAP_FMAC4 soap_get__ns3__LogoffResponse(struct soap *soap, _ns3__LogoffResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__LogoffResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__LogoffResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__LogoffResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__LogoffResponse * SOAP_FMAC4 soap_in__ns3__LogoffResponse(struct soap *soap, const char *tag, _ns3__LogoffResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__LogoffResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__LogoffResponse, sizeof(_ns3__LogoffResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__LogoffResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__LogoffResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LogoffResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LogoffResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns3:LogoffResult", &(a->_ns3__LogoffResponse::LogoffResult), "xsd:boolean"))
				{	soap_flag_LogoffResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:LogoffResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__LogoffResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__LogoffResponse, 0, sizeof(_ns3__LogoffResponse), 0, soap_copy__ns3__LogoffResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_LogoffResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__LogoffResponse * SOAP_FMAC4 soap_instantiate__ns3__LogoffResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__LogoffResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__LogoffResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__LogoffResponse;
		if (size)
			*size = sizeof(_ns3__LogoffResponse);
		((_ns3__LogoffResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__LogoffResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__LogoffResponse);
		for (int i = 0; i < n; i++)
			((_ns3__LogoffResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__LogoffResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__LogoffResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__LogoffResponse %p -> %p\n", q, p));
	*(_ns3__LogoffResponse*)p = *(_ns3__LogoffResponse*)q;
}

void _ns3__Logoff::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__Logoff::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns3__Logoff::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__Logoff);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__Logoff::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__Logoff(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__Logoff(struct soap *soap, const char *tag, int id, const _ns3__Logoff *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__Logoff), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__Logoff::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__Logoff(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__Logoff * SOAP_FMAC4 soap_get__ns3__Logoff(struct soap *soap, _ns3__Logoff *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__Logoff(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__Logoff::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__Logoff(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__Logoff * SOAP_FMAC4 soap_in__ns3__Logoff(struct soap *soap, const char *tag, _ns3__Logoff *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__Logoff *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__Logoff, sizeof(_ns3__Logoff), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__Logoff)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__Logoff *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__Logoff *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__Logoff, 0, sizeof(_ns3__Logoff), 0, soap_copy__ns3__Logoff);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__Logoff * SOAP_FMAC4 soap_instantiate__ns3__Logoff(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__Logoff(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__Logoff, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__Logoff;
		if (size)
			*size = sizeof(_ns3__Logoff);
		((_ns3__Logoff*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__Logoff[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__Logoff);
		for (int i = 0; i < n; i++)
			((_ns3__Logoff*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__Logoff*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__Logoff(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__Logoff %p -> %p\n", q, p));
	*(_ns3__Logoff*)p = *(_ns3__Logoff*)q;
}

void _ns3__GetShelveListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetShelveListResponse::GetShelveListResult = NULL;
	/* transient soap skipped */
}

void _ns3__GetShelveListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__ArrayOfShelveDTO(soap, &this->_ns3__GetShelveListResponse::GetShelveListResult);
	/* transient soap skipped */
}

int _ns3__GetShelveListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetShelveListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetShelveListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetShelveListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetShelveListResponse(struct soap *soap, const char *tag, int id, const _ns3__GetShelveListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetShelveListResponse), type))
		return soap->error;
	if (a->GetShelveListResult)
		soap_element_result(soap, "ns3:GetShelveListResult");
	if (soap_out_PointerTons3__ArrayOfShelveDTO(soap, "ns3:GetShelveListResult", -1, &(a->_ns3__GetShelveListResponse::GetShelveListResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetShelveListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetShelveListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetShelveListResponse * SOAP_FMAC4 soap_get__ns3__GetShelveListResponse(struct soap *soap, _ns3__GetShelveListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetShelveListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetShelveListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetShelveListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetShelveListResponse * SOAP_FMAC4 soap_in__ns3__GetShelveListResponse(struct soap *soap, const char *tag, _ns3__GetShelveListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetShelveListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetShelveListResponse, sizeof(_ns3__GetShelveListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetShelveListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetShelveListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetShelveListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetShelveListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfShelveDTO(soap, "ns3:GetShelveListResult", &(a->_ns3__GetShelveListResponse::GetShelveListResult), "ns3:ArrayOfShelveDTO"))
				{	soap_flag_GetShelveListResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:GetShelveListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetShelveListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetShelveListResponse, 0, sizeof(_ns3__GetShelveListResponse), 0, soap_copy__ns3__GetShelveListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetShelveListResponse * SOAP_FMAC4 soap_instantiate__ns3__GetShelveListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetShelveListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetShelveListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetShelveListResponse;
		if (size)
			*size = sizeof(_ns3__GetShelveListResponse);
		((_ns3__GetShelveListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetShelveListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetShelveListResponse);
		for (int i = 0; i < n; i++)
			((_ns3__GetShelveListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetShelveListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetShelveListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetShelveListResponse %p -> %p\n", q, p));
	*(_ns3__GetShelveListResponse*)p = *(_ns3__GetShelveListResponse*)q;
}

void _ns3__GetShelveList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetShelveList::titleid = NULL;
	/* transient soap skipped */
}

void _ns3__GetShelveList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__GetShelveList::titleid);
	/* transient soap skipped */
}

int _ns3__GetShelveList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetShelveList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetShelveList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetShelveList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetShelveList(struct soap *soap, const char *tag, int id, const _ns3__GetShelveList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetShelveList), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:titleid", -1, &(a->_ns3__GetShelveList::titleid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetShelveList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetShelveList(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetShelveList * SOAP_FMAC4 soap_get__ns3__GetShelveList(struct soap *soap, _ns3__GetShelveList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetShelveList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetShelveList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetShelveList(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetShelveList * SOAP_FMAC4 soap_in__ns3__GetShelveList(struct soap *soap, const char *tag, _ns3__GetShelveList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetShelveList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetShelveList, sizeof(_ns3__GetShelveList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetShelveList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetShelveList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_titleid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_titleid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:titleid", &(a->_ns3__GetShelveList::titleid), "ns4:guid"))
				{	soap_flag_titleid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetShelveList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetShelveList, 0, sizeof(_ns3__GetShelveList), 0, soap_copy__ns3__GetShelveList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_titleid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetShelveList * SOAP_FMAC4 soap_instantiate__ns3__GetShelveList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetShelveList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetShelveList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetShelveList;
		if (size)
			*size = sizeof(_ns3__GetShelveList);
		((_ns3__GetShelveList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetShelveList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetShelveList);
		for (int i = 0; i < n; i++)
			((_ns3__GetShelveList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetShelveList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetShelveList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetShelveList %p -> %p\n", q, p));
	*(_ns3__GetShelveList*)p = *(_ns3__GetShelveList*)q;
}

void _ns3__GetTagsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetTagsResponse::GetTagsResult = NULL;
	/* transient soap skipped */
}

void _ns3__GetTagsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__ArrayOfString(soap, &this->_ns3__GetTagsResponse::GetTagsResult);
	/* transient soap skipped */
}

int _ns3__GetTagsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetTagsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetTagsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetTagsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetTagsResponse(struct soap *soap, const char *tag, int id, const _ns3__GetTagsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetTagsResponse), type))
		return soap->error;
	if (a->GetTagsResult)
		soap_element_result(soap, "ns3:GetTagsResult");
	if (soap_out_PointerTons3__ArrayOfString(soap, "ns3:GetTagsResult", -1, &(a->_ns3__GetTagsResponse::GetTagsResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetTagsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetTagsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetTagsResponse * SOAP_FMAC4 soap_get__ns3__GetTagsResponse(struct soap *soap, _ns3__GetTagsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetTagsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetTagsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetTagsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetTagsResponse * SOAP_FMAC4 soap_in__ns3__GetTagsResponse(struct soap *soap, const char *tag, _ns3__GetTagsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetTagsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetTagsResponse, sizeof(_ns3__GetTagsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetTagsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetTagsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetTagsResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetTagsResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfString(soap, "ns3:GetTagsResult", &(a->_ns3__GetTagsResponse::GetTagsResult), "ns3:ArrayOfString"))
				{	soap_flag_GetTagsResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:GetTagsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetTagsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetTagsResponse, 0, sizeof(_ns3__GetTagsResponse), 0, soap_copy__ns3__GetTagsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetTagsResponse * SOAP_FMAC4 soap_instantiate__ns3__GetTagsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetTagsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetTagsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetTagsResponse;
		if (size)
			*size = sizeof(_ns3__GetTagsResponse);
		((_ns3__GetTagsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetTagsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetTagsResponse);
		for (int i = 0; i < n; i++)
			((_ns3__GetTagsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetTagsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetTagsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetTagsResponse %p -> %p\n", q, p));
	*(_ns3__GetTagsResponse*)p = *(_ns3__GetTagsResponse*)q;
}

void _ns3__GetTags::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetTags::assetid = NULL;
	/* transient soap skipped */
}

void _ns3__GetTags::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__GetTags::assetid);
	/* transient soap skipped */
}

int _ns3__GetTags::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetTags);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetTags::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetTags(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetTags(struct soap *soap, const char *tag, int id, const _ns3__GetTags *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetTags), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:assetid", -1, &(a->_ns3__GetTags::assetid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetTags::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetTags(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetTags * SOAP_FMAC4 soap_get__ns3__GetTags(struct soap *soap, _ns3__GetTags *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetTags(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetTags::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetTags(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetTags * SOAP_FMAC4 soap_in__ns3__GetTags(struct soap *soap, const char *tag, _ns3__GetTags *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetTags *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetTags, sizeof(_ns3__GetTags), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetTags)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetTags *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_assetid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assetid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:assetid", &(a->_ns3__GetTags::assetid), "ns4:guid"))
				{	soap_flag_assetid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetTags *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetTags, 0, sizeof(_ns3__GetTags), 0, soap_copy__ns3__GetTags);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_assetid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetTags * SOAP_FMAC4 soap_instantiate__ns3__GetTags(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetTags(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetTags, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetTags;
		if (size)
			*size = sizeof(_ns3__GetTags);
		((_ns3__GetTags*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetTags[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetTags);
		for (int i = 0; i < n; i++)
			((_ns3__GetTags*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetTags*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetTags(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetTags %p -> %p\n", q, p));
	*(_ns3__GetTags*)p = *(_ns3__GetTags*)q;
}

void _ns3__GetCommentListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetCommentListResponse::GetCommentListResult = NULL;
	/* transient soap skipped */
}

void _ns3__GetCommentListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__ArrayOfCommentDTO(soap, &this->_ns3__GetCommentListResponse::GetCommentListResult);
	/* transient soap skipped */
}

int _ns3__GetCommentListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetCommentListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetCommentListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetCommentListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetCommentListResponse(struct soap *soap, const char *tag, int id, const _ns3__GetCommentListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetCommentListResponse), type))
		return soap->error;
	if (a->GetCommentListResult)
		soap_element_result(soap, "ns3:GetCommentListResult");
	if (soap_out_PointerTons3__ArrayOfCommentDTO(soap, "ns3:GetCommentListResult", -1, &(a->_ns3__GetCommentListResponse::GetCommentListResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetCommentListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetCommentListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetCommentListResponse * SOAP_FMAC4 soap_get__ns3__GetCommentListResponse(struct soap *soap, _ns3__GetCommentListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetCommentListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetCommentListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetCommentListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetCommentListResponse * SOAP_FMAC4 soap_in__ns3__GetCommentListResponse(struct soap *soap, const char *tag, _ns3__GetCommentListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetCommentListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetCommentListResponse, sizeof(_ns3__GetCommentListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetCommentListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetCommentListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetCommentListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetCommentListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfCommentDTO(soap, "ns3:GetCommentListResult", &(a->_ns3__GetCommentListResponse::GetCommentListResult), "ns3:ArrayOfCommentDTO"))
				{	soap_flag_GetCommentListResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:GetCommentListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetCommentListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetCommentListResponse, 0, sizeof(_ns3__GetCommentListResponse), 0, soap_copy__ns3__GetCommentListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetCommentListResponse * SOAP_FMAC4 soap_instantiate__ns3__GetCommentListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetCommentListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetCommentListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetCommentListResponse;
		if (size)
			*size = sizeof(_ns3__GetCommentListResponse);
		((_ns3__GetCommentListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetCommentListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetCommentListResponse);
		for (int i = 0; i < n; i++)
			((_ns3__GetCommentListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetCommentListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetCommentListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetCommentListResponse %p -> %p\n", q, p));
	*(_ns3__GetCommentListResponse*)p = *(_ns3__GetCommentListResponse*)q;
}

void _ns3__GetCommentList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetCommentList::assetid = NULL;
	/* transient soap skipped */
}

void _ns3__GetCommentList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__GetCommentList::assetid);
	/* transient soap skipped */
}

int _ns3__GetCommentList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetCommentList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetCommentList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetCommentList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetCommentList(struct soap *soap, const char *tag, int id, const _ns3__GetCommentList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetCommentList), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:assetid", -1, &(a->_ns3__GetCommentList::assetid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetCommentList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetCommentList(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetCommentList * SOAP_FMAC4 soap_get__ns3__GetCommentList(struct soap *soap, _ns3__GetCommentList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetCommentList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetCommentList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetCommentList(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetCommentList * SOAP_FMAC4 soap_in__ns3__GetCommentList(struct soap *soap, const char *tag, _ns3__GetCommentList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetCommentList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetCommentList, sizeof(_ns3__GetCommentList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetCommentList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetCommentList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_assetid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assetid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:assetid", &(a->_ns3__GetCommentList::assetid), "ns4:guid"))
				{	soap_flag_assetid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetCommentList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetCommentList, 0, sizeof(_ns3__GetCommentList), 0, soap_copy__ns3__GetCommentList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_assetid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetCommentList * SOAP_FMAC4 soap_instantiate__ns3__GetCommentList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetCommentList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetCommentList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetCommentList;
		if (size)
			*size = sizeof(_ns3__GetCommentList);
		((_ns3__GetCommentList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetCommentList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetCommentList);
		for (int i = 0; i < n; i++)
			((_ns3__GetCommentList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetCommentList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetCommentList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetCommentList %p -> %p\n", q, p));
	*(_ns3__GetCommentList*)p = *(_ns3__GetCommentList*)q;
}

void _ns3__GetRoleResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetRoleResponse::GetRoleResult = NULL;
	/* transient soap skipped */
}

void _ns3__GetRoleResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__GetRoleResponse::GetRoleResult);
	/* transient soap skipped */
}

int _ns3__GetRoleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetRoleResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetRoleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRoleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRoleResponse(struct soap *soap, const char *tag, int id, const _ns3__GetRoleResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetRoleResponse), type))
		return soap->error;
	if (a->GetRoleResult)
		soap_element_result(soap, "ns3:GetRoleResult");
	if (soap_out_ns4__guid(soap, "ns3:GetRoleResult", -1, &(a->_ns3__GetRoleResponse::GetRoleResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRoleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRoleResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRoleResponse * SOAP_FMAC4 soap_get__ns3__GetRoleResponse(struct soap *soap, _ns3__GetRoleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRoleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetRoleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRoleResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRoleResponse * SOAP_FMAC4 soap_in__ns3__GetRoleResponse(struct soap *soap, const char *tag, _ns3__GetRoleResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRoleResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetRoleResponse, sizeof(_ns3__GetRoleResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetRoleResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRoleResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetRoleResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetRoleResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:GetRoleResult", &(a->_ns3__GetRoleResponse::GetRoleResult), "ns4:guid"))
				{	soap_flag_GetRoleResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:GetRoleResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRoleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetRoleResponse, 0, sizeof(_ns3__GetRoleResponse), 0, soap_copy__ns3__GetRoleResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_GetRoleResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetRoleResponse * SOAP_FMAC4 soap_instantiate__ns3__GetRoleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRoleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetRoleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetRoleResponse;
		if (size)
			*size = sizeof(_ns3__GetRoleResponse);
		((_ns3__GetRoleResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetRoleResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetRoleResponse);
		for (int i = 0; i < n; i++)
			((_ns3__GetRoleResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetRoleResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRoleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRoleResponse %p -> %p\n", q, p));
	*(_ns3__GetRoleResponse*)p = *(_ns3__GetRoleResponse*)q;
}

void _ns3__GetRole::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__GetRole::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns3__GetRole::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetRole);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetRole::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetRole(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetRole(struct soap *soap, const char *tag, int id, const _ns3__GetRole *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetRole), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetRole::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetRole(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetRole * SOAP_FMAC4 soap_get__ns3__GetRole(struct soap *soap, _ns3__GetRole *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetRole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetRole::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetRole(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetRole * SOAP_FMAC4 soap_in__ns3__GetRole(struct soap *soap, const char *tag, _ns3__GetRole *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetRole *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetRole, sizeof(_ns3__GetRole), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetRole)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetRole *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetRole *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetRole, 0, sizeof(_ns3__GetRole), 0, soap_copy__ns3__GetRole);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetRole * SOAP_FMAC4 soap_instantiate__ns3__GetRole(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetRole(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetRole, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetRole;
		if (size)
			*size = sizeof(_ns3__GetRole);
		((_ns3__GetRole*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetRole[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetRole);
		for (int i = 0; i < n; i++)
			((_ns3__GetRole*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetRole*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetRole(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetRole %p -> %p\n", q, p));
	*(_ns3__GetRole*)p = *(_ns3__GetRole*)q;
}

void _ns3__GetTitleListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetTitleListResponse::GetTitleListResult = NULL;
	/* transient soap skipped */
}

void _ns3__GetTitleListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__ArrayOfTitleDTO(soap, &this->_ns3__GetTitleListResponse::GetTitleListResult);
	/* transient soap skipped */
}

int _ns3__GetTitleListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetTitleListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetTitleListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetTitleListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetTitleListResponse(struct soap *soap, const char *tag, int id, const _ns3__GetTitleListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetTitleListResponse), type))
		return soap->error;
	if (a->GetTitleListResult)
		soap_element_result(soap, "ns3:GetTitleListResult");
	if (soap_out_PointerTons3__ArrayOfTitleDTO(soap, "ns3:GetTitleListResult", -1, &(a->_ns3__GetTitleListResponse::GetTitleListResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetTitleListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetTitleListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetTitleListResponse * SOAP_FMAC4 soap_get__ns3__GetTitleListResponse(struct soap *soap, _ns3__GetTitleListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetTitleListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetTitleListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetTitleListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetTitleListResponse * SOAP_FMAC4 soap_in__ns3__GetTitleListResponse(struct soap *soap, const char *tag, _ns3__GetTitleListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetTitleListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetTitleListResponse, sizeof(_ns3__GetTitleListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetTitleListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetTitleListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetTitleListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetTitleListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfTitleDTO(soap, "ns3:GetTitleListResult", &(a->_ns3__GetTitleListResponse::GetTitleListResult), "ns3:ArrayOfTitleDTO"))
				{	soap_flag_GetTitleListResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:GetTitleListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetTitleListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetTitleListResponse, 0, sizeof(_ns3__GetTitleListResponse), 0, soap_copy__ns3__GetTitleListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetTitleListResponse * SOAP_FMAC4 soap_instantiate__ns3__GetTitleListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetTitleListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetTitleListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetTitleListResponse;
		if (size)
			*size = sizeof(_ns3__GetTitleListResponse);
		((_ns3__GetTitleListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetTitleListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetTitleListResponse);
		for (int i = 0; i < n; i++)
			((_ns3__GetTitleListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetTitleListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetTitleListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetTitleListResponse %p -> %p\n", q, p));
	*(_ns3__GetTitleListResponse*)p = *(_ns3__GetTitleListResponse*)q;
}

void _ns3__GetTitleList::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__GetTitleList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns3__GetTitleList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetTitleList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetTitleList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetTitleList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetTitleList(struct soap *soap, const char *tag, int id, const _ns3__GetTitleList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetTitleList), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetTitleList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetTitleList(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetTitleList * SOAP_FMAC4 soap_get__ns3__GetTitleList(struct soap *soap, _ns3__GetTitleList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetTitleList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetTitleList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetTitleList(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetTitleList * SOAP_FMAC4 soap_in__ns3__GetTitleList(struct soap *soap, const char *tag, _ns3__GetTitleList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetTitleList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetTitleList, sizeof(_ns3__GetTitleList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetTitleList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetTitleList *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetTitleList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetTitleList, 0, sizeof(_ns3__GetTitleList), 0, soap_copy__ns3__GetTitleList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetTitleList * SOAP_FMAC4 soap_instantiate__ns3__GetTitleList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetTitleList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetTitleList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetTitleList;
		if (size)
			*size = sizeof(_ns3__GetTitleList);
		((_ns3__GetTitleList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetTitleList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetTitleList);
		for (int i = 0; i < n; i++)
			((_ns3__GetTitleList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetTitleList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetTitleList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetTitleList %p -> %p\n", q, p));
	*(_ns3__GetTitleList*)p = *(_ns3__GetTitleList*)q;
}

void _ns3__LoginResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__LoginResponse::LoginResult = NULL;
	/* transient soap skipped */
}

void _ns3__LoginResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__UserDTO(soap, &this->_ns3__LoginResponse::LoginResult);
	/* transient soap skipped */
}

int _ns3__LoginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__LoginResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__LoginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__LoginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__LoginResponse(struct soap *soap, const char *tag, int id, const _ns3__LoginResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__LoginResponse), type))
		return soap->error;
	if (a->LoginResult)
		soap_element_result(soap, "ns3:LoginResult");
	if (soap_out_PointerTons3__UserDTO(soap, "ns3:LoginResult", -1, &(a->_ns3__LoginResponse::LoginResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__LoginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__LoginResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__LoginResponse * SOAP_FMAC4 soap_get__ns3__LoginResponse(struct soap *soap, _ns3__LoginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__LoginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__LoginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__LoginResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__LoginResponse * SOAP_FMAC4 soap_in__ns3__LoginResponse(struct soap *soap, const char *tag, _ns3__LoginResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__LoginResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__LoginResponse, sizeof(_ns3__LoginResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__LoginResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__LoginResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LoginResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LoginResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__UserDTO(soap, "ns3:LoginResult", &(a->_ns3__LoginResponse::LoginResult), "ns3:UserDTO"))
				{	soap_flag_LoginResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:LoginResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__LoginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__LoginResponse, 0, sizeof(_ns3__LoginResponse), 0, soap_copy__ns3__LoginResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__LoginResponse * SOAP_FMAC4 soap_instantiate__ns3__LoginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__LoginResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__LoginResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__LoginResponse;
		if (size)
			*size = sizeof(_ns3__LoginResponse);
		((_ns3__LoginResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__LoginResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__LoginResponse);
		for (int i = 0; i < n; i++)
			((_ns3__LoginResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__LoginResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__LoginResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__LoginResponse %p -> %p\n", q, p));
	*(_ns3__LoginResponse*)p = *(_ns3__LoginResponse*)q;
}

void _ns3__Login::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__Login::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns3__Login::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__Login);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__Login::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__Login(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__Login(struct soap *soap, const char *tag, int id, const _ns3__Login *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__Login), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__Login::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__Login(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__Login * SOAP_FMAC4 soap_get__ns3__Login(struct soap *soap, _ns3__Login *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__Login::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__Login(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__Login * SOAP_FMAC4 soap_in__ns3__Login(struct soap *soap, const char *tag, _ns3__Login *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__Login *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__Login, sizeof(_ns3__Login), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__Login)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__Login *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__Login *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__Login, 0, sizeof(_ns3__Login), 0, soap_copy__ns3__Login);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__Login * SOAP_FMAC4 soap_instantiate__ns3__Login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__Login(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__Login, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__Login;
		if (size)
			*size = sizeof(_ns3__Login);
		((_ns3__Login*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__Login[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__Login);
		for (int i = 0; i < n; i++)
			((_ns3__Login*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__Login*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__Login(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__Login %p -> %p\n", q, p));
	*(_ns3__Login*)p = *(_ns3__Login*)q;
}

void _ns3__DeleteTaskResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__DeleteTaskResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns3__DeleteTaskResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__DeleteTaskResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__DeleteTaskResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__DeleteTaskResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__DeleteTaskResponse(struct soap *soap, const char *tag, int id, const _ns3__DeleteTaskResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__DeleteTaskResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__DeleteTaskResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__DeleteTaskResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__DeleteTaskResponse * SOAP_FMAC4 soap_get__ns3__DeleteTaskResponse(struct soap *soap, _ns3__DeleteTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__DeleteTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__DeleteTaskResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__DeleteTaskResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__DeleteTaskResponse * SOAP_FMAC4 soap_in__ns3__DeleteTaskResponse(struct soap *soap, const char *tag, _ns3__DeleteTaskResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__DeleteTaskResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__DeleteTaskResponse, sizeof(_ns3__DeleteTaskResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__DeleteTaskResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__DeleteTaskResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__DeleteTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__DeleteTaskResponse, 0, sizeof(_ns3__DeleteTaskResponse), 0, soap_copy__ns3__DeleteTaskResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__DeleteTaskResponse * SOAP_FMAC4 soap_instantiate__ns3__DeleteTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__DeleteTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__DeleteTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__DeleteTaskResponse;
		if (size)
			*size = sizeof(_ns3__DeleteTaskResponse);
		((_ns3__DeleteTaskResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__DeleteTaskResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__DeleteTaskResponse);
		for (int i = 0; i < n; i++)
			((_ns3__DeleteTaskResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__DeleteTaskResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__DeleteTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__DeleteTaskResponse %p -> %p\n", q, p));
	*(_ns3__DeleteTaskResponse*)p = *(_ns3__DeleteTaskResponse*)q;
}

void _ns3__DeleteTask::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__DeleteTask::taskId = NULL;
	/* transient soap skipped */
}

void _ns3__DeleteTask::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__DeleteTask::taskId);
	/* transient soap skipped */
}

int _ns3__DeleteTask::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__DeleteTask);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__DeleteTask::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__DeleteTask(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__DeleteTask(struct soap *soap, const char *tag, int id, const _ns3__DeleteTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__DeleteTask), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:taskId", -1, &(a->_ns3__DeleteTask::taskId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__DeleteTask::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__DeleteTask(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__DeleteTask * SOAP_FMAC4 soap_get__ns3__DeleteTask(struct soap *soap, _ns3__DeleteTask *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__DeleteTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__DeleteTask::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__DeleteTask(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__DeleteTask * SOAP_FMAC4 soap_in__ns3__DeleteTask(struct soap *soap, const char *tag, _ns3__DeleteTask *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__DeleteTask *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__DeleteTask, sizeof(_ns3__DeleteTask), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__DeleteTask)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__DeleteTask *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_taskId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_taskId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:taskId", &(a->_ns3__DeleteTask::taskId), "ns4:guid"))
				{	soap_flag_taskId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__DeleteTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__DeleteTask, 0, sizeof(_ns3__DeleteTask), 0, soap_copy__ns3__DeleteTask);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_taskId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__DeleteTask * SOAP_FMAC4 soap_instantiate__ns3__DeleteTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__DeleteTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__DeleteTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__DeleteTask;
		if (size)
			*size = sizeof(_ns3__DeleteTask);
		((_ns3__DeleteTask*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__DeleteTask[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__DeleteTask);
		for (int i = 0; i < n; i++)
			((_ns3__DeleteTask*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__DeleteTask*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__DeleteTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__DeleteTask %p -> %p\n", q, p));
	*(_ns3__DeleteTask*)p = *(_ns3__DeleteTask*)q;
}

void _ns3__GetTaskHistoryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetTaskHistoryResponse::GetTaskHistoryResult = NULL;
	/* transient soap skipped */
}

void _ns3__GetTaskHistoryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &this->_ns3__GetTaskHistoryResponse::GetTaskHistoryResult);
	/* transient soap skipped */
}

int _ns3__GetTaskHistoryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetTaskHistoryResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetTaskHistoryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetTaskHistoryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetTaskHistoryResponse(struct soap *soap, const char *tag, int id, const _ns3__GetTaskHistoryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetTaskHistoryResponse), type))
		return soap->error;
	if (a->GetTaskHistoryResult)
		soap_element_result(soap, "ns3:GetTaskHistoryResult");
	if (soap_out_PointerToxsd__base64Binary(soap, "ns3:GetTaskHistoryResult", -1, &(a->_ns3__GetTaskHistoryResponse::GetTaskHistoryResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetTaskHistoryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetTaskHistoryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetTaskHistoryResponse * SOAP_FMAC4 soap_get__ns3__GetTaskHistoryResponse(struct soap *soap, _ns3__GetTaskHistoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetTaskHistoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetTaskHistoryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetTaskHistoryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetTaskHistoryResponse * SOAP_FMAC4 soap_in__ns3__GetTaskHistoryResponse(struct soap *soap, const char *tag, _ns3__GetTaskHistoryResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetTaskHistoryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetTaskHistoryResponse, sizeof(_ns3__GetTaskHistoryResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetTaskHistoryResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetTaskHistoryResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetTaskHistoryResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetTaskHistoryResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "ns3:GetTaskHistoryResult", &(a->_ns3__GetTaskHistoryResponse::GetTaskHistoryResult), "xsd:base64Binary"))
				{	soap_flag_GetTaskHistoryResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:GetTaskHistoryResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetTaskHistoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetTaskHistoryResponse, 0, sizeof(_ns3__GetTaskHistoryResponse), 0, soap_copy__ns3__GetTaskHistoryResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetTaskHistoryResponse * SOAP_FMAC4 soap_instantiate__ns3__GetTaskHistoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetTaskHistoryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetTaskHistoryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetTaskHistoryResponse;
		if (size)
			*size = sizeof(_ns3__GetTaskHistoryResponse);
		((_ns3__GetTaskHistoryResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetTaskHistoryResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetTaskHistoryResponse);
		for (int i = 0; i < n; i++)
			((_ns3__GetTaskHistoryResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetTaskHistoryResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetTaskHistoryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetTaskHistoryResponse %p -> %p\n", q, p));
	*(_ns3__GetTaskHistoryResponse*)p = *(_ns3__GetTaskHistoryResponse*)q;
}

void _ns3__GetTaskHistory::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetTaskHistory::taskid = NULL;
	/* transient soap skipped */
}

void _ns3__GetTaskHistory::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__GetTaskHistory::taskid);
	/* transient soap skipped */
}

int _ns3__GetTaskHistory::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetTaskHistory);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetTaskHistory::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetTaskHistory(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetTaskHistory(struct soap *soap, const char *tag, int id, const _ns3__GetTaskHistory *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetTaskHistory), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:taskid", -1, &(a->_ns3__GetTaskHistory::taskid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetTaskHistory::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetTaskHistory(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetTaskHistory * SOAP_FMAC4 soap_get__ns3__GetTaskHistory(struct soap *soap, _ns3__GetTaskHistory *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetTaskHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetTaskHistory::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetTaskHistory(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetTaskHistory * SOAP_FMAC4 soap_in__ns3__GetTaskHistory(struct soap *soap, const char *tag, _ns3__GetTaskHistory *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetTaskHistory *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetTaskHistory, sizeof(_ns3__GetTaskHistory), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetTaskHistory)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetTaskHistory *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_taskid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_taskid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:taskid", &(a->_ns3__GetTaskHistory::taskid), "ns4:guid"))
				{	soap_flag_taskid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetTaskHistory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetTaskHistory, 0, sizeof(_ns3__GetTaskHistory), 0, soap_copy__ns3__GetTaskHistory);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_taskid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetTaskHistory * SOAP_FMAC4 soap_instantiate__ns3__GetTaskHistory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetTaskHistory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetTaskHistory, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetTaskHistory;
		if (size)
			*size = sizeof(_ns3__GetTaskHistory);
		((_ns3__GetTaskHistory*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetTaskHistory[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetTaskHistory);
		for (int i = 0; i < n; i++)
			((_ns3__GetTaskHistory*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetTaskHistory*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetTaskHistory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetTaskHistory %p -> %p\n", q, p));
	*(_ns3__GetTaskHistory*)p = *(_ns3__GetTaskHistory*)q;
}

void _ns3__UpdateTaskResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__UpdateTaskResponse::UpdateTaskResult = NULL;
	/* transient soap skipped */
}

void _ns3__UpdateTaskResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__TaskDTO(soap, &this->_ns3__UpdateTaskResponse::UpdateTaskResult);
	/* transient soap skipped */
}

int _ns3__UpdateTaskResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__UpdateTaskResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__UpdateTaskResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__UpdateTaskResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UpdateTaskResponse(struct soap *soap, const char *tag, int id, const _ns3__UpdateTaskResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UpdateTaskResponse), type))
		return soap->error;
	if (a->UpdateTaskResult)
		soap_element_result(soap, "ns3:UpdateTaskResult");
	if (soap_out_PointerTons3__TaskDTO(soap, "ns3:UpdateTaskResult", -1, &(a->_ns3__UpdateTaskResponse::UpdateTaskResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__UpdateTaskResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__UpdateTaskResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__UpdateTaskResponse * SOAP_FMAC4 soap_get__ns3__UpdateTaskResponse(struct soap *soap, _ns3__UpdateTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UpdateTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__UpdateTaskResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__UpdateTaskResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__UpdateTaskResponse * SOAP_FMAC4 soap_in__ns3__UpdateTaskResponse(struct soap *soap, const char *tag, _ns3__UpdateTaskResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__UpdateTaskResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UpdateTaskResponse, sizeof(_ns3__UpdateTaskResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__UpdateTaskResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__UpdateTaskResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UpdateTaskResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdateTaskResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__TaskDTO(soap, "ns3:UpdateTaskResult", &(a->_ns3__UpdateTaskResponse::UpdateTaskResult), "ns3:TaskDTO"))
				{	soap_flag_UpdateTaskResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:UpdateTaskResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__UpdateTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UpdateTaskResponse, 0, sizeof(_ns3__UpdateTaskResponse), 0, soap_copy__ns3__UpdateTaskResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__UpdateTaskResponse * SOAP_FMAC4 soap_instantiate__ns3__UpdateTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__UpdateTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__UpdateTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__UpdateTaskResponse;
		if (size)
			*size = sizeof(_ns3__UpdateTaskResponse);
		((_ns3__UpdateTaskResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__UpdateTaskResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__UpdateTaskResponse);
		for (int i = 0; i < n; i++)
			((_ns3__UpdateTaskResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__UpdateTaskResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__UpdateTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__UpdateTaskResponse %p -> %p\n", q, p));
	*(_ns3__UpdateTaskResponse*)p = *(_ns3__UpdateTaskResponse*)q;
}

void _ns3__UpdateTask::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__UpdateTask::task = NULL;
	this->_ns3__UpdateTask::comment = NULL;
	/* transient soap skipped */
}

void _ns3__UpdateTask::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__TaskDTO(soap, &this->_ns3__UpdateTask::task);
	soap_serialize_wstring(soap, &this->_ns3__UpdateTask::comment);
	/* transient soap skipped */
}

int _ns3__UpdateTask::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__UpdateTask);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__UpdateTask::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__UpdateTask(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__UpdateTask(struct soap *soap, const char *tag, int id, const _ns3__UpdateTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__UpdateTask), type))
		return soap->error;
	if (soap_out_PointerTons3__TaskDTO(soap, "ns3:task", -1, &(a->_ns3__UpdateTask::task), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:comment", -1, &(a->_ns3__UpdateTask::comment), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__UpdateTask::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__UpdateTask(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__UpdateTask * SOAP_FMAC4 soap_get__ns3__UpdateTask(struct soap *soap, _ns3__UpdateTask *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__UpdateTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__UpdateTask::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__UpdateTask(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__UpdateTask * SOAP_FMAC4 soap_in__ns3__UpdateTask(struct soap *soap, const char *tag, _ns3__UpdateTask *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__UpdateTask *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__UpdateTask, sizeof(_ns3__UpdateTask), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__UpdateTask)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__UpdateTask *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_task1 = 1;
	size_t soap_flag_comment1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_task1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__TaskDTO(soap, "ns3:task", &(a->_ns3__UpdateTask::task), "ns3:TaskDTO"))
				{	soap_flag_task1--;
					continue;
				}
			if (soap_flag_comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:comment", &(a->_ns3__UpdateTask::comment), "xsd:string"))
				{	soap_flag_comment1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__UpdateTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__UpdateTask, 0, sizeof(_ns3__UpdateTask), 0, soap_copy__ns3__UpdateTask);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__UpdateTask * SOAP_FMAC4 soap_instantiate__ns3__UpdateTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__UpdateTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__UpdateTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__UpdateTask;
		if (size)
			*size = sizeof(_ns3__UpdateTask);
		((_ns3__UpdateTask*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__UpdateTask[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__UpdateTask);
		for (int i = 0; i < n; i++)
			((_ns3__UpdateTask*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__UpdateTask*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__UpdateTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__UpdateTask %p -> %p\n", q, p));
	*(_ns3__UpdateTask*)p = *(_ns3__UpdateTask*)q;
}

void _ns3__GetTaskCategoryListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetTaskCategoryListResponse::GetTaskCategoryListResult = NULL;
	/* transient soap skipped */
}

void _ns3__GetTaskCategoryListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__ArrayOfIdNameDTO(soap, &this->_ns3__GetTaskCategoryListResponse::GetTaskCategoryListResult);
	/* transient soap skipped */
}

int _ns3__GetTaskCategoryListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetTaskCategoryListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetTaskCategoryListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetTaskCategoryListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetTaskCategoryListResponse(struct soap *soap, const char *tag, int id, const _ns3__GetTaskCategoryListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetTaskCategoryListResponse), type))
		return soap->error;
	if (a->GetTaskCategoryListResult)
		soap_element_result(soap, "ns3:GetTaskCategoryListResult");
	if (soap_out_PointerTons3__ArrayOfIdNameDTO(soap, "ns3:GetTaskCategoryListResult", -1, &(a->_ns3__GetTaskCategoryListResponse::GetTaskCategoryListResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetTaskCategoryListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetTaskCategoryListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetTaskCategoryListResponse * SOAP_FMAC4 soap_get__ns3__GetTaskCategoryListResponse(struct soap *soap, _ns3__GetTaskCategoryListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetTaskCategoryListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetTaskCategoryListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetTaskCategoryListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetTaskCategoryListResponse * SOAP_FMAC4 soap_in__ns3__GetTaskCategoryListResponse(struct soap *soap, const char *tag, _ns3__GetTaskCategoryListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetTaskCategoryListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetTaskCategoryListResponse, sizeof(_ns3__GetTaskCategoryListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetTaskCategoryListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetTaskCategoryListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetTaskCategoryListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetTaskCategoryListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfIdNameDTO(soap, "ns3:GetTaskCategoryListResult", &(a->_ns3__GetTaskCategoryListResponse::GetTaskCategoryListResult), "ns3:ArrayOfIdNameDTO"))
				{	soap_flag_GetTaskCategoryListResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:GetTaskCategoryListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetTaskCategoryListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetTaskCategoryListResponse, 0, sizeof(_ns3__GetTaskCategoryListResponse), 0, soap_copy__ns3__GetTaskCategoryListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetTaskCategoryListResponse * SOAP_FMAC4 soap_instantiate__ns3__GetTaskCategoryListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetTaskCategoryListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetTaskCategoryListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetTaskCategoryListResponse;
		if (size)
			*size = sizeof(_ns3__GetTaskCategoryListResponse);
		((_ns3__GetTaskCategoryListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetTaskCategoryListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetTaskCategoryListResponse);
		for (int i = 0; i < n; i++)
			((_ns3__GetTaskCategoryListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetTaskCategoryListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetTaskCategoryListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetTaskCategoryListResponse %p -> %p\n", q, p));
	*(_ns3__GetTaskCategoryListResponse*)p = *(_ns3__GetTaskCategoryListResponse*)q;
}

void _ns3__GetTaskCategoryList::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__GetTaskCategoryList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns3__GetTaskCategoryList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetTaskCategoryList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetTaskCategoryList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetTaskCategoryList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetTaskCategoryList(struct soap *soap, const char *tag, int id, const _ns3__GetTaskCategoryList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetTaskCategoryList), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetTaskCategoryList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetTaskCategoryList(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetTaskCategoryList * SOAP_FMAC4 soap_get__ns3__GetTaskCategoryList(struct soap *soap, _ns3__GetTaskCategoryList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetTaskCategoryList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetTaskCategoryList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetTaskCategoryList(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetTaskCategoryList * SOAP_FMAC4 soap_in__ns3__GetTaskCategoryList(struct soap *soap, const char *tag, _ns3__GetTaskCategoryList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetTaskCategoryList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetTaskCategoryList, sizeof(_ns3__GetTaskCategoryList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetTaskCategoryList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetTaskCategoryList *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetTaskCategoryList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetTaskCategoryList, 0, sizeof(_ns3__GetTaskCategoryList), 0, soap_copy__ns3__GetTaskCategoryList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetTaskCategoryList * SOAP_FMAC4 soap_instantiate__ns3__GetTaskCategoryList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetTaskCategoryList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetTaskCategoryList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetTaskCategoryList;
		if (size)
			*size = sizeof(_ns3__GetTaskCategoryList);
		((_ns3__GetTaskCategoryList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetTaskCategoryList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetTaskCategoryList);
		for (int i = 0; i < n; i++)
			((_ns3__GetTaskCategoryList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetTaskCategoryList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetTaskCategoryList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetTaskCategoryList %p -> %p\n", q, p));
	*(_ns3__GetTaskCategoryList*)p = *(_ns3__GetTaskCategoryList*)q;
}

void _ns3__CreateTaskResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__CreateTaskResponse::CreateTaskResult = NULL;
	/* transient soap skipped */
}

void _ns3__CreateTaskResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__TaskDTO(soap, &this->_ns3__CreateTaskResponse::CreateTaskResult);
	/* transient soap skipped */
}

int _ns3__CreateTaskResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__CreateTaskResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__CreateTaskResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__CreateTaskResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__CreateTaskResponse(struct soap *soap, const char *tag, int id, const _ns3__CreateTaskResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__CreateTaskResponse), type))
		return soap->error;
	if (a->CreateTaskResult)
		soap_element_result(soap, "ns3:CreateTaskResult");
	if (soap_out_PointerTons3__TaskDTO(soap, "ns3:CreateTaskResult", -1, &(a->_ns3__CreateTaskResponse::CreateTaskResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__CreateTaskResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__CreateTaskResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__CreateTaskResponse * SOAP_FMAC4 soap_get__ns3__CreateTaskResponse(struct soap *soap, _ns3__CreateTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__CreateTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__CreateTaskResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__CreateTaskResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__CreateTaskResponse * SOAP_FMAC4 soap_in__ns3__CreateTaskResponse(struct soap *soap, const char *tag, _ns3__CreateTaskResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__CreateTaskResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__CreateTaskResponse, sizeof(_ns3__CreateTaskResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__CreateTaskResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__CreateTaskResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CreateTaskResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CreateTaskResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__TaskDTO(soap, "ns3:CreateTaskResult", &(a->_ns3__CreateTaskResponse::CreateTaskResult), "ns3:TaskDTO"))
				{	soap_flag_CreateTaskResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:CreateTaskResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__CreateTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__CreateTaskResponse, 0, sizeof(_ns3__CreateTaskResponse), 0, soap_copy__ns3__CreateTaskResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__CreateTaskResponse * SOAP_FMAC4 soap_instantiate__ns3__CreateTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__CreateTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__CreateTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__CreateTaskResponse;
		if (size)
			*size = sizeof(_ns3__CreateTaskResponse);
		((_ns3__CreateTaskResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__CreateTaskResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__CreateTaskResponse);
		for (int i = 0; i < n; i++)
			((_ns3__CreateTaskResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__CreateTaskResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__CreateTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__CreateTaskResponse %p -> %p\n", q, p));
	*(_ns3__CreateTaskResponse*)p = *(_ns3__CreateTaskResponse*)q;
}

void _ns3__CreateTask::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__CreateTask::task = NULL;
	/* transient soap skipped */
}

void _ns3__CreateTask::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__TaskDTO(soap, &this->_ns3__CreateTask::task);
	/* transient soap skipped */
}

int _ns3__CreateTask::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__CreateTask);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__CreateTask::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__CreateTask(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__CreateTask(struct soap *soap, const char *tag, int id, const _ns3__CreateTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__CreateTask), type))
		return soap->error;
	if (soap_out_PointerTons3__TaskDTO(soap, "ns3:task", -1, &(a->_ns3__CreateTask::task), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__CreateTask::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__CreateTask(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__CreateTask * SOAP_FMAC4 soap_get__ns3__CreateTask(struct soap *soap, _ns3__CreateTask *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__CreateTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__CreateTask::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__CreateTask(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__CreateTask * SOAP_FMAC4 soap_in__ns3__CreateTask(struct soap *soap, const char *tag, _ns3__CreateTask *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__CreateTask *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__CreateTask, sizeof(_ns3__CreateTask), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__CreateTask)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__CreateTask *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_task1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_task1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__TaskDTO(soap, "ns3:task", &(a->_ns3__CreateTask::task), "ns3:TaskDTO"))
				{	soap_flag_task1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__CreateTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__CreateTask, 0, sizeof(_ns3__CreateTask), 0, soap_copy__ns3__CreateTask);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__CreateTask * SOAP_FMAC4 soap_instantiate__ns3__CreateTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__CreateTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__CreateTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__CreateTask;
		if (size)
			*size = sizeof(_ns3__CreateTask);
		((_ns3__CreateTask*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__CreateTask[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__CreateTask);
		for (int i = 0; i < n; i++)
			((_ns3__CreateTask*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__CreateTask*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__CreateTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__CreateTask %p -> %p\n", q, p));
	*(_ns3__CreateTask*)p = *(_ns3__CreateTask*)q;
}

void _ns3__GetTaskStatusListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetTaskStatusListResponse::GetTaskStatusListResult = NULL;
	/* transient soap skipped */
}

void _ns3__GetTaskStatusListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__ArrayOfIdNameDTO(soap, &this->_ns3__GetTaskStatusListResponse::GetTaskStatusListResult);
	/* transient soap skipped */
}

int _ns3__GetTaskStatusListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetTaskStatusListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetTaskStatusListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetTaskStatusListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetTaskStatusListResponse(struct soap *soap, const char *tag, int id, const _ns3__GetTaskStatusListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetTaskStatusListResponse), type))
		return soap->error;
	if (a->GetTaskStatusListResult)
		soap_element_result(soap, "ns3:GetTaskStatusListResult");
	if (soap_out_PointerTons3__ArrayOfIdNameDTO(soap, "ns3:GetTaskStatusListResult", -1, &(a->_ns3__GetTaskStatusListResponse::GetTaskStatusListResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetTaskStatusListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetTaskStatusListResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetTaskStatusListResponse * SOAP_FMAC4 soap_get__ns3__GetTaskStatusListResponse(struct soap *soap, _ns3__GetTaskStatusListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetTaskStatusListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetTaskStatusListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetTaskStatusListResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetTaskStatusListResponse * SOAP_FMAC4 soap_in__ns3__GetTaskStatusListResponse(struct soap *soap, const char *tag, _ns3__GetTaskStatusListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetTaskStatusListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetTaskStatusListResponse, sizeof(_ns3__GetTaskStatusListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetTaskStatusListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetTaskStatusListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetTaskStatusListResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetTaskStatusListResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfIdNameDTO(soap, "ns3:GetTaskStatusListResult", &(a->_ns3__GetTaskStatusListResponse::GetTaskStatusListResult), "ns3:ArrayOfIdNameDTO"))
				{	soap_flag_GetTaskStatusListResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:GetTaskStatusListResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetTaskStatusListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetTaskStatusListResponse, 0, sizeof(_ns3__GetTaskStatusListResponse), 0, soap_copy__ns3__GetTaskStatusListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetTaskStatusListResponse * SOAP_FMAC4 soap_instantiate__ns3__GetTaskStatusListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetTaskStatusListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetTaskStatusListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetTaskStatusListResponse;
		if (size)
			*size = sizeof(_ns3__GetTaskStatusListResponse);
		((_ns3__GetTaskStatusListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetTaskStatusListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetTaskStatusListResponse);
		for (int i = 0; i < n; i++)
			((_ns3__GetTaskStatusListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetTaskStatusListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetTaskStatusListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetTaskStatusListResponse %p -> %p\n", q, p));
	*(_ns3__GetTaskStatusListResponse*)p = *(_ns3__GetTaskStatusListResponse*)q;
}

void _ns3__GetTaskStatusList::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns3__GetTaskStatusList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns3__GetTaskStatusList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetTaskStatusList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetTaskStatusList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetTaskStatusList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetTaskStatusList(struct soap *soap, const char *tag, int id, const _ns3__GetTaskStatusList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetTaskStatusList), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetTaskStatusList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetTaskStatusList(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetTaskStatusList * SOAP_FMAC4 soap_get__ns3__GetTaskStatusList(struct soap *soap, _ns3__GetTaskStatusList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetTaskStatusList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetTaskStatusList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetTaskStatusList(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetTaskStatusList * SOAP_FMAC4 soap_in__ns3__GetTaskStatusList(struct soap *soap, const char *tag, _ns3__GetTaskStatusList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetTaskStatusList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetTaskStatusList, sizeof(_ns3__GetTaskStatusList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetTaskStatusList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetTaskStatusList *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetTaskStatusList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetTaskStatusList, 0, sizeof(_ns3__GetTaskStatusList), 0, soap_copy__ns3__GetTaskStatusList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetTaskStatusList * SOAP_FMAC4 soap_instantiate__ns3__GetTaskStatusList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetTaskStatusList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetTaskStatusList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetTaskStatusList;
		if (size)
			*size = sizeof(_ns3__GetTaskStatusList);
		((_ns3__GetTaskStatusList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetTaskStatusList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetTaskStatusList);
		for (int i = 0; i < n; i++)
			((_ns3__GetTaskStatusList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetTaskStatusList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetTaskStatusList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetTaskStatusList %p -> %p\n", q, p));
	*(_ns3__GetTaskStatusList*)p = *(_ns3__GetTaskStatusList*)q;
}

void _ns3__GetUsersForTitleResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetUsersForTitleResponse::GetUsersForTitleResult = NULL;
	/* transient soap skipped */
}

void _ns3__GetUsersForTitleResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__ArrayOfUserDTO(soap, &this->_ns3__GetUsersForTitleResponse::GetUsersForTitleResult);
	/* transient soap skipped */
}

int _ns3__GetUsersForTitleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetUsersForTitleResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetUsersForTitleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetUsersForTitleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetUsersForTitleResponse(struct soap *soap, const char *tag, int id, const _ns3__GetUsersForTitleResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetUsersForTitleResponse), type))
		return soap->error;
	if (a->GetUsersForTitleResult)
		soap_element_result(soap, "ns3:GetUsersForTitleResult");
	if (soap_out_PointerTons3__ArrayOfUserDTO(soap, "ns3:GetUsersForTitleResult", -1, &(a->_ns3__GetUsersForTitleResponse::GetUsersForTitleResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetUsersForTitleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetUsersForTitleResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetUsersForTitleResponse * SOAP_FMAC4 soap_get__ns3__GetUsersForTitleResponse(struct soap *soap, _ns3__GetUsersForTitleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetUsersForTitleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetUsersForTitleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetUsersForTitleResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetUsersForTitleResponse * SOAP_FMAC4 soap_in__ns3__GetUsersForTitleResponse(struct soap *soap, const char *tag, _ns3__GetUsersForTitleResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetUsersForTitleResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetUsersForTitleResponse, sizeof(_ns3__GetUsersForTitleResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetUsersForTitleResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetUsersForTitleResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetUsersForTitleResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetUsersForTitleResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfUserDTO(soap, "ns3:GetUsersForTitleResult", &(a->_ns3__GetUsersForTitleResponse::GetUsersForTitleResult), "ns3:ArrayOfUserDTO"))
				{	soap_flag_GetUsersForTitleResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns3:GetUsersForTitleResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetUsersForTitleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetUsersForTitleResponse, 0, sizeof(_ns3__GetUsersForTitleResponse), 0, soap_copy__ns3__GetUsersForTitleResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetUsersForTitleResponse * SOAP_FMAC4 soap_instantiate__ns3__GetUsersForTitleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetUsersForTitleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetUsersForTitleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetUsersForTitleResponse;
		if (size)
			*size = sizeof(_ns3__GetUsersForTitleResponse);
		((_ns3__GetUsersForTitleResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetUsersForTitleResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetUsersForTitleResponse);
		for (int i = 0; i < n; i++)
			((_ns3__GetUsersForTitleResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetUsersForTitleResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetUsersForTitleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetUsersForTitleResponse %p -> %p\n", q, p));
	*(_ns3__GetUsersForTitleResponse*)p = *(_ns3__GetUsersForTitleResponse*)q;
}

void _ns3__GetUsersForTitle::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns3__GetUsersForTitle::titleId = NULL;
	/* transient soap skipped */
}

void _ns3__GetUsersForTitle::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->_ns3__GetUsersForTitle::titleId);
	/* transient soap skipped */
}

int _ns3__GetUsersForTitle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns3__GetUsersForTitle);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns3__GetUsersForTitle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns3__GetUsersForTitle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetUsersForTitle(struct soap *soap, const char *tag, int id, const _ns3__GetUsersForTitle *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetUsersForTitle), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:titleId", -1, &(a->_ns3__GetUsersForTitle::titleId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns3__GetUsersForTitle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns3__GetUsersForTitle(soap, this, tag, type);
}

SOAP_FMAC3 _ns3__GetUsersForTitle * SOAP_FMAC4 soap_get__ns3__GetUsersForTitle(struct soap *soap, _ns3__GetUsersForTitle *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetUsersForTitle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns3__GetUsersForTitle::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns3__GetUsersForTitle(soap, tag, this, type);
}

SOAP_FMAC3 _ns3__GetUsersForTitle * SOAP_FMAC4 soap_in__ns3__GetUsersForTitle(struct soap *soap, const char *tag, _ns3__GetUsersForTitle *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns3__GetUsersForTitle *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetUsersForTitle, sizeof(_ns3__GetUsersForTitle), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns3__GetUsersForTitle)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns3__GetUsersForTitle *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_titleId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_titleId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:titleId", &(a->_ns3__GetUsersForTitle::titleId), "ns4:guid"))
				{	soap_flag_titleId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns3__GetUsersForTitle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetUsersForTitle, 0, sizeof(_ns3__GetUsersForTitle), 0, soap_copy__ns3__GetUsersForTitle);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_titleId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns3__GetUsersForTitle * SOAP_FMAC4 soap_instantiate__ns3__GetUsersForTitle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns3__GetUsersForTitle(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns3__GetUsersForTitle, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns3__GetUsersForTitle;
		if (size)
			*size = sizeof(_ns3__GetUsersForTitle);
		((_ns3__GetUsersForTitle*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns3__GetUsersForTitle[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns3__GetUsersForTitle);
		for (int i = 0; i < n; i++)
			((_ns3__GetUsersForTitle*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns3__GetUsersForTitle*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns3__GetUsersForTitle(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns3__GetUsersForTitle %p -> %p\n", q, p));
	*(_ns3__GetUsersForTitle*)p = *(_ns3__GetUsersForTitle*)q;
}

void ns3__ArrayOfLockDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__ArrayOfLockDTO::__sizeLockDTO = 0;
	this->ns3__ArrayOfLockDTO::LockDTO = NULL;
	/* transient soap skipped */
}

void ns3__ArrayOfLockDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns3__ArrayOfLockDTO::LockDTO)
	{	int i;
		for (i = 0; i < this->ns3__ArrayOfLockDTO::__sizeLockDTO; i++)
		{
			soap_serialize_PointerTons3__LockDTO(soap, this->ns3__ArrayOfLockDTO::LockDTO + i);
		}
	}
	/* transient soap skipped */
}

int ns3__ArrayOfLockDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__ArrayOfLockDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__ArrayOfLockDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfLockDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfLockDTO(struct soap *soap, const char *tag, int id, const ns3__ArrayOfLockDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ArrayOfLockDTO), type))
		return soap->error;
	if (a->ns3__ArrayOfLockDTO::LockDTO)
	{	int i;
		for (i = 0; i < a->ns3__ArrayOfLockDTO::__sizeLockDTO; i++)
			if (soap_out_PointerTons3__LockDTO(soap, "ns3:LockDTO", -1, a->ns3__ArrayOfLockDTO::LockDTO + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfLockDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfLockDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfLockDTO * SOAP_FMAC4 soap_get_ns3__ArrayOfLockDTO(struct soap *soap, ns3__ArrayOfLockDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfLockDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__ArrayOfLockDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ArrayOfLockDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfLockDTO * SOAP_FMAC4 soap_in_ns3__ArrayOfLockDTO(struct soap *soap, const char *tag, ns3__ArrayOfLockDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfLockDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ArrayOfLockDTO, sizeof(ns3__ArrayOfLockDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__ArrayOfLockDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ArrayOfLockDTO *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_LockDTO1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:LockDTO", 1, NULL))
			{	if (a->ns3__ArrayOfLockDTO::LockDTO == NULL)
				{	if (soap_blist_LockDTO1 == NULL)
						soap_blist_LockDTO1 = soap_new_block(soap);
					a->ns3__ArrayOfLockDTO::LockDTO = (ns3__LockDTO **)soap_push_block(soap, soap_blist_LockDTO1, sizeof(ns3__LockDTO *));
					if (a->ns3__ArrayOfLockDTO::LockDTO == NULL)
						return NULL;
					*a->ns3__ArrayOfLockDTO::LockDTO = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons3__LockDTO(soap, "ns3:LockDTO", a->ns3__ArrayOfLockDTO::LockDTO, "ns3:LockDTO"))
				{	a->ns3__ArrayOfLockDTO::__sizeLockDTO++;
					a->ns3__ArrayOfLockDTO::LockDTO = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__ArrayOfLockDTO::LockDTO)
			soap_pop_block(soap, soap_blist_LockDTO1);
		if (a->ns3__ArrayOfLockDTO::__sizeLockDTO)
			a->ns3__ArrayOfLockDTO::LockDTO = (ns3__LockDTO **)soap_save_block(soap, soap_blist_LockDTO1, NULL, 1);
		else
		{	a->ns3__ArrayOfLockDTO::LockDTO = NULL;
			if (soap_blist_LockDTO1)
				soap_end_block(soap, soap_blist_LockDTO1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfLockDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ArrayOfLockDTO, 0, sizeof(ns3__ArrayOfLockDTO), 0, soap_copy_ns3__ArrayOfLockDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__ArrayOfLockDTO * SOAP_FMAC4 soap_instantiate_ns3__ArrayOfLockDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfLockDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__ArrayOfLockDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__ArrayOfLockDTO;
		if (size)
			*size = sizeof(ns3__ArrayOfLockDTO);
		((ns3__ArrayOfLockDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__ArrayOfLockDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__ArrayOfLockDTO);
		for (int i = 0; i < n; i++)
			((ns3__ArrayOfLockDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__ArrayOfLockDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ArrayOfLockDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ArrayOfLockDTO %p -> %p\n", q, p));
	*(ns3__ArrayOfLockDTO*)p = *(ns3__ArrayOfLockDTO*)q;
}

void ns3__StatusDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__StatusDTO::statusId = NULL;
	this->ns3__StatusDTO::statusName = NULL;
	soap_default_bool(soap, &this->ns3__StatusDTO::layout);
	soap_default_bool(soap, &this->ns3__StatusDTO::text);
	this->ns3__StatusDTO::stateId = NULL;
	soap_default_int(soap, &this->ns3__StatusDTO::sortIndex);
	/* transient soap skipped */
}

void ns3__StatusDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->ns3__StatusDTO::statusId);
	soap_serialize_wstring(soap, &this->ns3__StatusDTO::statusName);
	soap_serialize_ns4__guid(soap, &this->ns3__StatusDTO::stateId);
	soap_embedded(soap, &this->ns3__StatusDTO::sortIndex, SOAP_TYPE_int);
	/* transient soap skipped */
}

int ns3__StatusDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__StatusDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__StatusDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__StatusDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__StatusDTO(struct soap *soap, const char *tag, int id, const ns3__StatusDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__StatusDTO), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:statusId", -1, &(a->ns3__StatusDTO::statusId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:statusName", -1, &(a->ns3__StatusDTO::statusName), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns3:layout", -1, &(a->ns3__StatusDTO::layout), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns3:text", -1, &(a->ns3__StatusDTO::text), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:stateId", -1, &(a->ns3__StatusDTO::stateId), ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:sortIndex", -1, &(a->ns3__StatusDTO::sortIndex), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__StatusDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__StatusDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__StatusDTO * SOAP_FMAC4 soap_get_ns3__StatusDTO(struct soap *soap, ns3__StatusDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__StatusDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__StatusDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__StatusDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__StatusDTO * SOAP_FMAC4 soap_in_ns3__StatusDTO(struct soap *soap, const char *tag, ns3__StatusDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__StatusDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__StatusDTO, sizeof(ns3__StatusDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__StatusDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__StatusDTO *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_statusId1 = 1;
	size_t soap_flag_statusName1 = 1;
	size_t soap_flag_layout1 = 1;
	size_t soap_flag_text1 = 1;
	size_t soap_flag_stateId1 = 1;
	size_t soap_flag_sortIndex1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:statusId", &(a->ns3__StatusDTO::statusId), "ns4:guid"))
				{	soap_flag_statusId1--;
					continue;
				}
			if (soap_flag_statusName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:statusName", &(a->ns3__StatusDTO::statusName), "xsd:string"))
				{	soap_flag_statusName1--;
					continue;
				}
			if (soap_flag_layout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns3:layout", &(a->ns3__StatusDTO::layout), "xsd:boolean"))
				{	soap_flag_layout1--;
					continue;
				}
			if (soap_flag_text1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns3:text", &(a->ns3__StatusDTO::text), "xsd:boolean"))
				{	soap_flag_text1--;
					continue;
				}
			if (soap_flag_stateId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:stateId", &(a->ns3__StatusDTO::stateId), "ns4:guid"))
				{	soap_flag_stateId1--;
					continue;
				}
			if (soap_flag_sortIndex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns3:sortIndex", &(a->ns3__StatusDTO::sortIndex), "xsd:int"))
				{	soap_flag_sortIndex1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__StatusDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__StatusDTO, 0, sizeof(ns3__StatusDTO), 0, soap_copy_ns3__StatusDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_statusId1 > 0 || soap_flag_layout1 > 0 || soap_flag_text1 > 0 || soap_flag_stateId1 > 0 || soap_flag_sortIndex1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__StatusDTO * SOAP_FMAC4 soap_instantiate_ns3__StatusDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__StatusDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__StatusDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__StatusDTO;
		if (size)
			*size = sizeof(ns3__StatusDTO);
		((ns3__StatusDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__StatusDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__StatusDTO);
		for (int i = 0; i < n; i++)
			((ns3__StatusDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__StatusDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__StatusDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__StatusDTO %p -> %p\n", q, p));
	*(ns3__StatusDTO*)p = *(ns3__StatusDTO*)q;
}

void ns3__ArrayOfStatusDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__ArrayOfStatusDTO::__sizeStatusDTO = 0;
	this->ns3__ArrayOfStatusDTO::StatusDTO = NULL;
	/* transient soap skipped */
}

void ns3__ArrayOfStatusDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns3__ArrayOfStatusDTO::StatusDTO)
	{	int i;
		for (i = 0; i < this->ns3__ArrayOfStatusDTO::__sizeStatusDTO; i++)
		{
			soap_serialize_PointerTons3__StatusDTO(soap, this->ns3__ArrayOfStatusDTO::StatusDTO + i);
		}
	}
	/* transient soap skipped */
}

int ns3__ArrayOfStatusDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__ArrayOfStatusDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__ArrayOfStatusDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfStatusDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfStatusDTO(struct soap *soap, const char *tag, int id, const ns3__ArrayOfStatusDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ArrayOfStatusDTO), type))
		return soap->error;
	if (a->ns3__ArrayOfStatusDTO::StatusDTO)
	{	int i;
		for (i = 0; i < a->ns3__ArrayOfStatusDTO::__sizeStatusDTO; i++)
			if (soap_out_PointerTons3__StatusDTO(soap, "ns3:StatusDTO", -1, a->ns3__ArrayOfStatusDTO::StatusDTO + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfStatusDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfStatusDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfStatusDTO * SOAP_FMAC4 soap_get_ns3__ArrayOfStatusDTO(struct soap *soap, ns3__ArrayOfStatusDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfStatusDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__ArrayOfStatusDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ArrayOfStatusDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfStatusDTO * SOAP_FMAC4 soap_in_ns3__ArrayOfStatusDTO(struct soap *soap, const char *tag, ns3__ArrayOfStatusDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfStatusDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ArrayOfStatusDTO, sizeof(ns3__ArrayOfStatusDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__ArrayOfStatusDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ArrayOfStatusDTO *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_StatusDTO1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:StatusDTO", 1, NULL))
			{	if (a->ns3__ArrayOfStatusDTO::StatusDTO == NULL)
				{	if (soap_blist_StatusDTO1 == NULL)
						soap_blist_StatusDTO1 = soap_new_block(soap);
					a->ns3__ArrayOfStatusDTO::StatusDTO = (ns3__StatusDTO **)soap_push_block(soap, soap_blist_StatusDTO1, sizeof(ns3__StatusDTO *));
					if (a->ns3__ArrayOfStatusDTO::StatusDTO == NULL)
						return NULL;
					*a->ns3__ArrayOfStatusDTO::StatusDTO = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons3__StatusDTO(soap, "ns3:StatusDTO", a->ns3__ArrayOfStatusDTO::StatusDTO, "ns3:StatusDTO"))
				{	a->ns3__ArrayOfStatusDTO::__sizeStatusDTO++;
					a->ns3__ArrayOfStatusDTO::StatusDTO = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__ArrayOfStatusDTO::StatusDTO)
			soap_pop_block(soap, soap_blist_StatusDTO1);
		if (a->ns3__ArrayOfStatusDTO::__sizeStatusDTO)
			a->ns3__ArrayOfStatusDTO::StatusDTO = (ns3__StatusDTO **)soap_save_block(soap, soap_blist_StatusDTO1, NULL, 1);
		else
		{	a->ns3__ArrayOfStatusDTO::StatusDTO = NULL;
			if (soap_blist_StatusDTO1)
				soap_end_block(soap, soap_blist_StatusDTO1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfStatusDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ArrayOfStatusDTO, 0, sizeof(ns3__ArrayOfStatusDTO), 0, soap_copy_ns3__ArrayOfStatusDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__ArrayOfStatusDTO * SOAP_FMAC4 soap_instantiate_ns3__ArrayOfStatusDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfStatusDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__ArrayOfStatusDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__ArrayOfStatusDTO;
		if (size)
			*size = sizeof(ns3__ArrayOfStatusDTO);
		((ns3__ArrayOfStatusDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__ArrayOfStatusDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__ArrayOfStatusDTO);
		for (int i = 0; i < n; i++)
			((ns3__ArrayOfStatusDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__ArrayOfStatusDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ArrayOfStatusDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ArrayOfStatusDTO %p -> %p\n", q, p));
	*(ns3__ArrayOfStatusDTO*)p = *(ns3__ArrayOfStatusDTO*)q;
}

void ns3__TitleStatusDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__TitleStatusDTO::titleid = NULL;
	this->ns3__TitleStatusDTO::statuses = NULL;
	/* transient soap skipped */
}

void ns3__TitleStatusDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->ns3__TitleStatusDTO::titleid);
	soap_serialize_PointerTons3__ArrayOfStatusDTO(soap, &this->ns3__TitleStatusDTO::statuses);
	/* transient soap skipped */
}

int ns3__TitleStatusDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__TitleStatusDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__TitleStatusDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TitleStatusDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TitleStatusDTO(struct soap *soap, const char *tag, int id, const ns3__TitleStatusDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TitleStatusDTO), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:titleid", -1, &(a->ns3__TitleStatusDTO::titleid), ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfStatusDTO(soap, "ns3:statuses", -1, &(a->ns3__TitleStatusDTO::statuses), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__TitleStatusDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TitleStatusDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TitleStatusDTO * SOAP_FMAC4 soap_get_ns3__TitleStatusDTO(struct soap *soap, ns3__TitleStatusDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TitleStatusDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__TitleStatusDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__TitleStatusDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TitleStatusDTO * SOAP_FMAC4 soap_in_ns3__TitleStatusDTO(struct soap *soap, const char *tag, ns3__TitleStatusDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TitleStatusDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TitleStatusDTO, sizeof(ns3__TitleStatusDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__TitleStatusDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__TitleStatusDTO *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_titleid1 = 1;
	size_t soap_flag_statuses1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_titleid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:titleid", &(a->ns3__TitleStatusDTO::titleid), "ns4:guid"))
				{	soap_flag_titleid1--;
					continue;
				}
			if (soap_flag_statuses1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfStatusDTO(soap, "ns3:statuses", &(a->ns3__TitleStatusDTO::statuses), "ns3:ArrayOfStatusDTO"))
				{	soap_flag_statuses1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__TitleStatusDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TitleStatusDTO, 0, sizeof(ns3__TitleStatusDTO), 0, soap_copy_ns3__TitleStatusDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_titleid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__TitleStatusDTO * SOAP_FMAC4 soap_instantiate_ns3__TitleStatusDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TitleStatusDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__TitleStatusDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__TitleStatusDTO;
		if (size)
			*size = sizeof(ns3__TitleStatusDTO);
		((ns3__TitleStatusDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__TitleStatusDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__TitleStatusDTO);
		for (int i = 0; i < n; i++)
			((ns3__TitleStatusDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__TitleStatusDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__TitleStatusDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__TitleStatusDTO %p -> %p\n", q, p));
	*(ns3__TitleStatusDTO*)p = *(ns3__TitleStatusDTO*)q;
}

void ns3__ArrayOfTitleStatusDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__ArrayOfTitleStatusDTO::__sizeTitleStatusDTO = 0;
	this->ns3__ArrayOfTitleStatusDTO::TitleStatusDTO = NULL;
	/* transient soap skipped */
}

void ns3__ArrayOfTitleStatusDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns3__ArrayOfTitleStatusDTO::TitleStatusDTO)
	{	int i;
		for (i = 0; i < this->ns3__ArrayOfTitleStatusDTO::__sizeTitleStatusDTO; i++)
		{
			soap_serialize_PointerTons3__TitleStatusDTO(soap, this->ns3__ArrayOfTitleStatusDTO::TitleStatusDTO + i);
		}
	}
	/* transient soap skipped */
}

int ns3__ArrayOfTitleStatusDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__ArrayOfTitleStatusDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__ArrayOfTitleStatusDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfTitleStatusDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfTitleStatusDTO(struct soap *soap, const char *tag, int id, const ns3__ArrayOfTitleStatusDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ArrayOfTitleStatusDTO), type))
		return soap->error;
	if (a->ns3__ArrayOfTitleStatusDTO::TitleStatusDTO)
	{	int i;
		for (i = 0; i < a->ns3__ArrayOfTitleStatusDTO::__sizeTitleStatusDTO; i++)
			if (soap_out_PointerTons3__TitleStatusDTO(soap, "ns3:TitleStatusDTO", -1, a->ns3__ArrayOfTitleStatusDTO::TitleStatusDTO + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfTitleStatusDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfTitleStatusDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfTitleStatusDTO * SOAP_FMAC4 soap_get_ns3__ArrayOfTitleStatusDTO(struct soap *soap, ns3__ArrayOfTitleStatusDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfTitleStatusDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__ArrayOfTitleStatusDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ArrayOfTitleStatusDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfTitleStatusDTO * SOAP_FMAC4 soap_in_ns3__ArrayOfTitleStatusDTO(struct soap *soap, const char *tag, ns3__ArrayOfTitleStatusDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfTitleStatusDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ArrayOfTitleStatusDTO, sizeof(ns3__ArrayOfTitleStatusDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__ArrayOfTitleStatusDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ArrayOfTitleStatusDTO *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_TitleStatusDTO1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:TitleStatusDTO", 1, NULL))
			{	if (a->ns3__ArrayOfTitleStatusDTO::TitleStatusDTO == NULL)
				{	if (soap_blist_TitleStatusDTO1 == NULL)
						soap_blist_TitleStatusDTO1 = soap_new_block(soap);
					a->ns3__ArrayOfTitleStatusDTO::TitleStatusDTO = (ns3__TitleStatusDTO **)soap_push_block(soap, soap_blist_TitleStatusDTO1, sizeof(ns3__TitleStatusDTO *));
					if (a->ns3__ArrayOfTitleStatusDTO::TitleStatusDTO == NULL)
						return NULL;
					*a->ns3__ArrayOfTitleStatusDTO::TitleStatusDTO = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons3__TitleStatusDTO(soap, "ns3:TitleStatusDTO", a->ns3__ArrayOfTitleStatusDTO::TitleStatusDTO, "ns3:TitleStatusDTO"))
				{	a->ns3__ArrayOfTitleStatusDTO::__sizeTitleStatusDTO++;
					a->ns3__ArrayOfTitleStatusDTO::TitleStatusDTO = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__ArrayOfTitleStatusDTO::TitleStatusDTO)
			soap_pop_block(soap, soap_blist_TitleStatusDTO1);
		if (a->ns3__ArrayOfTitleStatusDTO::__sizeTitleStatusDTO)
			a->ns3__ArrayOfTitleStatusDTO::TitleStatusDTO = (ns3__TitleStatusDTO **)soap_save_block(soap, soap_blist_TitleStatusDTO1, NULL, 1);
		else
		{	a->ns3__ArrayOfTitleStatusDTO::TitleStatusDTO = NULL;
			if (soap_blist_TitleStatusDTO1)
				soap_end_block(soap, soap_blist_TitleStatusDTO1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfTitleStatusDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ArrayOfTitleStatusDTO, 0, sizeof(ns3__ArrayOfTitleStatusDTO), 0, soap_copy_ns3__ArrayOfTitleStatusDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__ArrayOfTitleStatusDTO * SOAP_FMAC4 soap_instantiate_ns3__ArrayOfTitleStatusDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfTitleStatusDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__ArrayOfTitleStatusDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__ArrayOfTitleStatusDTO;
		if (size)
			*size = sizeof(ns3__ArrayOfTitleStatusDTO);
		((ns3__ArrayOfTitleStatusDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__ArrayOfTitleStatusDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__ArrayOfTitleStatusDTO);
		for (int i = 0; i < n; i++)
			((ns3__ArrayOfTitleStatusDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__ArrayOfTitleStatusDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ArrayOfTitleStatusDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ArrayOfTitleStatusDTO %p -> %p\n", q, p));
	*(ns3__ArrayOfTitleStatusDTO*)p = *(ns3__ArrayOfTitleStatusDTO*)q;
}

void ns3__EditionTitlesDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__EditionTitlesDTO::titleid = NULL;
	this->ns3__EditionTitlesDTO::editions = NULL;
	/* transient soap skipped */
}

void ns3__EditionTitlesDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->ns3__EditionTitlesDTO::titleid);
	soap_serialize_PointerTons3__ArrayOfShelveDTO(soap, &this->ns3__EditionTitlesDTO::editions);
	/* transient soap skipped */
}

int ns3__EditionTitlesDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__EditionTitlesDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__EditionTitlesDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__EditionTitlesDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__EditionTitlesDTO(struct soap *soap, const char *tag, int id, const ns3__EditionTitlesDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__EditionTitlesDTO), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:titleid", -1, &(a->ns3__EditionTitlesDTO::titleid), ""))
		return soap->error;
	if (soap_out_PointerTons3__ArrayOfShelveDTO(soap, "ns3:editions", -1, &(a->ns3__EditionTitlesDTO::editions), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__EditionTitlesDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__EditionTitlesDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__EditionTitlesDTO * SOAP_FMAC4 soap_get_ns3__EditionTitlesDTO(struct soap *soap, ns3__EditionTitlesDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__EditionTitlesDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__EditionTitlesDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__EditionTitlesDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__EditionTitlesDTO * SOAP_FMAC4 soap_in_ns3__EditionTitlesDTO(struct soap *soap, const char *tag, ns3__EditionTitlesDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__EditionTitlesDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__EditionTitlesDTO, sizeof(ns3__EditionTitlesDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__EditionTitlesDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__EditionTitlesDTO *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_titleid1 = 1;
	size_t soap_flag_editions1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_titleid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:titleid", &(a->ns3__EditionTitlesDTO::titleid), "ns4:guid"))
				{	soap_flag_titleid1--;
					continue;
				}
			if (soap_flag_editions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ArrayOfShelveDTO(soap, "ns3:editions", &(a->ns3__EditionTitlesDTO::editions), "ns3:ArrayOfShelveDTO"))
				{	soap_flag_editions1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__EditionTitlesDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__EditionTitlesDTO, 0, sizeof(ns3__EditionTitlesDTO), 0, soap_copy_ns3__EditionTitlesDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_titleid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__EditionTitlesDTO * SOAP_FMAC4 soap_instantiate_ns3__EditionTitlesDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__EditionTitlesDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__EditionTitlesDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__EditionTitlesDTO;
		if (size)
			*size = sizeof(ns3__EditionTitlesDTO);
		((ns3__EditionTitlesDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__EditionTitlesDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__EditionTitlesDTO);
		for (int i = 0; i < n; i++)
			((ns3__EditionTitlesDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__EditionTitlesDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__EditionTitlesDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__EditionTitlesDTO %p -> %p\n", q, p));
	*(ns3__EditionTitlesDTO*)p = *(ns3__EditionTitlesDTO*)q;
}

void ns3__ArrayOfEditionTitlesDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__ArrayOfEditionTitlesDTO::__sizeEditionTitlesDTO = 0;
	this->ns3__ArrayOfEditionTitlesDTO::EditionTitlesDTO = NULL;
	/* transient soap skipped */
}

void ns3__ArrayOfEditionTitlesDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns3__ArrayOfEditionTitlesDTO::EditionTitlesDTO)
	{	int i;
		for (i = 0; i < this->ns3__ArrayOfEditionTitlesDTO::__sizeEditionTitlesDTO; i++)
		{
			soap_serialize_PointerTons3__EditionTitlesDTO(soap, this->ns3__ArrayOfEditionTitlesDTO::EditionTitlesDTO + i);
		}
	}
	/* transient soap skipped */
}

int ns3__ArrayOfEditionTitlesDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__ArrayOfEditionTitlesDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__ArrayOfEditionTitlesDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfEditionTitlesDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfEditionTitlesDTO(struct soap *soap, const char *tag, int id, const ns3__ArrayOfEditionTitlesDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ArrayOfEditionTitlesDTO), type))
		return soap->error;
	if (a->ns3__ArrayOfEditionTitlesDTO::EditionTitlesDTO)
	{	int i;
		for (i = 0; i < a->ns3__ArrayOfEditionTitlesDTO::__sizeEditionTitlesDTO; i++)
			if (soap_out_PointerTons3__EditionTitlesDTO(soap, "ns3:EditionTitlesDTO", -1, a->ns3__ArrayOfEditionTitlesDTO::EditionTitlesDTO + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfEditionTitlesDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfEditionTitlesDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfEditionTitlesDTO * SOAP_FMAC4 soap_get_ns3__ArrayOfEditionTitlesDTO(struct soap *soap, ns3__ArrayOfEditionTitlesDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfEditionTitlesDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__ArrayOfEditionTitlesDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ArrayOfEditionTitlesDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfEditionTitlesDTO * SOAP_FMAC4 soap_in_ns3__ArrayOfEditionTitlesDTO(struct soap *soap, const char *tag, ns3__ArrayOfEditionTitlesDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfEditionTitlesDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ArrayOfEditionTitlesDTO, sizeof(ns3__ArrayOfEditionTitlesDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__ArrayOfEditionTitlesDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ArrayOfEditionTitlesDTO *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_EditionTitlesDTO1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:EditionTitlesDTO", 1, NULL))
			{	if (a->ns3__ArrayOfEditionTitlesDTO::EditionTitlesDTO == NULL)
				{	if (soap_blist_EditionTitlesDTO1 == NULL)
						soap_blist_EditionTitlesDTO1 = soap_new_block(soap);
					a->ns3__ArrayOfEditionTitlesDTO::EditionTitlesDTO = (ns3__EditionTitlesDTO **)soap_push_block(soap, soap_blist_EditionTitlesDTO1, sizeof(ns3__EditionTitlesDTO *));
					if (a->ns3__ArrayOfEditionTitlesDTO::EditionTitlesDTO == NULL)
						return NULL;
					*a->ns3__ArrayOfEditionTitlesDTO::EditionTitlesDTO = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons3__EditionTitlesDTO(soap, "ns3:EditionTitlesDTO", a->ns3__ArrayOfEditionTitlesDTO::EditionTitlesDTO, "ns3:EditionTitlesDTO"))
				{	a->ns3__ArrayOfEditionTitlesDTO::__sizeEditionTitlesDTO++;
					a->ns3__ArrayOfEditionTitlesDTO::EditionTitlesDTO = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__ArrayOfEditionTitlesDTO::EditionTitlesDTO)
			soap_pop_block(soap, soap_blist_EditionTitlesDTO1);
		if (a->ns3__ArrayOfEditionTitlesDTO::__sizeEditionTitlesDTO)
			a->ns3__ArrayOfEditionTitlesDTO::EditionTitlesDTO = (ns3__EditionTitlesDTO **)soap_save_block(soap, soap_blist_EditionTitlesDTO1, NULL, 1);
		else
		{	a->ns3__ArrayOfEditionTitlesDTO::EditionTitlesDTO = NULL;
			if (soap_blist_EditionTitlesDTO1)
				soap_end_block(soap, soap_blist_EditionTitlesDTO1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfEditionTitlesDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ArrayOfEditionTitlesDTO, 0, sizeof(ns3__ArrayOfEditionTitlesDTO), 0, soap_copy_ns3__ArrayOfEditionTitlesDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__ArrayOfEditionTitlesDTO * SOAP_FMAC4 soap_instantiate_ns3__ArrayOfEditionTitlesDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfEditionTitlesDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__ArrayOfEditionTitlesDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__ArrayOfEditionTitlesDTO;
		if (size)
			*size = sizeof(ns3__ArrayOfEditionTitlesDTO);
		((ns3__ArrayOfEditionTitlesDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__ArrayOfEditionTitlesDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__ArrayOfEditionTitlesDTO);
		for (int i = 0; i < n; i++)
			((ns3__ArrayOfEditionTitlesDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__ArrayOfEditionTitlesDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ArrayOfEditionTitlesDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ArrayOfEditionTitlesDTO %p -> %p\n", q, p));
	*(ns3__ArrayOfEditionTitlesDTO*)p = *(ns3__ArrayOfEditionTitlesDTO*)q;
}

void ns3__ArrayOfTaskDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__ArrayOfTaskDTO::__sizeTaskDTO = 0;
	this->ns3__ArrayOfTaskDTO::TaskDTO = NULL;
	/* transient soap skipped */
}

void ns3__ArrayOfTaskDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns3__ArrayOfTaskDTO::TaskDTO)
	{	int i;
		for (i = 0; i < this->ns3__ArrayOfTaskDTO::__sizeTaskDTO; i++)
		{
			soap_serialize_PointerTons3__TaskDTO(soap, this->ns3__ArrayOfTaskDTO::TaskDTO + i);
		}
	}
	/* transient soap skipped */
}

int ns3__ArrayOfTaskDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__ArrayOfTaskDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__ArrayOfTaskDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfTaskDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfTaskDTO(struct soap *soap, const char *tag, int id, const ns3__ArrayOfTaskDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ArrayOfTaskDTO), type))
		return soap->error;
	if (a->ns3__ArrayOfTaskDTO::TaskDTO)
	{	int i;
		for (i = 0; i < a->ns3__ArrayOfTaskDTO::__sizeTaskDTO; i++)
			if (soap_out_PointerTons3__TaskDTO(soap, "ns3:TaskDTO", -1, a->ns3__ArrayOfTaskDTO::TaskDTO + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfTaskDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfTaskDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfTaskDTO * SOAP_FMAC4 soap_get_ns3__ArrayOfTaskDTO(struct soap *soap, ns3__ArrayOfTaskDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfTaskDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__ArrayOfTaskDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ArrayOfTaskDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfTaskDTO * SOAP_FMAC4 soap_in_ns3__ArrayOfTaskDTO(struct soap *soap, const char *tag, ns3__ArrayOfTaskDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfTaskDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ArrayOfTaskDTO, sizeof(ns3__ArrayOfTaskDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__ArrayOfTaskDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ArrayOfTaskDTO *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_TaskDTO1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:TaskDTO", 1, NULL))
			{	if (a->ns3__ArrayOfTaskDTO::TaskDTO == NULL)
				{	if (soap_blist_TaskDTO1 == NULL)
						soap_blist_TaskDTO1 = soap_new_block(soap);
					a->ns3__ArrayOfTaskDTO::TaskDTO = (ns3__TaskDTO **)soap_push_block(soap, soap_blist_TaskDTO1, sizeof(ns3__TaskDTO *));
					if (a->ns3__ArrayOfTaskDTO::TaskDTO == NULL)
						return NULL;
					*a->ns3__ArrayOfTaskDTO::TaskDTO = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons3__TaskDTO(soap, "ns3:TaskDTO", a->ns3__ArrayOfTaskDTO::TaskDTO, "ns3:TaskDTO"))
				{	a->ns3__ArrayOfTaskDTO::__sizeTaskDTO++;
					a->ns3__ArrayOfTaskDTO::TaskDTO = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__ArrayOfTaskDTO::TaskDTO)
			soap_pop_block(soap, soap_blist_TaskDTO1);
		if (a->ns3__ArrayOfTaskDTO::__sizeTaskDTO)
			a->ns3__ArrayOfTaskDTO::TaskDTO = (ns3__TaskDTO **)soap_save_block(soap, soap_blist_TaskDTO1, NULL, 1);
		else
		{	a->ns3__ArrayOfTaskDTO::TaskDTO = NULL;
			if (soap_blist_TaskDTO1)
				soap_end_block(soap, soap_blist_TaskDTO1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfTaskDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ArrayOfTaskDTO, 0, sizeof(ns3__ArrayOfTaskDTO), 0, soap_copy_ns3__ArrayOfTaskDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__ArrayOfTaskDTO * SOAP_FMAC4 soap_instantiate_ns3__ArrayOfTaskDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfTaskDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__ArrayOfTaskDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__ArrayOfTaskDTO;
		if (size)
			*size = sizeof(ns3__ArrayOfTaskDTO);
		((ns3__ArrayOfTaskDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__ArrayOfTaskDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__ArrayOfTaskDTO);
		for (int i = 0; i < n; i++)
			((ns3__ArrayOfTaskDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__ArrayOfTaskDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ArrayOfTaskDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ArrayOfTaskDTO %p -> %p\n", q, p));
	*(ns3__ArrayOfTaskDTO*)p = *(ns3__ArrayOfTaskDTO*)q;
}

void ns3__VersionDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__VersionDTO::versionId = NULL;
	this->ns3__VersionDTO::data = NULL;
	soap_default_bool(soap, &this->ns3__VersionDTO::isCompressed);
	/* transient soap skipped */
}

void ns3__VersionDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->ns3__VersionDTO::versionId);
	soap_serialize_PointerToxsd__base64Binary(soap, &this->ns3__VersionDTO::data);
	/* transient soap skipped */
}

int ns3__VersionDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__VersionDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__VersionDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__VersionDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__VersionDTO(struct soap *soap, const char *tag, int id, const ns3__VersionDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__VersionDTO), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:versionId", -1, &(a->ns3__VersionDTO::versionId), ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "ns3:data", -1, &(a->ns3__VersionDTO::data), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns3:isCompressed", -1, &(a->ns3__VersionDTO::isCompressed), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__VersionDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__VersionDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__VersionDTO * SOAP_FMAC4 soap_get_ns3__VersionDTO(struct soap *soap, ns3__VersionDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__VersionDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__VersionDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__VersionDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__VersionDTO * SOAP_FMAC4 soap_in_ns3__VersionDTO(struct soap *soap, const char *tag, ns3__VersionDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__VersionDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__VersionDTO, sizeof(ns3__VersionDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__VersionDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__VersionDTO *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_versionId1 = 1;
	size_t soap_flag_data1 = 1;
	size_t soap_flag_isCompressed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_versionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:versionId", &(a->ns3__VersionDTO::versionId), "ns4:guid"))
				{	soap_flag_versionId1--;
					continue;
				}
			if (soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "ns3:data", &(a->ns3__VersionDTO::data), "xsd:base64Binary"))
				{	soap_flag_data1--;
					continue;
				}
			if (soap_flag_isCompressed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns3:isCompressed", &(a->ns3__VersionDTO::isCompressed), "xsd:boolean"))
				{	soap_flag_isCompressed1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__VersionDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__VersionDTO, 0, sizeof(ns3__VersionDTO), 0, soap_copy_ns3__VersionDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_versionId1 > 0 || soap_flag_isCompressed1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__VersionDTO * SOAP_FMAC4 soap_instantiate_ns3__VersionDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__VersionDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__VersionDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__VersionDTO;
		if (size)
			*size = sizeof(ns3__VersionDTO);
		((ns3__VersionDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__VersionDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__VersionDTO);
		for (int i = 0; i < n; i++)
			((ns3__VersionDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__VersionDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__VersionDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__VersionDTO %p -> %p\n", q, p));
	*(ns3__VersionDTO*)p = *(ns3__VersionDTO*)q;
}

void ns3__ArrayOfAssetDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__ArrayOfAssetDTO::__sizeAssetDTO = 0;
	this->ns3__ArrayOfAssetDTO::AssetDTO = NULL;
	/* transient soap skipped */
}

void ns3__ArrayOfAssetDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns3__ArrayOfAssetDTO::AssetDTO)
	{	int i;
		for (i = 0; i < this->ns3__ArrayOfAssetDTO::__sizeAssetDTO; i++)
		{
			soap_serialize_PointerTons3__AssetDTO(soap, this->ns3__ArrayOfAssetDTO::AssetDTO + i);
		}
	}
	/* transient soap skipped */
}

int ns3__ArrayOfAssetDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__ArrayOfAssetDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__ArrayOfAssetDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfAssetDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfAssetDTO(struct soap *soap, const char *tag, int id, const ns3__ArrayOfAssetDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ArrayOfAssetDTO), type))
		return soap->error;
	if (a->ns3__ArrayOfAssetDTO::AssetDTO)
	{	int i;
		for (i = 0; i < a->ns3__ArrayOfAssetDTO::__sizeAssetDTO; i++)
			if (soap_out_PointerTons3__AssetDTO(soap, "ns3:AssetDTO", -1, a->ns3__ArrayOfAssetDTO::AssetDTO + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfAssetDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfAssetDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfAssetDTO * SOAP_FMAC4 soap_get_ns3__ArrayOfAssetDTO(struct soap *soap, ns3__ArrayOfAssetDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfAssetDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__ArrayOfAssetDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ArrayOfAssetDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfAssetDTO * SOAP_FMAC4 soap_in_ns3__ArrayOfAssetDTO(struct soap *soap, const char *tag, ns3__ArrayOfAssetDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfAssetDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ArrayOfAssetDTO, sizeof(ns3__ArrayOfAssetDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__ArrayOfAssetDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ArrayOfAssetDTO *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_AssetDTO1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:AssetDTO", 1, NULL))
			{	if (a->ns3__ArrayOfAssetDTO::AssetDTO == NULL)
				{	if (soap_blist_AssetDTO1 == NULL)
						soap_blist_AssetDTO1 = soap_new_block(soap);
					a->ns3__ArrayOfAssetDTO::AssetDTO = (ns3__AssetDTO **)soap_push_block(soap, soap_blist_AssetDTO1, sizeof(ns3__AssetDTO *));
					if (a->ns3__ArrayOfAssetDTO::AssetDTO == NULL)
						return NULL;
					*a->ns3__ArrayOfAssetDTO::AssetDTO = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons3__AssetDTO(soap, "ns3:AssetDTO", a->ns3__ArrayOfAssetDTO::AssetDTO, "ns3:AssetDTO"))
				{	a->ns3__ArrayOfAssetDTO::__sizeAssetDTO++;
					a->ns3__ArrayOfAssetDTO::AssetDTO = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__ArrayOfAssetDTO::AssetDTO)
			soap_pop_block(soap, soap_blist_AssetDTO1);
		if (a->ns3__ArrayOfAssetDTO::__sizeAssetDTO)
			a->ns3__ArrayOfAssetDTO::AssetDTO = (ns3__AssetDTO **)soap_save_block(soap, soap_blist_AssetDTO1, NULL, 1);
		else
		{	a->ns3__ArrayOfAssetDTO::AssetDTO = NULL;
			if (soap_blist_AssetDTO1)
				soap_end_block(soap, soap_blist_AssetDTO1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfAssetDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ArrayOfAssetDTO, 0, sizeof(ns3__ArrayOfAssetDTO), 0, soap_copy_ns3__ArrayOfAssetDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__ArrayOfAssetDTO * SOAP_FMAC4 soap_instantiate_ns3__ArrayOfAssetDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfAssetDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__ArrayOfAssetDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__ArrayOfAssetDTO;
		if (size)
			*size = sizeof(ns3__ArrayOfAssetDTO);
		((ns3__ArrayOfAssetDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__ArrayOfAssetDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__ArrayOfAssetDTO);
		for (int i = 0; i < n; i++)
			((ns3__ArrayOfAssetDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__ArrayOfAssetDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ArrayOfAssetDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ArrayOfAssetDTO %p -> %p\n", q, p));
	*(ns3__ArrayOfAssetDTO*)p = *(ns3__ArrayOfAssetDTO*)q;
}

void ns3__ArrayOfGuid::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__ArrayOfGuid::__sizeguid = 0;
	this->ns3__ArrayOfGuid::guid = NULL;
	/* transient soap skipped */
}

void ns3__ArrayOfGuid::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns3__ArrayOfGuid::guid)
	{	int i;
		for (i = 0; i < this->ns3__ArrayOfGuid::__sizeguid; i++)
		{
			soap_serialize_ns4__guid(soap, this->ns3__ArrayOfGuid::guid + i);
		}
	}
	/* transient soap skipped */
}

int ns3__ArrayOfGuid::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__ArrayOfGuid);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__ArrayOfGuid::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfGuid(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfGuid(struct soap *soap, const char *tag, int id, const ns3__ArrayOfGuid *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ArrayOfGuid), type))
		return soap->error;
	if (a->ns3__ArrayOfGuid::guid)
	{	int i;
		for (i = 0; i < a->ns3__ArrayOfGuid::__sizeguid; i++)
			if (soap_out_ns4__guid(soap, "ns3:guid", -1, a->ns3__ArrayOfGuid::guid + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfGuid::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfGuid(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfGuid * SOAP_FMAC4 soap_get_ns3__ArrayOfGuid(struct soap *soap, ns3__ArrayOfGuid *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfGuid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__ArrayOfGuid::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ArrayOfGuid(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfGuid * SOAP_FMAC4 soap_in_ns3__ArrayOfGuid(struct soap *soap, const char *tag, ns3__ArrayOfGuid *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfGuid *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ArrayOfGuid, sizeof(ns3__ArrayOfGuid), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__ArrayOfGuid)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ArrayOfGuid *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_guid1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:guid", 1, NULL))
			{	if (a->ns3__ArrayOfGuid::guid == NULL)
				{	if (soap_blist_guid1 == NULL)
						soap_blist_guid1 = soap_new_block(soap);
					a->ns3__ArrayOfGuid::guid = (wchar_t **)soap_push_block(soap, soap_blist_guid1, sizeof(wchar_t *));
					if (a->ns3__ArrayOfGuid::guid == NULL)
						return NULL;
					*a->ns3__ArrayOfGuid::guid = NULL;
				}soap_revert(soap);
				if (soap_in_ns4__guid(soap, "ns3:guid", a->ns3__ArrayOfGuid::guid, "ns4:guid"))
				{	a->ns3__ArrayOfGuid::__sizeguid++;
					a->ns3__ArrayOfGuid::guid = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__ArrayOfGuid::guid)
			soap_pop_block(soap, soap_blist_guid1);
		if (a->ns3__ArrayOfGuid::__sizeguid)
			a->ns3__ArrayOfGuid::guid = (wchar_t **)soap_save_block(soap, soap_blist_guid1, NULL, 1);
		else
		{	a->ns3__ArrayOfGuid::guid = NULL;
			if (soap_blist_guid1)
				soap_end_block(soap, soap_blist_guid1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfGuid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ArrayOfGuid, 0, sizeof(ns3__ArrayOfGuid), 0, soap_copy_ns3__ArrayOfGuid);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__ArrayOfGuid * SOAP_FMAC4 soap_instantiate_ns3__ArrayOfGuid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfGuid(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__ArrayOfGuid, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__ArrayOfGuid;
		if (size)
			*size = sizeof(ns3__ArrayOfGuid);
		((ns3__ArrayOfGuid*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__ArrayOfGuid[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__ArrayOfGuid);
		for (int i = 0; i < n; i++)
			((ns3__ArrayOfGuid*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__ArrayOfGuid*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ArrayOfGuid(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ArrayOfGuid %p -> %p\n", q, p));
	*(ns3__ArrayOfGuid*)p = *(ns3__ArrayOfGuid*)q;
}

void ns3__VersionInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__VersionInfo::statusid = NULL;
	this->ns3__VersionInfo::date = NULL;
	this->ns3__VersionInfo::versionid = NULL;
	this->ns3__VersionInfo::number = NULL;
	this->ns3__VersionInfo::user = NULL;
	/* transient soap skipped */
}

void ns3__VersionInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->ns3__VersionInfo::statusid);
	soap_serialize_PointerTotime(soap, &this->ns3__VersionInfo::date);
	soap_serialize_ns4__guid(soap, &this->ns3__VersionInfo::versionid);
	soap_serialize_PointerToint(soap, &this->ns3__VersionInfo::number);
	soap_serialize_PointerTons3__UserDTO(soap, &this->ns3__VersionInfo::user);
	/* transient soap skipped */
}

int ns3__VersionInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__VersionInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__VersionInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__VersionInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__VersionInfo(struct soap *soap, const char *tag, int id, const ns3__VersionInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__VersionInfo), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:statusid", -1, &(a->ns3__VersionInfo::statusid), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns3:date", -1, &(a->ns3__VersionInfo::date), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:versionid", -1, &(a->ns3__VersionInfo::versionid), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns3:number", -1, &(a->ns3__VersionInfo::number), ""))
		return soap->error;
	if (soap_out_PointerTons3__UserDTO(soap, "ns3:user", -1, &(a->ns3__VersionInfo::user), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__VersionInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__VersionInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__VersionInfo * SOAP_FMAC4 soap_get_ns3__VersionInfo(struct soap *soap, ns3__VersionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__VersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__VersionInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__VersionInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__VersionInfo * SOAP_FMAC4 soap_in_ns3__VersionInfo(struct soap *soap, const char *tag, ns3__VersionInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__VersionInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__VersionInfo, sizeof(ns3__VersionInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__VersionInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__VersionInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_statusid1 = 1;
	size_t soap_flag_date1 = 1;
	size_t soap_flag_versionid1 = 1;
	size_t soap_flag_number1 = 1;
	size_t soap_flag_user1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:statusid", &(a->ns3__VersionInfo::statusid), "ns4:guid"))
				{	soap_flag_statusid1--;
					continue;
				}
			if (soap_flag_date1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns3:date", &(a->ns3__VersionInfo::date), "xsd:dateTime"))
				{	soap_flag_date1--;
					continue;
				}
			if (soap_flag_versionid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:versionid", &(a->ns3__VersionInfo::versionid), "ns4:guid"))
				{	soap_flag_versionid1--;
					continue;
				}
			if (soap_flag_number1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns3:number", &(a->ns3__VersionInfo::number), "xsd:int"))
				{	soap_flag_number1--;
					continue;
				}
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__UserDTO(soap, "ns3:user", &(a->ns3__VersionInfo::user), "ns3:UserDTO"))
				{	soap_flag_user1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__VersionInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__VersionInfo, 0, sizeof(ns3__VersionInfo), 0, soap_copy_ns3__VersionInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_statusid1 > 0 || soap_flag_date1 > 0 || soap_flag_versionid1 > 0 || soap_flag_number1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__VersionInfo * SOAP_FMAC4 soap_instantiate_ns3__VersionInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__VersionInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__VersionInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__VersionInfo;
		if (size)
			*size = sizeof(ns3__VersionInfo);
		((ns3__VersionInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__VersionInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__VersionInfo);
		for (int i = 0; i < n; i++)
			((ns3__VersionInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__VersionInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__VersionInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__VersionInfo %p -> %p\n", q, p));
	*(ns3__VersionInfo*)p = *(ns3__VersionInfo*)q;
}

void ns3__AssetDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__AssetDTO::assetid = NULL;
	this->ns3__AssetDTO::name = NULL;
	this->ns3__AssetDTO::documentid = NULL;
	this->ns3__AssetDTO::documentname = NULL;
	this->ns3__AssetDTO::titleid = NULL;
	this->ns3__AssetDTO::shelveid = NULL;
	this->ns3__AssetDTO::lockid = NULL;
	this->ns3__AssetDTO::typeid_ = NULL;
	this->ns3__AssetDTO::type = NULL;
	this->ns3__AssetDTO::Head = NULL;
	/* transient soap skipped */
}

void ns3__AssetDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->ns3__AssetDTO::assetid);
	soap_serialize_wstring(soap, &this->ns3__AssetDTO::name);
	soap_serialize_ns4__guid(soap, &this->ns3__AssetDTO::documentid);
	soap_serialize_wstring(soap, &this->ns3__AssetDTO::documentname);
	soap_serialize_ns4__guid(soap, &this->ns3__AssetDTO::titleid);
	soap_serialize_ns4__guid(soap, &this->ns3__AssetDTO::shelveid);
	soap_serialize_ns4__guid(soap, &this->ns3__AssetDTO::lockid);
	soap_serialize_ns4__guid(soap, &this->ns3__AssetDTO::typeid_);
	soap_serialize_wstring(soap, &this->ns3__AssetDTO::type);
	soap_serialize_PointerTons3__VersionInfo(soap, &this->ns3__AssetDTO::Head);
	/* transient soap skipped */
}

int ns3__AssetDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__AssetDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__AssetDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__AssetDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__AssetDTO(struct soap *soap, const char *tag, int id, const ns3__AssetDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__AssetDTO), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:assetid", -1, &(a->ns3__AssetDTO::assetid), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:name", -1, &(a->ns3__AssetDTO::name), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:documentid", -1, &(a->ns3__AssetDTO::documentid), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:documentname", -1, &(a->ns3__AssetDTO::documentname), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:titleid", -1, &(a->ns3__AssetDTO::titleid), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:shelveid", -1, &(a->ns3__AssetDTO::shelveid), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:lockid", -1, &(a->ns3__AssetDTO::lockid), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:typeid", -1, &(a->ns3__AssetDTO::typeid_), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:type", -1, &(a->ns3__AssetDTO::type), ""))
		return soap->error;
	if (soap_out_PointerTons3__VersionInfo(soap, "ns3:Head", -1, &(a->ns3__AssetDTO::Head), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__AssetDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__AssetDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__AssetDTO * SOAP_FMAC4 soap_get_ns3__AssetDTO(struct soap *soap, ns3__AssetDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__AssetDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__AssetDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__AssetDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__AssetDTO * SOAP_FMAC4 soap_in_ns3__AssetDTO(struct soap *soap, const char *tag, ns3__AssetDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__AssetDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__AssetDTO, sizeof(ns3__AssetDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__AssetDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__AssetDTO *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_assetid1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_documentid1 = 1;
	size_t soap_flag_documentname1 = 1;
	size_t soap_flag_titleid1 = 1;
	size_t soap_flag_shelveid1 = 1;
	size_t soap_flag_lockid1 = 1;
	size_t soap_flag_typeid_1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_Head1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assetid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:assetid", &(a->ns3__AssetDTO::assetid), "ns4:guid"))
				{	soap_flag_assetid1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:name", &(a->ns3__AssetDTO::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_documentid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:documentid", &(a->ns3__AssetDTO::documentid), "ns4:guid"))
				{	soap_flag_documentid1--;
					continue;
				}
			if (soap_flag_documentname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:documentname", &(a->ns3__AssetDTO::documentname), "xsd:string"))
				{	soap_flag_documentname1--;
					continue;
				}
			if (soap_flag_titleid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:titleid", &(a->ns3__AssetDTO::titleid), "ns4:guid"))
				{	soap_flag_titleid1--;
					continue;
				}
			if (soap_flag_shelveid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:shelveid", &(a->ns3__AssetDTO::shelveid), "ns4:guid"))
				{	soap_flag_shelveid1--;
					continue;
				}
			if (soap_flag_lockid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:lockid", &(a->ns3__AssetDTO::lockid), "ns4:guid"))
				{	soap_flag_lockid1--;
					continue;
				}
			if (soap_flag_typeid_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:typeid", &(a->ns3__AssetDTO::typeid_), "ns4:guid"))
				{	soap_flag_typeid_1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:type", &(a->ns3__AssetDTO::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_Head1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__VersionInfo(soap, "ns3:Head", &(a->ns3__AssetDTO::Head), "ns3:VersionInfo"))
				{	soap_flag_Head1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__AssetDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__AssetDTO, 0, sizeof(ns3__AssetDTO), 0, soap_copy_ns3__AssetDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_assetid1 > 0 || soap_flag_documentid1 > 0 || soap_flag_titleid1 > 0 || soap_flag_shelveid1 > 0 || soap_flag_lockid1 > 0 || soap_flag_typeid_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__AssetDTO * SOAP_FMAC4 soap_instantiate_ns3__AssetDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__AssetDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__AssetDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__AssetDTO;
		if (size)
			*size = sizeof(ns3__AssetDTO);
		((ns3__AssetDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__AssetDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__AssetDTO);
		for (int i = 0; i < n; i++)
			((ns3__AssetDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__AssetDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__AssetDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__AssetDTO %p -> %p\n", q, p));
	*(ns3__AssetDTO*)p = *(ns3__AssetDTO*)q;
}

void ns3__LockDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__LockDTO::lockid = NULL;
	this->ns3__LockDTO::applicationname = NULL;
	this->ns3__LockDTO::documentname = NULL;
	this->ns3__LockDTO::assetid = NULL;
	this->ns3__LockDTO::documentid = NULL;
	this->ns3__LockDTO::userid = NULL;
	this->ns3__LockDTO::username = NULL;
	/* transient soap skipped */
}

void ns3__LockDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->ns3__LockDTO::lockid);
	soap_serialize_wstring(soap, &this->ns3__LockDTO::applicationname);
	soap_serialize_wstring(soap, &this->ns3__LockDTO::documentname);
	soap_serialize_ns4__guid(soap, &this->ns3__LockDTO::assetid);
	soap_serialize_ns4__guid(soap, &this->ns3__LockDTO::documentid);
	soap_serialize_ns4__guid(soap, &this->ns3__LockDTO::userid);
	soap_serialize_wstring(soap, &this->ns3__LockDTO::username);
	/* transient soap skipped */
}

int ns3__LockDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__LockDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__LockDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__LockDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__LockDTO(struct soap *soap, const char *tag, int id, const ns3__LockDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__LockDTO), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:lockid", -1, &(a->ns3__LockDTO::lockid), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:applicationname", -1, &(a->ns3__LockDTO::applicationname), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:documentname", -1, &(a->ns3__LockDTO::documentname), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:assetid", -1, &(a->ns3__LockDTO::assetid), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:documentid", -1, &(a->ns3__LockDTO::documentid), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:userid", -1, &(a->ns3__LockDTO::userid), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:username", -1, &(a->ns3__LockDTO::username), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__LockDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__LockDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__LockDTO * SOAP_FMAC4 soap_get_ns3__LockDTO(struct soap *soap, ns3__LockDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__LockDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__LockDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__LockDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__LockDTO * SOAP_FMAC4 soap_in_ns3__LockDTO(struct soap *soap, const char *tag, ns3__LockDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__LockDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__LockDTO, sizeof(ns3__LockDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__LockDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__LockDTO *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lockid1 = 1;
	size_t soap_flag_applicationname1 = 1;
	size_t soap_flag_documentname1 = 1;
	size_t soap_flag_assetid1 = 1;
	size_t soap_flag_documentid1 = 1;
	size_t soap_flag_userid1 = 1;
	size_t soap_flag_username1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lockid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:lockid", &(a->ns3__LockDTO::lockid), "ns4:guid"))
				{	soap_flag_lockid1--;
					continue;
				}
			if (soap_flag_applicationname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:applicationname", &(a->ns3__LockDTO::applicationname), "xsd:string"))
				{	soap_flag_applicationname1--;
					continue;
				}
			if (soap_flag_documentname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:documentname", &(a->ns3__LockDTO::documentname), "xsd:string"))
				{	soap_flag_documentname1--;
					continue;
				}
			if (soap_flag_assetid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:assetid", &(a->ns3__LockDTO::assetid), "ns4:guid"))
				{	soap_flag_assetid1--;
					continue;
				}
			if (soap_flag_documentid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:documentid", &(a->ns3__LockDTO::documentid), "ns4:guid"))
				{	soap_flag_documentid1--;
					continue;
				}
			if (soap_flag_userid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:userid", &(a->ns3__LockDTO::userid), "ns4:guid"))
				{	soap_flag_userid1--;
					continue;
				}
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:username", &(a->ns3__LockDTO::username), "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__LockDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__LockDTO, 0, sizeof(ns3__LockDTO), 0, soap_copy_ns3__LockDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_lockid1 > 0 || soap_flag_assetid1 > 0 || soap_flag_documentid1 > 0 || soap_flag_userid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__LockDTO * SOAP_FMAC4 soap_instantiate_ns3__LockDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__LockDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__LockDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__LockDTO;
		if (size)
			*size = sizeof(ns3__LockDTO);
		((ns3__LockDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__LockDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__LockDTO);
		for (int i = 0; i < n; i++)
			((ns3__LockDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__LockDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__LockDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__LockDTO %p -> %p\n", q, p));
	*(ns3__LockDTO*)p = *(ns3__LockDTO*)q;
}

void ns3__ShelveDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__ShelveDTO::shelveid = NULL;
	this->ns3__ShelveDTO::name = NULL;
	/* transient soap skipped */
}

void ns3__ShelveDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->ns3__ShelveDTO::shelveid);
	soap_serialize_wstring(soap, &this->ns3__ShelveDTO::name);
	/* transient soap skipped */
}

int ns3__ShelveDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__ShelveDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__ShelveDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ShelveDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ShelveDTO(struct soap *soap, const char *tag, int id, const ns3__ShelveDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ShelveDTO), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:shelveid", -1, &(a->ns3__ShelveDTO::shelveid), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:name", -1, &(a->ns3__ShelveDTO::name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__ShelveDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ShelveDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ShelveDTO * SOAP_FMAC4 soap_get_ns3__ShelveDTO(struct soap *soap, ns3__ShelveDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ShelveDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__ShelveDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ShelveDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ShelveDTO * SOAP_FMAC4 soap_in_ns3__ShelveDTO(struct soap *soap, const char *tag, ns3__ShelveDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ShelveDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ShelveDTO, sizeof(ns3__ShelveDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__ShelveDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ShelveDTO *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_shelveid1 = 1;
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_shelveid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:shelveid", &(a->ns3__ShelveDTO::shelveid), "ns4:guid"))
				{	soap_flag_shelveid1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:name", &(a->ns3__ShelveDTO::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ShelveDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ShelveDTO, 0, sizeof(ns3__ShelveDTO), 0, soap_copy_ns3__ShelveDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_shelveid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__ShelveDTO * SOAP_FMAC4 soap_instantiate_ns3__ShelveDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ShelveDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__ShelveDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__ShelveDTO;
		if (size)
			*size = sizeof(ns3__ShelveDTO);
		((ns3__ShelveDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__ShelveDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__ShelveDTO);
		for (int i = 0; i < n; i++)
			((ns3__ShelveDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__ShelveDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ShelveDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ShelveDTO %p -> %p\n", q, p));
	*(ns3__ShelveDTO*)p = *(ns3__ShelveDTO*)q;
}

void ns3__ArrayOfShelveDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__ArrayOfShelveDTO::__sizeShelveDTO = 0;
	this->ns3__ArrayOfShelveDTO::ShelveDTO = NULL;
	/* transient soap skipped */
}

void ns3__ArrayOfShelveDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns3__ArrayOfShelveDTO::ShelveDTO)
	{	int i;
		for (i = 0; i < this->ns3__ArrayOfShelveDTO::__sizeShelveDTO; i++)
		{
			soap_serialize_PointerTons3__ShelveDTO(soap, this->ns3__ArrayOfShelveDTO::ShelveDTO + i);
		}
	}
	/* transient soap skipped */
}

int ns3__ArrayOfShelveDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__ArrayOfShelveDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__ArrayOfShelveDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfShelveDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfShelveDTO(struct soap *soap, const char *tag, int id, const ns3__ArrayOfShelveDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ArrayOfShelveDTO), type))
		return soap->error;
	if (a->ns3__ArrayOfShelveDTO::ShelveDTO)
	{	int i;
		for (i = 0; i < a->ns3__ArrayOfShelveDTO::__sizeShelveDTO; i++)
			if (soap_out_PointerTons3__ShelveDTO(soap, "ns3:ShelveDTO", -1, a->ns3__ArrayOfShelveDTO::ShelveDTO + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfShelveDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfShelveDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfShelveDTO * SOAP_FMAC4 soap_get_ns3__ArrayOfShelveDTO(struct soap *soap, ns3__ArrayOfShelveDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfShelveDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__ArrayOfShelveDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ArrayOfShelveDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfShelveDTO * SOAP_FMAC4 soap_in_ns3__ArrayOfShelveDTO(struct soap *soap, const char *tag, ns3__ArrayOfShelveDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfShelveDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ArrayOfShelveDTO, sizeof(ns3__ArrayOfShelveDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__ArrayOfShelveDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ArrayOfShelveDTO *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_ShelveDTO1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:ShelveDTO", 1, NULL))
			{	if (a->ns3__ArrayOfShelveDTO::ShelveDTO == NULL)
				{	if (soap_blist_ShelveDTO1 == NULL)
						soap_blist_ShelveDTO1 = soap_new_block(soap);
					a->ns3__ArrayOfShelveDTO::ShelveDTO = (ns3__ShelveDTO **)soap_push_block(soap, soap_blist_ShelveDTO1, sizeof(ns3__ShelveDTO *));
					if (a->ns3__ArrayOfShelveDTO::ShelveDTO == NULL)
						return NULL;
					*a->ns3__ArrayOfShelveDTO::ShelveDTO = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons3__ShelveDTO(soap, "ns3:ShelveDTO", a->ns3__ArrayOfShelveDTO::ShelveDTO, "ns3:ShelveDTO"))
				{	a->ns3__ArrayOfShelveDTO::__sizeShelveDTO++;
					a->ns3__ArrayOfShelveDTO::ShelveDTO = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__ArrayOfShelveDTO::ShelveDTO)
			soap_pop_block(soap, soap_blist_ShelveDTO1);
		if (a->ns3__ArrayOfShelveDTO::__sizeShelveDTO)
			a->ns3__ArrayOfShelveDTO::ShelveDTO = (ns3__ShelveDTO **)soap_save_block(soap, soap_blist_ShelveDTO1, NULL, 1);
		else
		{	a->ns3__ArrayOfShelveDTO::ShelveDTO = NULL;
			if (soap_blist_ShelveDTO1)
				soap_end_block(soap, soap_blist_ShelveDTO1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfShelveDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ArrayOfShelveDTO, 0, sizeof(ns3__ArrayOfShelveDTO), 0, soap_copy_ns3__ArrayOfShelveDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__ArrayOfShelveDTO * SOAP_FMAC4 soap_instantiate_ns3__ArrayOfShelveDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfShelveDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__ArrayOfShelveDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__ArrayOfShelveDTO;
		if (size)
			*size = sizeof(ns3__ArrayOfShelveDTO);
		((ns3__ArrayOfShelveDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__ArrayOfShelveDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__ArrayOfShelveDTO);
		for (int i = 0; i < n; i++)
			((ns3__ArrayOfShelveDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__ArrayOfShelveDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ArrayOfShelveDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ArrayOfShelveDTO %p -> %p\n", q, p));
	*(ns3__ArrayOfShelveDTO*)p = *(ns3__ArrayOfShelveDTO*)q;
}

void ns3__ArrayOfString::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__ArrayOfString::__sizestring = 0;
	this->ns3__ArrayOfString::string = NULL;
	/* transient soap skipped */
}

void ns3__ArrayOfString::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns3__ArrayOfString::string)
	{	int i;
		for (i = 0; i < this->ns3__ArrayOfString::__sizestring; i++)
		{
			soap_serialize_wstring(soap, this->ns3__ArrayOfString::string + i);
		}
	}
	/* transient soap skipped */
}

int ns3__ArrayOfString::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__ArrayOfString);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__ArrayOfString::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfString(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfString(struct soap *soap, const char *tag, int id, const ns3__ArrayOfString *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ArrayOfString), type))
		return soap->error;
	if (a->ns3__ArrayOfString::string)
	{	int i;
		for (i = 0; i < a->ns3__ArrayOfString::__sizestring; i++)
			if (soap_out_wstring(soap, "ns3:string", -1, a->ns3__ArrayOfString::string + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfString::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfString(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfString * SOAP_FMAC4 soap_get_ns3__ArrayOfString(struct soap *soap, ns3__ArrayOfString *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__ArrayOfString::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ArrayOfString(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfString * SOAP_FMAC4 soap_in_ns3__ArrayOfString(struct soap *soap, const char *tag, ns3__ArrayOfString *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfString *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ArrayOfString, sizeof(ns3__ArrayOfString), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__ArrayOfString)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ArrayOfString *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_string1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:string", 1, NULL))
			{	if (a->ns3__ArrayOfString::string == NULL)
				{	if (soap_blist_string1 == NULL)
						soap_blist_string1 = soap_new_block(soap);
					a->ns3__ArrayOfString::string = (wchar_t **)soap_push_block(soap, soap_blist_string1, sizeof(wchar_t *));
					if (a->ns3__ArrayOfString::string == NULL)
						return NULL;
					*a->ns3__ArrayOfString::string = NULL;
				}soap_revert(soap);
				if (soap_in_wstring(soap, "ns3:string", a->ns3__ArrayOfString::string, "xsd:string"))
				{	a->ns3__ArrayOfString::__sizestring++;
					a->ns3__ArrayOfString::string = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__ArrayOfString::string)
			soap_pop_block(soap, soap_blist_string1);
		if (a->ns3__ArrayOfString::__sizestring)
			a->ns3__ArrayOfString::string = (wchar_t **)soap_save_block(soap, soap_blist_string1, NULL, 1);
		else
		{	a->ns3__ArrayOfString::string = NULL;
			if (soap_blist_string1)
				soap_end_block(soap, soap_blist_string1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfString *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ArrayOfString, 0, sizeof(ns3__ArrayOfString), 0, soap_copy_ns3__ArrayOfString);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__ArrayOfString * SOAP_FMAC4 soap_instantiate_ns3__ArrayOfString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfString(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__ArrayOfString, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__ArrayOfString;
		if (size)
			*size = sizeof(ns3__ArrayOfString);
		((ns3__ArrayOfString*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__ArrayOfString[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__ArrayOfString);
		for (int i = 0; i < n; i++)
			((ns3__ArrayOfString*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__ArrayOfString*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ArrayOfString(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ArrayOfString %p -> %p\n", q, p));
	*(ns3__ArrayOfString*)p = *(ns3__ArrayOfString*)q;
}

void ns3__CommentDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__CommentDTO::assetid = NULL;
	this->ns3__CommentDTO::name = NULL;
	this->ns3__CommentDTO::comment = NULL;
	this->ns3__CommentDTO::statusid = NULL;
	this->ns3__CommentDTO::status = NULL;
	this->ns3__CommentDTO::userid = NULL;
	this->ns3__CommentDTO::username = NULL;
	this->ns3__CommentDTO::date = NULL;
	this->ns3__CommentDTO::versionid = NULL;
	this->ns3__CommentDTO::number = NULL;
	/* transient soap skipped */
}

void ns3__CommentDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->ns3__CommentDTO::assetid);
	soap_serialize_wstring(soap, &this->ns3__CommentDTO::name);
	soap_serialize_wstring(soap, &this->ns3__CommentDTO::comment);
	soap_serialize_ns4__guid(soap, &this->ns3__CommentDTO::statusid);
	soap_serialize_wstring(soap, &this->ns3__CommentDTO::status);
	soap_serialize_ns4__guid(soap, &this->ns3__CommentDTO::userid);
	soap_serialize_wstring(soap, &this->ns3__CommentDTO::username);
	soap_serialize_PointerTotime(soap, &this->ns3__CommentDTO::date);
	soap_serialize_ns4__guid(soap, &this->ns3__CommentDTO::versionid);
	soap_serialize_PointerToint(soap, &this->ns3__CommentDTO::number);
	/* transient soap skipped */
}

int ns3__CommentDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__CommentDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__CommentDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__CommentDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__CommentDTO(struct soap *soap, const char *tag, int id, const ns3__CommentDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__CommentDTO), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:assetid", -1, &(a->ns3__CommentDTO::assetid), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:name", -1, &(a->ns3__CommentDTO::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:comment", -1, &(a->ns3__CommentDTO::comment), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:statusid", -1, &(a->ns3__CommentDTO::statusid), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:status", -1, &(a->ns3__CommentDTO::status), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:userid", -1, &(a->ns3__CommentDTO::userid), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:username", -1, &(a->ns3__CommentDTO::username), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns3:date", -1, &(a->ns3__CommentDTO::date), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:versionid", -1, &(a->ns3__CommentDTO::versionid), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns3:number", -1, &(a->ns3__CommentDTO::number), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__CommentDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__CommentDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__CommentDTO * SOAP_FMAC4 soap_get_ns3__CommentDTO(struct soap *soap, ns3__CommentDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__CommentDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__CommentDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__CommentDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__CommentDTO * SOAP_FMAC4 soap_in_ns3__CommentDTO(struct soap *soap, const char *tag, ns3__CommentDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__CommentDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__CommentDTO, sizeof(ns3__CommentDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__CommentDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__CommentDTO *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_assetid1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_comment1 = 1;
	size_t soap_flag_statusid1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_userid1 = 1;
	size_t soap_flag_username1 = 1;
	size_t soap_flag_date1 = 1;
	size_t soap_flag_versionid1 = 1;
	size_t soap_flag_number1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_assetid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:assetid", &(a->ns3__CommentDTO::assetid), "ns4:guid"))
				{	soap_flag_assetid1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:name", &(a->ns3__CommentDTO::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:comment", &(a->ns3__CommentDTO::comment), "xsd:string"))
				{	soap_flag_comment1--;
					continue;
				}
			if (soap_flag_statusid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:statusid", &(a->ns3__CommentDTO::statusid), "ns4:guid"))
				{	soap_flag_statusid1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:status", &(a->ns3__CommentDTO::status), "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_userid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:userid", &(a->ns3__CommentDTO::userid), "ns4:guid"))
				{	soap_flag_userid1--;
					continue;
				}
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:username", &(a->ns3__CommentDTO::username), "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			if (soap_flag_date1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns3:date", &(a->ns3__CommentDTO::date), "xsd:dateTime"))
				{	soap_flag_date1--;
					continue;
				}
			if (soap_flag_versionid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:versionid", &(a->ns3__CommentDTO::versionid), "ns4:guid"))
				{	soap_flag_versionid1--;
					continue;
				}
			if (soap_flag_number1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns3:number", &(a->ns3__CommentDTO::number), "xsd:int"))
				{	soap_flag_number1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__CommentDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__CommentDTO, 0, sizeof(ns3__CommentDTO), 0, soap_copy_ns3__CommentDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_assetid1 > 0 || soap_flag_statusid1 > 0 || soap_flag_userid1 > 0 || soap_flag_date1 > 0 || soap_flag_versionid1 > 0 || soap_flag_number1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__CommentDTO * SOAP_FMAC4 soap_instantiate_ns3__CommentDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__CommentDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__CommentDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__CommentDTO;
		if (size)
			*size = sizeof(ns3__CommentDTO);
		((ns3__CommentDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__CommentDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__CommentDTO);
		for (int i = 0; i < n; i++)
			((ns3__CommentDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__CommentDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__CommentDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__CommentDTO %p -> %p\n", q, p));
	*(ns3__CommentDTO*)p = *(ns3__CommentDTO*)q;
}

void ns3__ArrayOfCommentDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__ArrayOfCommentDTO::__sizeCommentDTO = 0;
	this->ns3__ArrayOfCommentDTO::CommentDTO = NULL;
	/* transient soap skipped */
}

void ns3__ArrayOfCommentDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns3__ArrayOfCommentDTO::CommentDTO)
	{	int i;
		for (i = 0; i < this->ns3__ArrayOfCommentDTO::__sizeCommentDTO; i++)
		{
			soap_serialize_PointerTons3__CommentDTO(soap, this->ns3__ArrayOfCommentDTO::CommentDTO + i);
		}
	}
	/* transient soap skipped */
}

int ns3__ArrayOfCommentDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__ArrayOfCommentDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__ArrayOfCommentDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfCommentDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfCommentDTO(struct soap *soap, const char *tag, int id, const ns3__ArrayOfCommentDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ArrayOfCommentDTO), type))
		return soap->error;
	if (a->ns3__ArrayOfCommentDTO::CommentDTO)
	{	int i;
		for (i = 0; i < a->ns3__ArrayOfCommentDTO::__sizeCommentDTO; i++)
			if (soap_out_PointerTons3__CommentDTO(soap, "ns3:CommentDTO", -1, a->ns3__ArrayOfCommentDTO::CommentDTO + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfCommentDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfCommentDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfCommentDTO * SOAP_FMAC4 soap_get_ns3__ArrayOfCommentDTO(struct soap *soap, ns3__ArrayOfCommentDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfCommentDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__ArrayOfCommentDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ArrayOfCommentDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfCommentDTO * SOAP_FMAC4 soap_in_ns3__ArrayOfCommentDTO(struct soap *soap, const char *tag, ns3__ArrayOfCommentDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfCommentDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ArrayOfCommentDTO, sizeof(ns3__ArrayOfCommentDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__ArrayOfCommentDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ArrayOfCommentDTO *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_CommentDTO1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:CommentDTO", 1, NULL))
			{	if (a->ns3__ArrayOfCommentDTO::CommentDTO == NULL)
				{	if (soap_blist_CommentDTO1 == NULL)
						soap_blist_CommentDTO1 = soap_new_block(soap);
					a->ns3__ArrayOfCommentDTO::CommentDTO = (ns3__CommentDTO **)soap_push_block(soap, soap_blist_CommentDTO1, sizeof(ns3__CommentDTO *));
					if (a->ns3__ArrayOfCommentDTO::CommentDTO == NULL)
						return NULL;
					*a->ns3__ArrayOfCommentDTO::CommentDTO = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons3__CommentDTO(soap, "ns3:CommentDTO", a->ns3__ArrayOfCommentDTO::CommentDTO, "ns3:CommentDTO"))
				{	a->ns3__ArrayOfCommentDTO::__sizeCommentDTO++;
					a->ns3__ArrayOfCommentDTO::CommentDTO = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__ArrayOfCommentDTO::CommentDTO)
			soap_pop_block(soap, soap_blist_CommentDTO1);
		if (a->ns3__ArrayOfCommentDTO::__sizeCommentDTO)
			a->ns3__ArrayOfCommentDTO::CommentDTO = (ns3__CommentDTO **)soap_save_block(soap, soap_blist_CommentDTO1, NULL, 1);
		else
		{	a->ns3__ArrayOfCommentDTO::CommentDTO = NULL;
			if (soap_blist_CommentDTO1)
				soap_end_block(soap, soap_blist_CommentDTO1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfCommentDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ArrayOfCommentDTO, 0, sizeof(ns3__ArrayOfCommentDTO), 0, soap_copy_ns3__ArrayOfCommentDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__ArrayOfCommentDTO * SOAP_FMAC4 soap_instantiate_ns3__ArrayOfCommentDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfCommentDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__ArrayOfCommentDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__ArrayOfCommentDTO;
		if (size)
			*size = sizeof(ns3__ArrayOfCommentDTO);
		((ns3__ArrayOfCommentDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__ArrayOfCommentDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__ArrayOfCommentDTO);
		for (int i = 0; i < n; i++)
			((ns3__ArrayOfCommentDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__ArrayOfCommentDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ArrayOfCommentDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ArrayOfCommentDTO %p -> %p\n", q, p));
	*(ns3__ArrayOfCommentDTO*)p = *(ns3__ArrayOfCommentDTO*)q;
}

void ns3__ConstantDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__ConstantDTO::constantid = NULL;
	this->ns3__ConstantDTO::name = NULL;
	/* transient soap skipped */
}

void ns3__ConstantDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->ns3__ConstantDTO::constantid);
	soap_serialize_wstring(soap, &this->ns3__ConstantDTO::name);
	/* transient soap skipped */
}

int ns3__ConstantDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__ConstantDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__ConstantDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ConstantDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ConstantDTO(struct soap *soap, const char *tag, int id, const ns3__ConstantDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ConstantDTO), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:constantid", -1, &(a->ns3__ConstantDTO::constantid), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:name", -1, &(a->ns3__ConstantDTO::name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__ConstantDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ConstantDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ConstantDTO * SOAP_FMAC4 soap_get_ns3__ConstantDTO(struct soap *soap, ns3__ConstantDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ConstantDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__ConstantDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ConstantDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ConstantDTO * SOAP_FMAC4 soap_in_ns3__ConstantDTO(struct soap *soap, const char *tag, ns3__ConstantDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ConstantDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ConstantDTO, sizeof(ns3__ConstantDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__ConstantDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ConstantDTO *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_constantid1 = 1;
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_constantid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:constantid", &(a->ns3__ConstantDTO::constantid), "ns4:guid"))
				{	soap_flag_constantid1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:name", &(a->ns3__ConstantDTO::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ConstantDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ConstantDTO, 0, sizeof(ns3__ConstantDTO), 0, soap_copy_ns3__ConstantDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_constantid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__ConstantDTO * SOAP_FMAC4 soap_instantiate_ns3__ConstantDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ConstantDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__ConstantDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns3:TitleDTO"))
	{	cp->type = SOAP_TYPE_ns3__TitleDTO;
		if (n < 0)
		{	cp->ptr = (void*)new ns3__TitleDTO;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns3__TitleDTO);
			((ns3__TitleDTO*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns3__TitleDTO[n];
			if (size)
				*size = n * sizeof(ns3__TitleDTO);
			for (int i = 0; i < n; i++)
				((ns3__TitleDTO*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns3__TitleDTO*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns3__ConstantDTO;
		if (size)
			*size = sizeof(ns3__ConstantDTO);
		((ns3__ConstantDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__ConstantDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__ConstantDTO);
		for (int i = 0; i < n; i++)
			((ns3__ConstantDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__ConstantDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ConstantDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ConstantDTO %p -> %p\n", q, p));
	*(ns3__ConstantDTO*)p = *(ns3__ConstantDTO*)q;
}

void ns3__TitleDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__ConstantDTO::constantid = NULL;
	this->ns3__ConstantDTO::name = NULL;
	/* transient soap skipped */
}

void ns3__TitleDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->ns3__ConstantDTO::constantid);
	soap_serialize_wstring(soap, &this->ns3__ConstantDTO::name);
	/* transient soap skipped */
}

int ns3__TitleDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__TitleDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__TitleDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TitleDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TitleDTO(struct soap *soap, const char *tag, int id, const ns3__TitleDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TitleDTO), "ns3:TitleDTO"))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:constantid", -1, &(a->ns3__ConstantDTO::constantid), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:name", -1, &(a->ns3__ConstantDTO::name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__TitleDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TitleDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TitleDTO * SOAP_FMAC4 soap_get_ns3__TitleDTO(struct soap *soap, ns3__TitleDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TitleDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__TitleDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__TitleDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TitleDTO * SOAP_FMAC4 soap_in_ns3__TitleDTO(struct soap *soap, const char *tag, ns3__TitleDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TitleDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TitleDTO, sizeof(ns3__TitleDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__TitleDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__TitleDTO *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_constantid2 = 1;
	size_t soap_flag_name2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_constantid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:constantid", &(a->ns3__ConstantDTO::constantid), "ns4:guid"))
				{	soap_flag_constantid2--;
					continue;
				}
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:name", &(a->ns3__ConstantDTO::name), "xsd:string"))
				{	soap_flag_name2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__TitleDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TitleDTO, 0, sizeof(ns3__TitleDTO), 0, soap_copy_ns3__TitleDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_constantid2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__TitleDTO * SOAP_FMAC4 soap_instantiate_ns3__TitleDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TitleDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__TitleDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__TitleDTO;
		if (size)
			*size = sizeof(ns3__TitleDTO);
		((ns3__TitleDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__TitleDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__TitleDTO);
		for (int i = 0; i < n; i++)
			((ns3__TitleDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__TitleDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__TitleDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__TitleDTO %p -> %p\n", q, p));
	*(ns3__TitleDTO*)p = *(ns3__TitleDTO*)q;
}

void ns3__ArrayOfTitleDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__ArrayOfTitleDTO::__sizeTitleDTO = 0;
	this->ns3__ArrayOfTitleDTO::TitleDTO = NULL;
	/* transient soap skipped */
}

void ns3__ArrayOfTitleDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns3__ArrayOfTitleDTO::TitleDTO)
	{	int i;
		for (i = 0; i < this->ns3__ArrayOfTitleDTO::__sizeTitleDTO; i++)
		{
			soap_serialize_PointerTons3__TitleDTO(soap, this->ns3__ArrayOfTitleDTO::TitleDTO + i);
		}
	}
	/* transient soap skipped */
}

int ns3__ArrayOfTitleDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__ArrayOfTitleDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__ArrayOfTitleDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfTitleDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfTitleDTO(struct soap *soap, const char *tag, int id, const ns3__ArrayOfTitleDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ArrayOfTitleDTO), type))
		return soap->error;
	if (a->ns3__ArrayOfTitleDTO::TitleDTO)
	{	int i;
		for (i = 0; i < a->ns3__ArrayOfTitleDTO::__sizeTitleDTO; i++)
			if (soap_out_PointerTons3__TitleDTO(soap, "ns3:TitleDTO", -1, a->ns3__ArrayOfTitleDTO::TitleDTO + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfTitleDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfTitleDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfTitleDTO * SOAP_FMAC4 soap_get_ns3__ArrayOfTitleDTO(struct soap *soap, ns3__ArrayOfTitleDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfTitleDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__ArrayOfTitleDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ArrayOfTitleDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfTitleDTO * SOAP_FMAC4 soap_in_ns3__ArrayOfTitleDTO(struct soap *soap, const char *tag, ns3__ArrayOfTitleDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfTitleDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ArrayOfTitleDTO, sizeof(ns3__ArrayOfTitleDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__ArrayOfTitleDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ArrayOfTitleDTO *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_TitleDTO1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:TitleDTO", 1, NULL))
			{	if (a->ns3__ArrayOfTitleDTO::TitleDTO == NULL)
				{	if (soap_blist_TitleDTO1 == NULL)
						soap_blist_TitleDTO1 = soap_new_block(soap);
					a->ns3__ArrayOfTitleDTO::TitleDTO = (ns3__TitleDTO **)soap_push_block(soap, soap_blist_TitleDTO1, sizeof(ns3__TitleDTO *));
					if (a->ns3__ArrayOfTitleDTO::TitleDTO == NULL)
						return NULL;
					*a->ns3__ArrayOfTitleDTO::TitleDTO = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons3__TitleDTO(soap, "ns3:TitleDTO", a->ns3__ArrayOfTitleDTO::TitleDTO, "ns3:TitleDTO"))
				{	a->ns3__ArrayOfTitleDTO::__sizeTitleDTO++;
					a->ns3__ArrayOfTitleDTO::TitleDTO = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__ArrayOfTitleDTO::TitleDTO)
			soap_pop_block(soap, soap_blist_TitleDTO1);
		if (a->ns3__ArrayOfTitleDTO::__sizeTitleDTO)
			a->ns3__ArrayOfTitleDTO::TitleDTO = (ns3__TitleDTO **)soap_save_block(soap, soap_blist_TitleDTO1, NULL, 1);
		else
		{	a->ns3__ArrayOfTitleDTO::TitleDTO = NULL;
			if (soap_blist_TitleDTO1)
				soap_end_block(soap, soap_blist_TitleDTO1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfTitleDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ArrayOfTitleDTO, 0, sizeof(ns3__ArrayOfTitleDTO), 0, soap_copy_ns3__ArrayOfTitleDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__ArrayOfTitleDTO * SOAP_FMAC4 soap_instantiate_ns3__ArrayOfTitleDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfTitleDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__ArrayOfTitleDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__ArrayOfTitleDTO;
		if (size)
			*size = sizeof(ns3__ArrayOfTitleDTO);
		((ns3__ArrayOfTitleDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__ArrayOfTitleDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__ArrayOfTitleDTO);
		for (int i = 0; i < n; i++)
			((ns3__ArrayOfTitleDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__ArrayOfTitleDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ArrayOfTitleDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ArrayOfTitleDTO %p -> %p\n", q, p));
	*(ns3__ArrayOfTitleDTO*)p = *(ns3__ArrayOfTitleDTO*)q;
}

void ns3__TaskUpdateInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->ns3__TaskUpdateInfo::CreationDate);
	this->ns3__TaskUpdateInfo::createdByUserid = NULL;
	this->ns3__TaskUpdateInfo::lastModifiedUserId = NULL;
	this->ns3__TaskUpdateInfo::lastModifiedDate = NULL;
	this->ns3__TaskUpdateInfo::assigntoUserName = NULL;
	this->ns3__TaskUpdateInfo::createdByUserName = NULL;
	this->ns3__TaskUpdateInfo::lastModifiedUserName = NULL;
	/* transient soap skipped */
}

void ns3__TaskUpdateInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns3__TaskUpdateInfo::CreationDate, SOAP_TYPE_time);
	soap_serialize_ns4__guid(soap, &this->ns3__TaskUpdateInfo::createdByUserid);
	soap_serialize_ns4__guid(soap, &this->ns3__TaskUpdateInfo::lastModifiedUserId);
	soap_serialize_PointerTotime(soap, &this->ns3__TaskUpdateInfo::lastModifiedDate);
	soap_serialize_wstring(soap, &this->ns3__TaskUpdateInfo::assigntoUserName);
	soap_serialize_wstring(soap, &this->ns3__TaskUpdateInfo::createdByUserName);
	soap_serialize_wstring(soap, &this->ns3__TaskUpdateInfo::lastModifiedUserName);
	/* transient soap skipped */
}

int ns3__TaskUpdateInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__TaskUpdateInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__TaskUpdateInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TaskUpdateInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TaskUpdateInfo(struct soap *soap, const char *tag, int id, const ns3__TaskUpdateInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TaskUpdateInfo), type))
		return soap->error;
	if (soap_out_time(soap, "ns3:CreationDate", -1, &(a->ns3__TaskUpdateInfo::CreationDate), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:createdByUserid", -1, &(a->ns3__TaskUpdateInfo::createdByUserid), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:lastModifiedUserId", -1, &(a->ns3__TaskUpdateInfo::lastModifiedUserId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns3:lastModifiedDate", -1, &(a->ns3__TaskUpdateInfo::lastModifiedDate), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:assigntoUserName", -1, &(a->ns3__TaskUpdateInfo::assigntoUserName), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:createdByUserName", -1, &(a->ns3__TaskUpdateInfo::createdByUserName), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:lastModifiedUserName", -1, &(a->ns3__TaskUpdateInfo::lastModifiedUserName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__TaskUpdateInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TaskUpdateInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TaskUpdateInfo * SOAP_FMAC4 soap_get_ns3__TaskUpdateInfo(struct soap *soap, ns3__TaskUpdateInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TaskUpdateInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__TaskUpdateInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__TaskUpdateInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TaskUpdateInfo * SOAP_FMAC4 soap_in_ns3__TaskUpdateInfo(struct soap *soap, const char *tag, ns3__TaskUpdateInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TaskUpdateInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TaskUpdateInfo, sizeof(ns3__TaskUpdateInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__TaskUpdateInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__TaskUpdateInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CreationDate1 = 1;
	size_t soap_flag_createdByUserid1 = 1;
	size_t soap_flag_lastModifiedUserId1 = 1;
	size_t soap_flag_lastModifiedDate1 = 1;
	size_t soap_flag_assigntoUserName1 = 1;
	size_t soap_flag_createdByUserName1 = 1;
	size_t soap_flag_lastModifiedUserName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CreationDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns3:CreationDate", &(a->ns3__TaskUpdateInfo::CreationDate), "xsd:dateTime"))
				{	soap_flag_CreationDate1--;
					continue;
				}
			if (soap_flag_createdByUserid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:createdByUserid", &(a->ns3__TaskUpdateInfo::createdByUserid), "ns4:guid"))
				{	soap_flag_createdByUserid1--;
					continue;
				}
			if (soap_flag_lastModifiedUserId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:lastModifiedUserId", &(a->ns3__TaskUpdateInfo::lastModifiedUserId), "ns4:guid"))
				{	soap_flag_lastModifiedUserId1--;
					continue;
				}
			if (soap_flag_lastModifiedDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns3:lastModifiedDate", &(a->ns3__TaskUpdateInfo::lastModifiedDate), "xsd:dateTime"))
				{	soap_flag_lastModifiedDate1--;
					continue;
				}
			if (soap_flag_assigntoUserName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:assigntoUserName", &(a->ns3__TaskUpdateInfo::assigntoUserName), "xsd:string"))
				{	soap_flag_assigntoUserName1--;
					continue;
				}
			if (soap_flag_createdByUserName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:createdByUserName", &(a->ns3__TaskUpdateInfo::createdByUserName), "xsd:string"))
				{	soap_flag_createdByUserName1--;
					continue;
				}
			if (soap_flag_lastModifiedUserName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:lastModifiedUserName", &(a->ns3__TaskUpdateInfo::lastModifiedUserName), "xsd:string"))
				{	soap_flag_lastModifiedUserName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__TaskUpdateInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TaskUpdateInfo, 0, sizeof(ns3__TaskUpdateInfo), 0, soap_copy_ns3__TaskUpdateInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_CreationDate1 > 0 || soap_flag_createdByUserid1 > 0 || soap_flag_lastModifiedUserId1 > 0 || soap_flag_lastModifiedDate1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__TaskUpdateInfo * SOAP_FMAC4 soap_instantiate_ns3__TaskUpdateInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TaskUpdateInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__TaskUpdateInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__TaskUpdateInfo;
		if (size)
			*size = sizeof(ns3__TaskUpdateInfo);
		((ns3__TaskUpdateInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__TaskUpdateInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__TaskUpdateInfo);
		for (int i = 0; i < n; i++)
			((ns3__TaskUpdateInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__TaskUpdateInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__TaskUpdateInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__TaskUpdateInfo %p -> %p\n", q, p));
	*(ns3__TaskUpdateInfo*)p = *(ns3__TaskUpdateInfo*)q;
}

void ns3__TaskDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__TaskDTO::taskid = NULL;
	this->ns3__TaskDTO::assetid = NULL;
	this->ns3__TaskDTO::subject = NULL;
	this->ns3__TaskDTO::description = NULL;
	soap_default_int(soap, &this->ns3__TaskDTO::taskStatusId);
	this->ns3__TaskDTO::assignToUserId = NULL;
	this->ns3__TaskDTO::categoryId = NULL;
	this->ns3__TaskDTO::category = NULL;
	this->ns3__TaskDTO::spread = NULL;
	this->ns3__TaskDTO::page = NULL;
	this->ns3__TaskDTO::editionId = NULL;
	soap_default_int(soap, &this->ns3__TaskDTO::versionNumber);
	this->ns3__TaskDTO::TaskUpdateInfo = NULL;
	/* transient soap skipped */
}

void ns3__TaskDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->ns3__TaskDTO::taskid);
	soap_serialize_ns4__guid(soap, &this->ns3__TaskDTO::assetid);
	soap_serialize_wstring(soap, &this->ns3__TaskDTO::subject);
	soap_serialize_wstring(soap, &this->ns3__TaskDTO::description);
	soap_embedded(soap, &this->ns3__TaskDTO::taskStatusId, SOAP_TYPE_int);
	soap_serialize_ns4__guid(soap, &this->ns3__TaskDTO::assignToUserId);
	soap_serialize_PointerToint(soap, &this->ns3__TaskDTO::categoryId);
	soap_serialize_wstring(soap, &this->ns3__TaskDTO::category);
	soap_serialize_wstring(soap, &this->ns3__TaskDTO::spread);
	soap_serialize_wstring(soap, &this->ns3__TaskDTO::page);
	soap_serialize_ns4__guid(soap, &this->ns3__TaskDTO::editionId);
	soap_embedded(soap, &this->ns3__TaskDTO::versionNumber, SOAP_TYPE_int);
	soap_serialize_PointerTons3__TaskUpdateInfo(soap, &this->ns3__TaskDTO::TaskUpdateInfo);
	/* transient soap skipped */
}

int ns3__TaskDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__TaskDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__TaskDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TaskDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TaskDTO(struct soap *soap, const char *tag, int id, const ns3__TaskDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TaskDTO), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:taskid", -1, &(a->ns3__TaskDTO::taskid), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:assetid", -1, &(a->ns3__TaskDTO::assetid), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:subject", -1, &(a->ns3__TaskDTO::subject), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:description", -1, &(a->ns3__TaskDTO::description), ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:taskStatusId", -1, &(a->ns3__TaskDTO::taskStatusId), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:assignToUserId", -1, &(a->ns3__TaskDTO::assignToUserId), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns3:categoryId", -1, &(a->ns3__TaskDTO::categoryId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:category", -1, &(a->ns3__TaskDTO::category), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:spread", -1, &(a->ns3__TaskDTO::spread), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:page", -1, &(a->ns3__TaskDTO::page), ""))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:editionId", -1, &(a->ns3__TaskDTO::editionId), ""))
		return soap->error;
	if (soap_out_int(soap, "ns3:versionNumber", -1, &(a->ns3__TaskDTO::versionNumber), ""))
		return soap->error;
	if (soap_out_PointerTons3__TaskUpdateInfo(soap, "ns3:TaskUpdateInfo", -1, &(a->ns3__TaskDTO::TaskUpdateInfo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__TaskDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TaskDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TaskDTO * SOAP_FMAC4 soap_get_ns3__TaskDTO(struct soap *soap, ns3__TaskDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TaskDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__TaskDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__TaskDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TaskDTO * SOAP_FMAC4 soap_in_ns3__TaskDTO(struct soap *soap, const char *tag, ns3__TaskDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TaskDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TaskDTO, sizeof(ns3__TaskDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__TaskDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__TaskDTO *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_taskid1 = 1;
	size_t soap_flag_assetid1 = 1;
	size_t soap_flag_subject1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_taskStatusId1 = 1;
	size_t soap_flag_assignToUserId1 = 1;
	size_t soap_flag_categoryId1 = 1;
	size_t soap_flag_category1 = 1;
	size_t soap_flag_spread1 = 1;
	size_t soap_flag_page1 = 1;
	size_t soap_flag_editionId1 = 1;
	size_t soap_flag_versionNumber1 = 1;
	size_t soap_flag_TaskUpdateInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_taskid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:taskid", &(a->ns3__TaskDTO::taskid), "ns4:guid"))
				{	soap_flag_taskid1--;
					continue;
				}
			if (soap_flag_assetid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:assetid", &(a->ns3__TaskDTO::assetid), "ns4:guid"))
				{	soap_flag_assetid1--;
					continue;
				}
			if (soap_flag_subject1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:subject", &(a->ns3__TaskDTO::subject), "xsd:string"))
				{	soap_flag_subject1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:description", &(a->ns3__TaskDTO::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_taskStatusId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns3:taskStatusId", &(a->ns3__TaskDTO::taskStatusId), "xsd:int"))
				{	soap_flag_taskStatusId1--;
					continue;
				}
			if (soap_flag_assignToUserId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:assignToUserId", &(a->ns3__TaskDTO::assignToUserId), "ns4:guid"))
				{	soap_flag_assignToUserId1--;
					continue;
				}
			if (soap_flag_categoryId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns3:categoryId", &(a->ns3__TaskDTO::categoryId), "xsd:int"))
				{	soap_flag_categoryId1--;
					continue;
				}
			if (soap_flag_category1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:category", &(a->ns3__TaskDTO::category), "xsd:string"))
				{	soap_flag_category1--;
					continue;
				}
			if (soap_flag_spread1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:spread", &(a->ns3__TaskDTO::spread), "xsd:string"))
				{	soap_flag_spread1--;
					continue;
				}
			if (soap_flag_page1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:page", &(a->ns3__TaskDTO::page), "xsd:string"))
				{	soap_flag_page1--;
					continue;
				}
			if (soap_flag_editionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:editionId", &(a->ns3__TaskDTO::editionId), "ns4:guid"))
				{	soap_flag_editionId1--;
					continue;
				}
			if (soap_flag_versionNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns3:versionNumber", &(a->ns3__TaskDTO::versionNumber), "xsd:int"))
				{	soap_flag_versionNumber1--;
					continue;
				}
			if (soap_flag_TaskUpdateInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__TaskUpdateInfo(soap, "ns3:TaskUpdateInfo", &(a->ns3__TaskDTO::TaskUpdateInfo), "ns3:TaskUpdateInfo"))
				{	soap_flag_TaskUpdateInfo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__TaskDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TaskDTO, 0, sizeof(ns3__TaskDTO), 0, soap_copy_ns3__TaskDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_taskid1 > 0 || soap_flag_assetid1 > 0 || soap_flag_taskStatusId1 > 0 || soap_flag_assignToUserId1 > 0 || soap_flag_categoryId1 > 0 || soap_flag_editionId1 > 0 || soap_flag_versionNumber1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__TaskDTO * SOAP_FMAC4 soap_instantiate_ns3__TaskDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TaskDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__TaskDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__TaskDTO;
		if (size)
			*size = sizeof(ns3__TaskDTO);
		((ns3__TaskDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__TaskDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__TaskDTO);
		for (int i = 0; i < n; i++)
			((ns3__TaskDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__TaskDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__TaskDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__TaskDTO %p -> %p\n", q, p));
	*(ns3__TaskDTO*)p = *(ns3__TaskDTO*)q;
}

void ns3__IdNameDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns3__IdNameDTO::id);
	this->ns3__IdNameDTO::name = NULL;
	/* transient soap skipped */
}

void ns3__IdNameDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns3__IdNameDTO::id, SOAP_TYPE_int);
	soap_serialize_wstring(soap, &this->ns3__IdNameDTO::name);
	/* transient soap skipped */
}

int ns3__IdNameDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__IdNameDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__IdNameDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__IdNameDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__IdNameDTO(struct soap *soap, const char *tag, int id, const ns3__IdNameDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__IdNameDTO), type))
		return soap->error;
	if (soap_out_int(soap, "ns3:id", -1, &(a->ns3__IdNameDTO::id), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:name", -1, &(a->ns3__IdNameDTO::name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__IdNameDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__IdNameDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__IdNameDTO * SOAP_FMAC4 soap_get_ns3__IdNameDTO(struct soap *soap, ns3__IdNameDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__IdNameDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__IdNameDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__IdNameDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__IdNameDTO * SOAP_FMAC4 soap_in_ns3__IdNameDTO(struct soap *soap, const char *tag, ns3__IdNameDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__IdNameDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__IdNameDTO, sizeof(ns3__IdNameDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__IdNameDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__IdNameDTO *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns3:id", &(a->ns3__IdNameDTO::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:name", &(a->ns3__IdNameDTO::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__IdNameDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__IdNameDTO, 0, sizeof(ns3__IdNameDTO), 0, soap_copy_ns3__IdNameDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__IdNameDTO * SOAP_FMAC4 soap_instantiate_ns3__IdNameDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__IdNameDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__IdNameDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__IdNameDTO;
		if (size)
			*size = sizeof(ns3__IdNameDTO);
		((ns3__IdNameDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__IdNameDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__IdNameDTO);
		for (int i = 0; i < n; i++)
			((ns3__IdNameDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__IdNameDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__IdNameDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__IdNameDTO %p -> %p\n", q, p));
	*(ns3__IdNameDTO*)p = *(ns3__IdNameDTO*)q;
}

void ns3__ArrayOfIdNameDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__ArrayOfIdNameDTO::__sizeIdNameDTO = 0;
	this->ns3__ArrayOfIdNameDTO::IdNameDTO = NULL;
	/* transient soap skipped */
}

void ns3__ArrayOfIdNameDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns3__ArrayOfIdNameDTO::IdNameDTO)
	{	int i;
		for (i = 0; i < this->ns3__ArrayOfIdNameDTO::__sizeIdNameDTO; i++)
		{
			soap_serialize_PointerTons3__IdNameDTO(soap, this->ns3__ArrayOfIdNameDTO::IdNameDTO + i);
		}
	}
	/* transient soap skipped */
}

int ns3__ArrayOfIdNameDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__ArrayOfIdNameDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__ArrayOfIdNameDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfIdNameDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfIdNameDTO(struct soap *soap, const char *tag, int id, const ns3__ArrayOfIdNameDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ArrayOfIdNameDTO), type))
		return soap->error;
	if (a->ns3__ArrayOfIdNameDTO::IdNameDTO)
	{	int i;
		for (i = 0; i < a->ns3__ArrayOfIdNameDTO::__sizeIdNameDTO; i++)
			if (soap_out_PointerTons3__IdNameDTO(soap, "ns3:IdNameDTO", -1, a->ns3__ArrayOfIdNameDTO::IdNameDTO + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfIdNameDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfIdNameDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfIdNameDTO * SOAP_FMAC4 soap_get_ns3__ArrayOfIdNameDTO(struct soap *soap, ns3__ArrayOfIdNameDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfIdNameDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__ArrayOfIdNameDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ArrayOfIdNameDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfIdNameDTO * SOAP_FMAC4 soap_in_ns3__ArrayOfIdNameDTO(struct soap *soap, const char *tag, ns3__ArrayOfIdNameDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfIdNameDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ArrayOfIdNameDTO, sizeof(ns3__ArrayOfIdNameDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__ArrayOfIdNameDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ArrayOfIdNameDTO *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_IdNameDTO1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:IdNameDTO", 1, NULL))
			{	if (a->ns3__ArrayOfIdNameDTO::IdNameDTO == NULL)
				{	if (soap_blist_IdNameDTO1 == NULL)
						soap_blist_IdNameDTO1 = soap_new_block(soap);
					a->ns3__ArrayOfIdNameDTO::IdNameDTO = (ns3__IdNameDTO **)soap_push_block(soap, soap_blist_IdNameDTO1, sizeof(ns3__IdNameDTO *));
					if (a->ns3__ArrayOfIdNameDTO::IdNameDTO == NULL)
						return NULL;
					*a->ns3__ArrayOfIdNameDTO::IdNameDTO = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons3__IdNameDTO(soap, "ns3:IdNameDTO", a->ns3__ArrayOfIdNameDTO::IdNameDTO, "ns3:IdNameDTO"))
				{	a->ns3__ArrayOfIdNameDTO::__sizeIdNameDTO++;
					a->ns3__ArrayOfIdNameDTO::IdNameDTO = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__ArrayOfIdNameDTO::IdNameDTO)
			soap_pop_block(soap, soap_blist_IdNameDTO1);
		if (a->ns3__ArrayOfIdNameDTO::__sizeIdNameDTO)
			a->ns3__ArrayOfIdNameDTO::IdNameDTO = (ns3__IdNameDTO **)soap_save_block(soap, soap_blist_IdNameDTO1, NULL, 1);
		else
		{	a->ns3__ArrayOfIdNameDTO::IdNameDTO = NULL;
			if (soap_blist_IdNameDTO1)
				soap_end_block(soap, soap_blist_IdNameDTO1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfIdNameDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ArrayOfIdNameDTO, 0, sizeof(ns3__ArrayOfIdNameDTO), 0, soap_copy_ns3__ArrayOfIdNameDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__ArrayOfIdNameDTO * SOAP_FMAC4 soap_instantiate_ns3__ArrayOfIdNameDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfIdNameDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__ArrayOfIdNameDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__ArrayOfIdNameDTO;
		if (size)
			*size = sizeof(ns3__ArrayOfIdNameDTO);
		((ns3__ArrayOfIdNameDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__ArrayOfIdNameDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__ArrayOfIdNameDTO);
		for (int i = 0; i < n; i++)
			((ns3__ArrayOfIdNameDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__ArrayOfIdNameDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ArrayOfIdNameDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ArrayOfIdNameDTO %p -> %p\n", q, p));
	*(ns3__ArrayOfIdNameDTO*)p = *(ns3__ArrayOfIdNameDTO*)q;
}

void ns3__UserDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__UserDTO::userid = NULL;
	this->ns3__UserDTO::username = NULL;
	this->ns3__UserDTO::name = NULL;
	/* transient soap skipped */
}

void ns3__UserDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns4__guid(soap, &this->ns3__UserDTO::userid);
	soap_serialize_wstring(soap, &this->ns3__UserDTO::username);
	soap_serialize_wstring(soap, &this->ns3__UserDTO::name);
	/* transient soap skipped */
}

int ns3__UserDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__UserDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__UserDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__UserDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__UserDTO(struct soap *soap, const char *tag, int id, const ns3__UserDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__UserDTO), type))
		return soap->error;
	if (soap_out_ns4__guid(soap, "ns3:userid", -1, &(a->ns3__UserDTO::userid), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:username", -1, &(a->ns3__UserDTO::username), ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns3:name", -1, &(a->ns3__UserDTO::name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__UserDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__UserDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__UserDTO * SOAP_FMAC4 soap_get_ns3__UserDTO(struct soap *soap, ns3__UserDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__UserDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__UserDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__UserDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__UserDTO * SOAP_FMAC4 soap_in_ns3__UserDTO(struct soap *soap, const char *tag, ns3__UserDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__UserDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__UserDTO, sizeof(ns3__UserDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__UserDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__UserDTO *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_userid1 = 1;
	size_t soap_flag_username1 = 1;
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns4__guid(soap, "ns3:userid", &(a->ns3__UserDTO::userid), "ns4:guid"))
				{	soap_flag_userid1--;
					continue;
				}
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:username", &(a->ns3__UserDTO::username), "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns3:name", &(a->ns3__UserDTO::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__UserDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__UserDTO, 0, sizeof(ns3__UserDTO), 0, soap_copy_ns3__UserDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_userid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__UserDTO * SOAP_FMAC4 soap_instantiate_ns3__UserDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__UserDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__UserDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__UserDTO;
		if (size)
			*size = sizeof(ns3__UserDTO);
		((ns3__UserDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__UserDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__UserDTO);
		for (int i = 0; i < n; i++)
			((ns3__UserDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__UserDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__UserDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__UserDTO %p -> %p\n", q, p));
	*(ns3__UserDTO*)p = *(ns3__UserDTO*)q;
}

void ns3__ArrayOfUserDTO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__ArrayOfUserDTO::__sizeUserDTO = 0;
	this->ns3__ArrayOfUserDTO::UserDTO = NULL;
	/* transient soap skipped */
}

void ns3__ArrayOfUserDTO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns3__ArrayOfUserDTO::UserDTO)
	{	int i;
		for (i = 0; i < this->ns3__ArrayOfUserDTO::__sizeUserDTO; i++)
		{
			soap_serialize_PointerTons3__UserDTO(soap, this->ns3__ArrayOfUserDTO::UserDTO + i);
		}
	}
	/* transient soap skipped */
}

int ns3__ArrayOfUserDTO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__ArrayOfUserDTO);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__ArrayOfUserDTO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__ArrayOfUserDTO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ArrayOfUserDTO(struct soap *soap, const char *tag, int id, const ns3__ArrayOfUserDTO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ArrayOfUserDTO), type))
		return soap->error;
	if (a->ns3__ArrayOfUserDTO::UserDTO)
	{	int i;
		for (i = 0; i < a->ns3__ArrayOfUserDTO::__sizeUserDTO; i++)
			if (soap_out_PointerTons3__UserDTO(soap, "ns3:UserDTO", -1, a->ns3__ArrayOfUserDTO::UserDTO + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__ArrayOfUserDTO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__ArrayOfUserDTO(soap, this, tag, type);
}

SOAP_FMAC3 ns3__ArrayOfUserDTO * SOAP_FMAC4 soap_get_ns3__ArrayOfUserDTO(struct soap *soap, ns3__ArrayOfUserDTO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ArrayOfUserDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__ArrayOfUserDTO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__ArrayOfUserDTO(soap, tag, this, type);
}

SOAP_FMAC3 ns3__ArrayOfUserDTO * SOAP_FMAC4 soap_in_ns3__ArrayOfUserDTO(struct soap *soap, const char *tag, ns3__ArrayOfUserDTO *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__ArrayOfUserDTO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ArrayOfUserDTO, sizeof(ns3__ArrayOfUserDTO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__ArrayOfUserDTO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__ArrayOfUserDTO *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_UserDTO1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:UserDTO", 1, NULL))
			{	if (a->ns3__ArrayOfUserDTO::UserDTO == NULL)
				{	if (soap_blist_UserDTO1 == NULL)
						soap_blist_UserDTO1 = soap_new_block(soap);
					a->ns3__ArrayOfUserDTO::UserDTO = (ns3__UserDTO **)soap_push_block(soap, soap_blist_UserDTO1, sizeof(ns3__UserDTO *));
					if (a->ns3__ArrayOfUserDTO::UserDTO == NULL)
						return NULL;
					*a->ns3__ArrayOfUserDTO::UserDTO = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTons3__UserDTO(soap, "ns3:UserDTO", a->ns3__ArrayOfUserDTO::UserDTO, "ns3:UserDTO"))
				{	a->ns3__ArrayOfUserDTO::__sizeUserDTO++;
					a->ns3__ArrayOfUserDTO::UserDTO = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns3__ArrayOfUserDTO::UserDTO)
			soap_pop_block(soap, soap_blist_UserDTO1);
		if (a->ns3__ArrayOfUserDTO::__sizeUserDTO)
			a->ns3__ArrayOfUserDTO::UserDTO = (ns3__UserDTO **)soap_save_block(soap, soap_blist_UserDTO1, NULL, 1);
		else
		{	a->ns3__ArrayOfUserDTO::UserDTO = NULL;
			if (soap_blist_UserDTO1)
				soap_end_block(soap, soap_blist_UserDTO1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__ArrayOfUserDTO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ArrayOfUserDTO, 0, sizeof(ns3__ArrayOfUserDTO), 0, soap_copy_ns3__ArrayOfUserDTO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__ArrayOfUserDTO * SOAP_FMAC4 soap_instantiate_ns3__ArrayOfUserDTO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__ArrayOfUserDTO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__ArrayOfUserDTO, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__ArrayOfUserDTO;
		if (size)
			*size = sizeof(ns3__ArrayOfUserDTO);
		((ns3__ArrayOfUserDTO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__ArrayOfUserDTO[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__ArrayOfUserDTO);
		for (int i = 0; i < n; i++)
			((ns3__ArrayOfUserDTO*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__ArrayOfUserDTO*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__ArrayOfUserDTO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__ArrayOfUserDTO %p -> %p\n", q, p));
	*(ns3__ArrayOfUserDTO*)p = *(ns3__ArrayOfUserDTO*)q;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if (this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__base64Binary;
		if (size)
			*size = sizeof(xsd__base64Binary);
		((xsd__base64Binary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__base64Binary[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__base64Binary);
		for (int i = 0; i < n; i++)
			((xsd__base64Binary*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__base64Binary*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DownloadVersion(struct soap *soap, struct __ns1__DownloadVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__DownloadVersion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DownloadVersion(struct soap *soap, const struct __ns1__DownloadVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__DownloadVersion(soap, &a->ns3__DownloadVersion);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DownloadVersion(struct soap *soap, const struct __ns1__DownloadVersion *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__DownloadVersion(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DownloadVersion(struct soap *soap, const char *tag, int id, const struct __ns1__DownloadVersion *a, const char *type)
{
	if (soap_out_PointerTo_ns3__DownloadVersion(soap, "ns3:DownloadVersion", -1, &a->ns3__DownloadVersion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DownloadVersion * SOAP_FMAC4 soap_get___ns1__DownloadVersion(struct soap *soap, struct __ns1__DownloadVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DownloadVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__DownloadVersion * SOAP_FMAC4 soap_in___ns1__DownloadVersion(struct soap *soap, const char *tag, struct __ns1__DownloadVersion *a, const char *type)
{
	size_t soap_flag_ns3__DownloadVersion = 1;
	short soap_flag;
	a = (struct __ns1__DownloadVersion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DownloadVersion, sizeof(struct __ns1__DownloadVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DownloadVersion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__DownloadVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__DownloadVersion(soap, "ns3:DownloadVersion", &a->ns3__DownloadVersion, ""))
				{	soap_flag_ns3__DownloadVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__DownloadVersion * SOAP_FMAC4 soap_instantiate___ns1__DownloadVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DownloadVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__DownloadVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__DownloadVersion;
		if (size)
			*size = sizeof(struct __ns1__DownloadVersion);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__DownloadVersion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__DownloadVersion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__DownloadVersion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__DownloadVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__DownloadVersion %p -> %p\n", q, p));
	*(struct __ns1__DownloadVersion*)p = *(struct __ns1__DownloadVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CheckInAsset(struct soap *soap, struct __ns1__CheckInAsset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__CheckInAsset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CheckInAsset(struct soap *soap, const struct __ns1__CheckInAsset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__CheckInAsset(soap, &a->ns3__CheckInAsset);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CheckInAsset(struct soap *soap, const struct __ns1__CheckInAsset *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__CheckInAsset(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CheckInAsset(struct soap *soap, const char *tag, int id, const struct __ns1__CheckInAsset *a, const char *type)
{
	if (soap_out_PointerTo_ns3__CheckInAsset(soap, "ns3:CheckInAsset", -1, &a->ns3__CheckInAsset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckInAsset * SOAP_FMAC4 soap_get___ns1__CheckInAsset(struct soap *soap, struct __ns1__CheckInAsset *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CheckInAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__CheckInAsset * SOAP_FMAC4 soap_in___ns1__CheckInAsset(struct soap *soap, const char *tag, struct __ns1__CheckInAsset *a, const char *type)
{
	size_t soap_flag_ns3__CheckInAsset = 1;
	short soap_flag;
	a = (struct __ns1__CheckInAsset *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CheckInAsset, sizeof(struct __ns1__CheckInAsset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CheckInAsset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__CheckInAsset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__CheckInAsset(soap, "ns3:CheckInAsset", &a->ns3__CheckInAsset, ""))
				{	soap_flag_ns3__CheckInAsset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__CheckInAsset * SOAP_FMAC4 soap_instantiate___ns1__CheckInAsset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CheckInAsset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__CheckInAsset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__CheckInAsset;
		if (size)
			*size = sizeof(struct __ns1__CheckInAsset);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__CheckInAsset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__CheckInAsset);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__CheckInAsset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__CheckInAsset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__CheckInAsset %p -> %p\n", q, p));
	*(struct __ns1__CheckInAsset*)p = *(struct __ns1__CheckInAsset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLock(struct soap *soap, struct __ns1__GetLock *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetLock = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLock(struct soap *soap, const struct __ns1__GetLock *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetLock(soap, &a->ns3__GetLock);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLock(struct soap *soap, const struct __ns1__GetLock *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetLock(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLock(struct soap *soap, const char *tag, int id, const struct __ns1__GetLock *a, const char *type)
{
	if (soap_out_PointerTo_ns3__GetLock(soap, "ns3:GetLock", -1, &a->ns3__GetLock, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLock * SOAP_FMAC4 soap_get___ns1__GetLock(struct soap *soap, struct __ns1__GetLock *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLock(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetLock * SOAP_FMAC4 soap_in___ns1__GetLock(struct soap *soap, const char *tag, struct __ns1__GetLock *a, const char *type)
{
	size_t soap_flag_ns3__GetLock = 1;
	short soap_flag;
	a = (struct __ns1__GetLock *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLock, sizeof(struct __ns1__GetLock), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLock(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetLock && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetLock(soap, "ns3:GetLock", &a->ns3__GetLock, ""))
				{	soap_flag_ns3__GetLock--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetLock * SOAP_FMAC4 soap_instantiate___ns1__GetLock(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLock(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetLock, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetLock;
		if (size)
			*size = sizeof(struct __ns1__GetLock);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetLock[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetLock);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetLock*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetLock(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetLock %p -> %p\n", q, p));
	*(struct __ns1__GetLock*)p = *(struct __ns1__GetLock*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdateAssetStatus(struct soap *soap, struct __ns1__UpdateAssetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__UpdateAssetStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdateAssetStatus(struct soap *soap, const struct __ns1__UpdateAssetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__UpdateAssetStatus(soap, &a->ns3__UpdateAssetStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdateAssetStatus(struct soap *soap, const struct __ns1__UpdateAssetStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UpdateAssetStatus(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdateAssetStatus(struct soap *soap, const char *tag, int id, const struct __ns1__UpdateAssetStatus *a, const char *type)
{
	if (soap_out_PointerTo_ns3__UpdateAssetStatus(soap, "ns3:UpdateAssetStatus", -1, &a->ns3__UpdateAssetStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateAssetStatus * SOAP_FMAC4 soap_get___ns1__UpdateAssetStatus(struct soap *soap, struct __ns1__UpdateAssetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdateAssetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__UpdateAssetStatus * SOAP_FMAC4 soap_in___ns1__UpdateAssetStatus(struct soap *soap, const char *tag, struct __ns1__UpdateAssetStatus *a, const char *type)
{
	size_t soap_flag_ns3__UpdateAssetStatus = 1;
	short soap_flag;
	a = (struct __ns1__UpdateAssetStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdateAssetStatus, sizeof(struct __ns1__UpdateAssetStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdateAssetStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__UpdateAssetStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__UpdateAssetStatus(soap, "ns3:UpdateAssetStatus", &a->ns3__UpdateAssetStatus, ""))
				{	soap_flag_ns3__UpdateAssetStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__UpdateAssetStatus * SOAP_FMAC4 soap_instantiate___ns1__UpdateAssetStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdateAssetStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UpdateAssetStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__UpdateAssetStatus;
		if (size)
			*size = sizeof(struct __ns1__UpdateAssetStatus);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__UpdateAssetStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__UpdateAssetStatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__UpdateAssetStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UpdateAssetStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UpdateAssetStatus %p -> %p\n", q, p));
	*(struct __ns1__UpdateAssetStatus*)p = *(struct __ns1__UpdateAssetStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdateAsset(struct soap *soap, struct __ns1__UpdateAsset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__UpdateAsset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdateAsset(struct soap *soap, const struct __ns1__UpdateAsset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__UpdateAsset(soap, &a->ns3__UpdateAsset);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdateAsset(struct soap *soap, const struct __ns1__UpdateAsset *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UpdateAsset(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdateAsset(struct soap *soap, const char *tag, int id, const struct __ns1__UpdateAsset *a, const char *type)
{
	if (soap_out_PointerTo_ns3__UpdateAsset(soap, "ns3:UpdateAsset", -1, &a->ns3__UpdateAsset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateAsset * SOAP_FMAC4 soap_get___ns1__UpdateAsset(struct soap *soap, struct __ns1__UpdateAsset *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdateAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__UpdateAsset * SOAP_FMAC4 soap_in___ns1__UpdateAsset(struct soap *soap, const char *tag, struct __ns1__UpdateAsset *a, const char *type)
{
	size_t soap_flag_ns3__UpdateAsset = 1;
	short soap_flag;
	a = (struct __ns1__UpdateAsset *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdateAsset, sizeof(struct __ns1__UpdateAsset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdateAsset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__UpdateAsset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__UpdateAsset(soap, "ns3:UpdateAsset", &a->ns3__UpdateAsset, ""))
				{	soap_flag_ns3__UpdateAsset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__UpdateAsset * SOAP_FMAC4 soap_instantiate___ns1__UpdateAsset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdateAsset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UpdateAsset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__UpdateAsset;
		if (size)
			*size = sizeof(struct __ns1__UpdateAsset);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__UpdateAsset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__UpdateAsset);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__UpdateAsset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UpdateAsset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UpdateAsset %p -> %p\n", q, p));
	*(struct __ns1__UpdateAsset*)p = *(struct __ns1__UpdateAsset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAssetList(struct soap *soap, struct __ns1__GetAssetList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetAssetList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAssetList(struct soap *soap, const struct __ns1__GetAssetList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetAssetList(soap, &a->ns3__GetAssetList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAssetList(struct soap *soap, const struct __ns1__GetAssetList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetAssetList(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAssetList(struct soap *soap, const char *tag, int id, const struct __ns1__GetAssetList *a, const char *type)
{
	if (soap_out_PointerTo_ns3__GetAssetList(soap, "ns3:GetAssetList", -1, &a->ns3__GetAssetList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAssetList * SOAP_FMAC4 soap_get___ns1__GetAssetList(struct soap *soap, struct __ns1__GetAssetList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAssetList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetAssetList * SOAP_FMAC4 soap_in___ns1__GetAssetList(struct soap *soap, const char *tag, struct __ns1__GetAssetList *a, const char *type)
{
	size_t soap_flag_ns3__GetAssetList = 1;
	short soap_flag;
	a = (struct __ns1__GetAssetList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAssetList, sizeof(struct __ns1__GetAssetList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAssetList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetAssetList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetAssetList(soap, "ns3:GetAssetList", &a->ns3__GetAssetList, ""))
				{	soap_flag_ns3__GetAssetList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetAssetList * SOAP_FMAC4 soap_instantiate___ns1__GetAssetList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAssetList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetAssetList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetAssetList;
		if (size)
			*size = sizeof(struct __ns1__GetAssetList);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetAssetList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetAssetList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetAssetList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetAssetList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetAssetList %p -> %p\n", q, p));
	*(struct __ns1__GetAssetList*)p = *(struct __ns1__GetAssetList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetStatusByTitle(struct soap *soap, struct __ns1__GetStatusByTitle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetStatusByTitle = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetStatusByTitle(struct soap *soap, const struct __ns1__GetStatusByTitle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetStatusByTitle(soap, &a->ns3__GetStatusByTitle);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetStatusByTitle(struct soap *soap, const struct __ns1__GetStatusByTitle *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetStatusByTitle(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetStatusByTitle(struct soap *soap, const char *tag, int id, const struct __ns1__GetStatusByTitle *a, const char *type)
{
	if (soap_out_PointerTo_ns3__GetStatusByTitle(soap, "ns3:GetStatusByTitle", -1, &a->ns3__GetStatusByTitle, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetStatusByTitle * SOAP_FMAC4 soap_get___ns1__GetStatusByTitle(struct soap *soap, struct __ns1__GetStatusByTitle *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetStatusByTitle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetStatusByTitle * SOAP_FMAC4 soap_in___ns1__GetStatusByTitle(struct soap *soap, const char *tag, struct __ns1__GetStatusByTitle *a, const char *type)
{
	size_t soap_flag_ns3__GetStatusByTitle = 1;
	short soap_flag;
	a = (struct __ns1__GetStatusByTitle *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetStatusByTitle, sizeof(struct __ns1__GetStatusByTitle), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetStatusByTitle(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetStatusByTitle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetStatusByTitle(soap, "ns3:GetStatusByTitle", &a->ns3__GetStatusByTitle, ""))
				{	soap_flag_ns3__GetStatusByTitle--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetStatusByTitle * SOAP_FMAC4 soap_instantiate___ns1__GetStatusByTitle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetStatusByTitle(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetStatusByTitle, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetStatusByTitle;
		if (size)
			*size = sizeof(struct __ns1__GetStatusByTitle);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetStatusByTitle[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetStatusByTitle);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetStatusByTitle*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetStatusByTitle(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetStatusByTitle %p -> %p\n", q, p));
	*(struct __ns1__GetStatusByTitle*)p = *(struct __ns1__GetStatusByTitle*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetEditionsByTitle(struct soap *soap, struct __ns1__GetEditionsByTitle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetEditionsByTitle = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetEditionsByTitle(struct soap *soap, const struct __ns1__GetEditionsByTitle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetEditionsByTitle(soap, &a->ns3__GetEditionsByTitle);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetEditionsByTitle(struct soap *soap, const struct __ns1__GetEditionsByTitle *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetEditionsByTitle(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetEditionsByTitle(struct soap *soap, const char *tag, int id, const struct __ns1__GetEditionsByTitle *a, const char *type)
{
	if (soap_out_PointerTo_ns3__GetEditionsByTitle(soap, "ns3:GetEditionsByTitle", -1, &a->ns3__GetEditionsByTitle, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetEditionsByTitle * SOAP_FMAC4 soap_get___ns1__GetEditionsByTitle(struct soap *soap, struct __ns1__GetEditionsByTitle *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetEditionsByTitle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetEditionsByTitle * SOAP_FMAC4 soap_in___ns1__GetEditionsByTitle(struct soap *soap, const char *tag, struct __ns1__GetEditionsByTitle *a, const char *type)
{
	size_t soap_flag_ns3__GetEditionsByTitle = 1;
	short soap_flag;
	a = (struct __ns1__GetEditionsByTitle *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetEditionsByTitle, sizeof(struct __ns1__GetEditionsByTitle), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetEditionsByTitle(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetEditionsByTitle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetEditionsByTitle(soap, "ns3:GetEditionsByTitle", &a->ns3__GetEditionsByTitle, ""))
				{	soap_flag_ns3__GetEditionsByTitle--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetEditionsByTitle * SOAP_FMAC4 soap_instantiate___ns1__GetEditionsByTitle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetEditionsByTitle(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetEditionsByTitle, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetEditionsByTitle;
		if (size)
			*size = sizeof(struct __ns1__GetEditionsByTitle);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetEditionsByTitle[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetEditionsByTitle);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetEditionsByTitle*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetEditionsByTitle(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetEditionsByTitle %p -> %p\n", q, p));
	*(struct __ns1__GetEditionsByTitle*)p = *(struct __ns1__GetEditionsByTitle*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CheckOutAsset(struct soap *soap, struct __ns1__CheckOutAsset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__CheckOutAsset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CheckOutAsset(struct soap *soap, const struct __ns1__CheckOutAsset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__CheckOutAsset(soap, &a->ns3__CheckOutAsset);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CheckOutAsset(struct soap *soap, const struct __ns1__CheckOutAsset *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__CheckOutAsset(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CheckOutAsset(struct soap *soap, const char *tag, int id, const struct __ns1__CheckOutAsset *a, const char *type)
{
	if (soap_out_PointerTo_ns3__CheckOutAsset(soap, "ns3:CheckOutAsset", -1, &a->ns3__CheckOutAsset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckOutAsset * SOAP_FMAC4 soap_get___ns1__CheckOutAsset(struct soap *soap, struct __ns1__CheckOutAsset *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CheckOutAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__CheckOutAsset * SOAP_FMAC4 soap_in___ns1__CheckOutAsset(struct soap *soap, const char *tag, struct __ns1__CheckOutAsset *a, const char *type)
{
	size_t soap_flag_ns3__CheckOutAsset = 1;
	short soap_flag;
	a = (struct __ns1__CheckOutAsset *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CheckOutAsset, sizeof(struct __ns1__CheckOutAsset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CheckOutAsset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__CheckOutAsset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__CheckOutAsset(soap, "ns3:CheckOutAsset", &a->ns3__CheckOutAsset, ""))
				{	soap_flag_ns3__CheckOutAsset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__CheckOutAsset * SOAP_FMAC4 soap_instantiate___ns1__CheckOutAsset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CheckOutAsset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__CheckOutAsset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__CheckOutAsset;
		if (size)
			*size = sizeof(struct __ns1__CheckOutAsset);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__CheckOutAsset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__CheckOutAsset);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__CheckOutAsset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__CheckOutAsset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__CheckOutAsset %p -> %p\n", q, p));
	*(struct __ns1__CheckOutAsset*)p = *(struct __ns1__CheckOutAsset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetEditionTaskList(struct soap *soap, struct __ns1__GetEditionTaskList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetEditionTaskList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetEditionTaskList(struct soap *soap, const struct __ns1__GetEditionTaskList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetEditionTaskList(soap, &a->ns3__GetEditionTaskList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetEditionTaskList(struct soap *soap, const struct __ns1__GetEditionTaskList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetEditionTaskList(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetEditionTaskList(struct soap *soap, const char *tag, int id, const struct __ns1__GetEditionTaskList *a, const char *type)
{
	if (soap_out_PointerTo_ns3__GetEditionTaskList(soap, "ns3:GetEditionTaskList", -1, &a->ns3__GetEditionTaskList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetEditionTaskList * SOAP_FMAC4 soap_get___ns1__GetEditionTaskList(struct soap *soap, struct __ns1__GetEditionTaskList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetEditionTaskList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetEditionTaskList * SOAP_FMAC4 soap_in___ns1__GetEditionTaskList(struct soap *soap, const char *tag, struct __ns1__GetEditionTaskList *a, const char *type)
{
	size_t soap_flag_ns3__GetEditionTaskList = 1;
	short soap_flag;
	a = (struct __ns1__GetEditionTaskList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetEditionTaskList, sizeof(struct __ns1__GetEditionTaskList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetEditionTaskList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetEditionTaskList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetEditionTaskList(soap, "ns3:GetEditionTaskList", &a->ns3__GetEditionTaskList, ""))
				{	soap_flag_ns3__GetEditionTaskList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetEditionTaskList * SOAP_FMAC4 soap_instantiate___ns1__GetEditionTaskList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetEditionTaskList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetEditionTaskList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetEditionTaskList;
		if (size)
			*size = sizeof(struct __ns1__GetEditionTaskList);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetEditionTaskList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetEditionTaskList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetEditionTaskList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetEditionTaskList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetEditionTaskList %p -> %p\n", q, p));
	*(struct __ns1__GetEditionTaskList*)p = *(struct __ns1__GetEditionTaskList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__RelinkAsset(struct soap *soap, struct __ns1__RelinkAsset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__RelinkAsset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__RelinkAsset(struct soap *soap, const struct __ns1__RelinkAsset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__RelinkAsset(soap, &a->ns3__RelinkAsset);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__RelinkAsset(struct soap *soap, const struct __ns1__RelinkAsset *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__RelinkAsset(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__RelinkAsset(struct soap *soap, const char *tag, int id, const struct __ns1__RelinkAsset *a, const char *type)
{
	if (soap_out_PointerTo_ns3__RelinkAsset(soap, "ns3:RelinkAsset", -1, &a->ns3__RelinkAsset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RelinkAsset * SOAP_FMAC4 soap_get___ns1__RelinkAsset(struct soap *soap, struct __ns1__RelinkAsset *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__RelinkAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__RelinkAsset * SOAP_FMAC4 soap_in___ns1__RelinkAsset(struct soap *soap, const char *tag, struct __ns1__RelinkAsset *a, const char *type)
{
	size_t soap_flag_ns3__RelinkAsset = 1;
	short soap_flag;
	a = (struct __ns1__RelinkAsset *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__RelinkAsset, sizeof(struct __ns1__RelinkAsset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__RelinkAsset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__RelinkAsset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__RelinkAsset(soap, "ns3:RelinkAsset", &a->ns3__RelinkAsset, ""))
				{	soap_flag_ns3__RelinkAsset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__RelinkAsset * SOAP_FMAC4 soap_instantiate___ns1__RelinkAsset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__RelinkAsset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__RelinkAsset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__RelinkAsset;
		if (size)
			*size = sizeof(struct __ns1__RelinkAsset);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__RelinkAsset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__RelinkAsset);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__RelinkAsset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__RelinkAsset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__RelinkAsset %p -> %p\n", q, p));
	*(struct __ns1__RelinkAsset*)p = *(struct __ns1__RelinkAsset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UnlinkAsset(struct soap *soap, struct __ns1__UnlinkAsset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__UnlinkAsset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UnlinkAsset(struct soap *soap, const struct __ns1__UnlinkAsset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__UnlinkAsset(soap, &a->ns3__UnlinkAsset);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UnlinkAsset(struct soap *soap, const struct __ns1__UnlinkAsset *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UnlinkAsset(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UnlinkAsset(struct soap *soap, const char *tag, int id, const struct __ns1__UnlinkAsset *a, const char *type)
{
	if (soap_out_PointerTo_ns3__UnlinkAsset(soap, "ns3:UnlinkAsset", -1, &a->ns3__UnlinkAsset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UnlinkAsset * SOAP_FMAC4 soap_get___ns1__UnlinkAsset(struct soap *soap, struct __ns1__UnlinkAsset *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UnlinkAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__UnlinkAsset * SOAP_FMAC4 soap_in___ns1__UnlinkAsset(struct soap *soap, const char *tag, struct __ns1__UnlinkAsset *a, const char *type)
{
	size_t soap_flag_ns3__UnlinkAsset = 1;
	short soap_flag;
	a = (struct __ns1__UnlinkAsset *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UnlinkAsset, sizeof(struct __ns1__UnlinkAsset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UnlinkAsset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__UnlinkAsset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__UnlinkAsset(soap, "ns3:UnlinkAsset", &a->ns3__UnlinkAsset, ""))
				{	soap_flag_ns3__UnlinkAsset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__UnlinkAsset * SOAP_FMAC4 soap_instantiate___ns1__UnlinkAsset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UnlinkAsset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UnlinkAsset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__UnlinkAsset;
		if (size)
			*size = sizeof(struct __ns1__UnlinkAsset);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__UnlinkAsset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__UnlinkAsset);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__UnlinkAsset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UnlinkAsset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UnlinkAsset %p -> %p\n", q, p));
	*(struct __ns1__UnlinkAsset*)p = *(struct __ns1__UnlinkAsset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UploadExport(struct soap *soap, struct __ns1__UploadExport *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__UploadExport = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UploadExport(struct soap *soap, const struct __ns1__UploadExport *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__UploadExport(soap, &a->ns3__UploadExport);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UploadExport(struct soap *soap, const struct __ns1__UploadExport *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UploadExport(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UploadExport(struct soap *soap, const char *tag, int id, const struct __ns1__UploadExport *a, const char *type)
{
	if (soap_out_PointerTo_ns3__UploadExport(soap, "ns3:UploadExport", -1, &a->ns3__UploadExport, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadExport * SOAP_FMAC4 soap_get___ns1__UploadExport(struct soap *soap, struct __ns1__UploadExport *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UploadExport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__UploadExport * SOAP_FMAC4 soap_in___ns1__UploadExport(struct soap *soap, const char *tag, struct __ns1__UploadExport *a, const char *type)
{
	size_t soap_flag_ns3__UploadExport = 1;
	short soap_flag;
	a = (struct __ns1__UploadExport *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UploadExport, sizeof(struct __ns1__UploadExport), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UploadExport(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__UploadExport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__UploadExport(soap, "ns3:UploadExport", &a->ns3__UploadExport, ""))
				{	soap_flag_ns3__UploadExport--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__UploadExport * SOAP_FMAC4 soap_instantiate___ns1__UploadExport(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UploadExport(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UploadExport, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__UploadExport;
		if (size)
			*size = sizeof(struct __ns1__UploadExport);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__UploadExport[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__UploadExport);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__UploadExport*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UploadExport(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UploadExport %p -> %p\n", q, p));
	*(struct __ns1__UploadExport*)p = *(struct __ns1__UploadExport*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UploadVersion(struct soap *soap, struct __ns1__UploadVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__UploadVersion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UploadVersion(struct soap *soap, const struct __ns1__UploadVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__UploadVersion(soap, &a->ns3__UploadVersion);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UploadVersion(struct soap *soap, const struct __ns1__UploadVersion *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UploadVersion(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UploadVersion(struct soap *soap, const char *tag, int id, const struct __ns1__UploadVersion *a, const char *type)
{
	if (soap_out_PointerTo_ns3__UploadVersion(soap, "ns3:UploadVersion", -1, &a->ns3__UploadVersion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadVersion * SOAP_FMAC4 soap_get___ns1__UploadVersion(struct soap *soap, struct __ns1__UploadVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UploadVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__UploadVersion * SOAP_FMAC4 soap_in___ns1__UploadVersion(struct soap *soap, const char *tag, struct __ns1__UploadVersion *a, const char *type)
{
	size_t soap_flag_ns3__UploadVersion = 1;
	short soap_flag;
	a = (struct __ns1__UploadVersion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UploadVersion, sizeof(struct __ns1__UploadVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UploadVersion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__UploadVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__UploadVersion(soap, "ns3:UploadVersion", &a->ns3__UploadVersion, ""))
				{	soap_flag_ns3__UploadVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__UploadVersion * SOAP_FMAC4 soap_instantiate___ns1__UploadVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UploadVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UploadVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__UploadVersion;
		if (size)
			*size = sizeof(struct __ns1__UploadVersion);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__UploadVersion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__UploadVersion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__UploadVersion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UploadVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UploadVersion %p -> %p\n", q, p));
	*(struct __ns1__UploadVersion*)p = *(struct __ns1__UploadVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UploadPage(struct soap *soap, struct __ns1__UploadPage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__UploadPage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UploadPage(struct soap *soap, const struct __ns1__UploadPage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__UploadPage(soap, &a->ns3__UploadPage);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UploadPage(struct soap *soap, const struct __ns1__UploadPage *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UploadPage(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UploadPage(struct soap *soap, const char *tag, int id, const struct __ns1__UploadPage *a, const char *type)
{
	if (soap_out_PointerTo_ns3__UploadPage(soap, "ns3:UploadPage", -1, &a->ns3__UploadPage, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadPage * SOAP_FMAC4 soap_get___ns1__UploadPage(struct soap *soap, struct __ns1__UploadPage *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UploadPage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__UploadPage * SOAP_FMAC4 soap_in___ns1__UploadPage(struct soap *soap, const char *tag, struct __ns1__UploadPage *a, const char *type)
{
	size_t soap_flag_ns3__UploadPage = 1;
	short soap_flag;
	a = (struct __ns1__UploadPage *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UploadPage, sizeof(struct __ns1__UploadPage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UploadPage(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__UploadPage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__UploadPage(soap, "ns3:UploadPage", &a->ns3__UploadPage, ""))
				{	soap_flag_ns3__UploadPage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__UploadPage * SOAP_FMAC4 soap_instantiate___ns1__UploadPage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UploadPage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UploadPage, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__UploadPage;
		if (size)
			*size = sizeof(struct __ns1__UploadPage);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__UploadPage[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__UploadPage);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__UploadPage*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UploadPage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UploadPage %p -> %p\n", q, p));
	*(struct __ns1__UploadPage*)p = *(struct __ns1__UploadPage*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UploadPDF(struct soap *soap, struct __ns1__UploadPDF *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__UploadPDF = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UploadPDF(struct soap *soap, const struct __ns1__UploadPDF *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__UploadPDF(soap, &a->ns3__UploadPDF);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UploadPDF(struct soap *soap, const struct __ns1__UploadPDF *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UploadPDF(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UploadPDF(struct soap *soap, const char *tag, int id, const struct __ns1__UploadPDF *a, const char *type)
{
	if (soap_out_PointerTo_ns3__UploadPDF(soap, "ns3:UploadPDF", -1, &a->ns3__UploadPDF, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadPDF * SOAP_FMAC4 soap_get___ns1__UploadPDF(struct soap *soap, struct __ns1__UploadPDF *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UploadPDF(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__UploadPDF * SOAP_FMAC4 soap_in___ns1__UploadPDF(struct soap *soap, const char *tag, struct __ns1__UploadPDF *a, const char *type)
{
	size_t soap_flag_ns3__UploadPDF = 1;
	short soap_flag;
	a = (struct __ns1__UploadPDF *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UploadPDF, sizeof(struct __ns1__UploadPDF), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UploadPDF(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__UploadPDF && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__UploadPDF(soap, "ns3:UploadPDF", &a->ns3__UploadPDF, ""))
				{	soap_flag_ns3__UploadPDF--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__UploadPDF * SOAP_FMAC4 soap_instantiate___ns1__UploadPDF(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UploadPDF(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UploadPDF, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__UploadPDF;
		if (size)
			*size = sizeof(struct __ns1__UploadPDF);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__UploadPDF[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__UploadPDF);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__UploadPDF*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UploadPDF(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UploadPDF %p -> %p\n", q, p));
	*(struct __ns1__UploadPDF*)p = *(struct __ns1__UploadPDF*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAsset(struct soap *soap, struct __ns1__GetAsset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetAsset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAsset(struct soap *soap, const struct __ns1__GetAsset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetAsset(soap, &a->ns3__GetAsset);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAsset(struct soap *soap, const struct __ns1__GetAsset *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetAsset(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAsset(struct soap *soap, const char *tag, int id, const struct __ns1__GetAsset *a, const char *type)
{
	if (soap_out_PointerTo_ns3__GetAsset(soap, "ns3:GetAsset", -1, &a->ns3__GetAsset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAsset * SOAP_FMAC4 soap_get___ns1__GetAsset(struct soap *soap, struct __ns1__GetAsset *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetAsset * SOAP_FMAC4 soap_in___ns1__GetAsset(struct soap *soap, const char *tag, struct __ns1__GetAsset *a, const char *type)
{
	size_t soap_flag_ns3__GetAsset = 1;
	short soap_flag;
	a = (struct __ns1__GetAsset *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAsset, sizeof(struct __ns1__GetAsset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAsset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetAsset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetAsset(soap, "ns3:GetAsset", &a->ns3__GetAsset, ""))
				{	soap_flag_ns3__GetAsset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetAsset * SOAP_FMAC4 soap_instantiate___ns1__GetAsset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAsset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetAsset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetAsset;
		if (size)
			*size = sizeof(struct __ns1__GetAsset);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetAsset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetAsset);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetAsset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetAsset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetAsset %p -> %p\n", q, p));
	*(struct __ns1__GetAsset*)p = *(struct __ns1__GetAsset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CanUpdateAssetName(struct soap *soap, struct __ns1__CanUpdateAssetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__CanUpdateAssetName = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CanUpdateAssetName(struct soap *soap, const struct __ns1__CanUpdateAssetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__CanUpdateAssetName(soap, &a->ns3__CanUpdateAssetName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CanUpdateAssetName(struct soap *soap, const struct __ns1__CanUpdateAssetName *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__CanUpdateAssetName(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CanUpdateAssetName(struct soap *soap, const char *tag, int id, const struct __ns1__CanUpdateAssetName *a, const char *type)
{
	if (soap_out_PointerTo_ns3__CanUpdateAssetName(soap, "ns3:CanUpdateAssetName", -1, &a->ns3__CanUpdateAssetName, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CanUpdateAssetName * SOAP_FMAC4 soap_get___ns1__CanUpdateAssetName(struct soap *soap, struct __ns1__CanUpdateAssetName *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CanUpdateAssetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__CanUpdateAssetName * SOAP_FMAC4 soap_in___ns1__CanUpdateAssetName(struct soap *soap, const char *tag, struct __ns1__CanUpdateAssetName *a, const char *type)
{
	size_t soap_flag_ns3__CanUpdateAssetName = 1;
	short soap_flag;
	a = (struct __ns1__CanUpdateAssetName *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CanUpdateAssetName, sizeof(struct __ns1__CanUpdateAssetName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CanUpdateAssetName(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__CanUpdateAssetName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__CanUpdateAssetName(soap, "ns3:CanUpdateAssetName", &a->ns3__CanUpdateAssetName, ""))
				{	soap_flag_ns3__CanUpdateAssetName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__CanUpdateAssetName * SOAP_FMAC4 soap_instantiate___ns1__CanUpdateAssetName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CanUpdateAssetName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__CanUpdateAssetName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__CanUpdateAssetName;
		if (size)
			*size = sizeof(struct __ns1__CanUpdateAssetName);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__CanUpdateAssetName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__CanUpdateAssetName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__CanUpdateAssetName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__CanUpdateAssetName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__CanUpdateAssetName %p -> %p\n", q, p));
	*(struct __ns1__CanUpdateAssetName*)p = *(struct __ns1__CanUpdateAssetName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdateAssetName(struct soap *soap, struct __ns1__UpdateAssetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__UpdateAssetName = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdateAssetName(struct soap *soap, const struct __ns1__UpdateAssetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__UpdateAssetName(soap, &a->ns3__UpdateAssetName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdateAssetName(struct soap *soap, const struct __ns1__UpdateAssetName *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UpdateAssetName(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdateAssetName(struct soap *soap, const char *tag, int id, const struct __ns1__UpdateAssetName *a, const char *type)
{
	if (soap_out_PointerTo_ns3__UpdateAssetName(soap, "ns3:UpdateAssetName", -1, &a->ns3__UpdateAssetName, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateAssetName * SOAP_FMAC4 soap_get___ns1__UpdateAssetName(struct soap *soap, struct __ns1__UpdateAssetName *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdateAssetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__UpdateAssetName * SOAP_FMAC4 soap_in___ns1__UpdateAssetName(struct soap *soap, const char *tag, struct __ns1__UpdateAssetName *a, const char *type)
{
	size_t soap_flag_ns3__UpdateAssetName = 1;
	short soap_flag;
	a = (struct __ns1__UpdateAssetName *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdateAssetName, sizeof(struct __ns1__UpdateAssetName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdateAssetName(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__UpdateAssetName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__UpdateAssetName(soap, "ns3:UpdateAssetName", &a->ns3__UpdateAssetName, ""))
				{	soap_flag_ns3__UpdateAssetName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__UpdateAssetName * SOAP_FMAC4 soap_instantiate___ns1__UpdateAssetName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdateAssetName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UpdateAssetName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__UpdateAssetName;
		if (size)
			*size = sizeof(struct __ns1__UpdateAssetName);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__UpdateAssetName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__UpdateAssetName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__UpdateAssetName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UpdateAssetName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UpdateAssetName %p -> %p\n", q, p));
	*(struct __ns1__UpdateAssetName*)p = *(struct __ns1__UpdateAssetName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CreateAsset(struct soap *soap, struct __ns1__CreateAsset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__CreateAsset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CreateAsset(struct soap *soap, const struct __ns1__CreateAsset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__CreateAsset(soap, &a->ns3__CreateAsset);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CreateAsset(struct soap *soap, const struct __ns1__CreateAsset *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__CreateAsset(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CreateAsset(struct soap *soap, const char *tag, int id, const struct __ns1__CreateAsset *a, const char *type)
{
	if (soap_out_PointerTo_ns3__CreateAsset(soap, "ns3:CreateAsset", -1, &a->ns3__CreateAsset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CreateAsset * SOAP_FMAC4 soap_get___ns1__CreateAsset(struct soap *soap, struct __ns1__CreateAsset *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CreateAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__CreateAsset * SOAP_FMAC4 soap_in___ns1__CreateAsset(struct soap *soap, const char *tag, struct __ns1__CreateAsset *a, const char *type)
{
	size_t soap_flag_ns3__CreateAsset = 1;
	short soap_flag;
	a = (struct __ns1__CreateAsset *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CreateAsset, sizeof(struct __ns1__CreateAsset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CreateAsset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__CreateAsset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__CreateAsset(soap, "ns3:CreateAsset", &a->ns3__CreateAsset, ""))
				{	soap_flag_ns3__CreateAsset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__CreateAsset * SOAP_FMAC4 soap_instantiate___ns1__CreateAsset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CreateAsset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__CreateAsset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__CreateAsset;
		if (size)
			*size = sizeof(struct __ns1__CreateAsset);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__CreateAsset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__CreateAsset);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__CreateAsset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__CreateAsset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__CreateAsset %p -> %p\n", q, p));
	*(struct __ns1__CreateAsset*)p = *(struct __ns1__CreateAsset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DeleteAsset(struct soap *soap, struct __ns1__DeleteAsset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__DeleteAsset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DeleteAsset(struct soap *soap, const struct __ns1__DeleteAsset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__DeleteAsset(soap, &a->ns3__DeleteAsset);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DeleteAsset(struct soap *soap, const struct __ns1__DeleteAsset *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__DeleteAsset(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DeleteAsset(struct soap *soap, const char *tag, int id, const struct __ns1__DeleteAsset *a, const char *type)
{
	if (soap_out_PointerTo_ns3__DeleteAsset(soap, "ns3:DeleteAsset", -1, &a->ns3__DeleteAsset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DeleteAsset * SOAP_FMAC4 soap_get___ns1__DeleteAsset(struct soap *soap, struct __ns1__DeleteAsset *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DeleteAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__DeleteAsset * SOAP_FMAC4 soap_in___ns1__DeleteAsset(struct soap *soap, const char *tag, struct __ns1__DeleteAsset *a, const char *type)
{
	size_t soap_flag_ns3__DeleteAsset = 1;
	short soap_flag;
	a = (struct __ns1__DeleteAsset *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DeleteAsset, sizeof(struct __ns1__DeleteAsset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DeleteAsset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__DeleteAsset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__DeleteAsset(soap, "ns3:DeleteAsset", &a->ns3__DeleteAsset, ""))
				{	soap_flag_ns3__DeleteAsset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__DeleteAsset * SOAP_FMAC4 soap_instantiate___ns1__DeleteAsset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DeleteAsset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__DeleteAsset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__DeleteAsset;
		if (size)
			*size = sizeof(struct __ns1__DeleteAsset);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__DeleteAsset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__DeleteAsset);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__DeleteAsset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__DeleteAsset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__DeleteAsset %p -> %p\n", q, p));
	*(struct __ns1__DeleteAsset*)p = *(struct __ns1__DeleteAsset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UnlockAsset(struct soap *soap, struct __ns1__UnlockAsset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__UnlockAsset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UnlockAsset(struct soap *soap, const struct __ns1__UnlockAsset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__UnlockAsset(soap, &a->ns3__UnlockAsset);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UnlockAsset(struct soap *soap, const struct __ns1__UnlockAsset *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UnlockAsset(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UnlockAsset(struct soap *soap, const char *tag, int id, const struct __ns1__UnlockAsset *a, const char *type)
{
	if (soap_out_PointerTo_ns3__UnlockAsset(soap, "ns3:UnlockAsset", -1, &a->ns3__UnlockAsset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UnlockAsset * SOAP_FMAC4 soap_get___ns1__UnlockAsset(struct soap *soap, struct __ns1__UnlockAsset *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UnlockAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__UnlockAsset * SOAP_FMAC4 soap_in___ns1__UnlockAsset(struct soap *soap, const char *tag, struct __ns1__UnlockAsset *a, const char *type)
{
	size_t soap_flag_ns3__UnlockAsset = 1;
	short soap_flag;
	a = (struct __ns1__UnlockAsset *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UnlockAsset, sizeof(struct __ns1__UnlockAsset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UnlockAsset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__UnlockAsset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__UnlockAsset(soap, "ns3:UnlockAsset", &a->ns3__UnlockAsset, ""))
				{	soap_flag_ns3__UnlockAsset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__UnlockAsset * SOAP_FMAC4 soap_instantiate___ns1__UnlockAsset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UnlockAsset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UnlockAsset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__UnlockAsset;
		if (size)
			*size = sizeof(struct __ns1__UnlockAsset);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__UnlockAsset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__UnlockAsset);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__UnlockAsset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UnlockAsset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UnlockAsset %p -> %p\n", q, p));
	*(struct __ns1__UnlockAsset*)p = *(struct __ns1__UnlockAsset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__LockAsset(struct soap *soap, struct __ns1__LockAsset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__LockAsset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__LockAsset(struct soap *soap, const struct __ns1__LockAsset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__LockAsset(soap, &a->ns3__LockAsset);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__LockAsset(struct soap *soap, const struct __ns1__LockAsset *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__LockAsset(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__LockAsset(struct soap *soap, const char *tag, int id, const struct __ns1__LockAsset *a, const char *type)
{
	if (soap_out_PointerTo_ns3__LockAsset(soap, "ns3:LockAsset", -1, &a->ns3__LockAsset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__LockAsset * SOAP_FMAC4 soap_get___ns1__LockAsset(struct soap *soap, struct __ns1__LockAsset *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__LockAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__LockAsset * SOAP_FMAC4 soap_in___ns1__LockAsset(struct soap *soap, const char *tag, struct __ns1__LockAsset *a, const char *type)
{
	size_t soap_flag_ns3__LockAsset = 1;
	short soap_flag;
	a = (struct __ns1__LockAsset *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__LockAsset, sizeof(struct __ns1__LockAsset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__LockAsset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__LockAsset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__LockAsset(soap, "ns3:LockAsset", &a->ns3__LockAsset, ""))
				{	soap_flag_ns3__LockAsset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__LockAsset * SOAP_FMAC4 soap_instantiate___ns1__LockAsset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__LockAsset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__LockAsset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__LockAsset;
		if (size)
			*size = sizeof(struct __ns1__LockAsset);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__LockAsset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__LockAsset);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__LockAsset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__LockAsset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__LockAsset %p -> %p\n", q, p));
	*(struct __ns1__LockAsset*)p = *(struct __ns1__LockAsset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetThumbnail(struct soap *soap, struct __ns1__GetThumbnail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetThumbnail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetThumbnail(struct soap *soap, const struct __ns1__GetThumbnail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetThumbnail(soap, &a->ns3__GetThumbnail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetThumbnail(struct soap *soap, const struct __ns1__GetThumbnail *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetThumbnail(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetThumbnail(struct soap *soap, const char *tag, int id, const struct __ns1__GetThumbnail *a, const char *type)
{
	if (soap_out_PointerTo_ns3__GetThumbnail(soap, "ns3:GetThumbnail", -1, &a->ns3__GetThumbnail, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetThumbnail * SOAP_FMAC4 soap_get___ns1__GetThumbnail(struct soap *soap, struct __ns1__GetThumbnail *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetThumbnail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetThumbnail * SOAP_FMAC4 soap_in___ns1__GetThumbnail(struct soap *soap, const char *tag, struct __ns1__GetThumbnail *a, const char *type)
{
	size_t soap_flag_ns3__GetThumbnail = 1;
	short soap_flag;
	a = (struct __ns1__GetThumbnail *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetThumbnail, sizeof(struct __ns1__GetThumbnail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetThumbnail(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetThumbnail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetThumbnail(soap, "ns3:GetThumbnail", &a->ns3__GetThumbnail, ""))
				{	soap_flag_ns3__GetThumbnail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetThumbnail * SOAP_FMAC4 soap_instantiate___ns1__GetThumbnail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetThumbnail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetThumbnail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetThumbnail;
		if (size)
			*size = sizeof(struct __ns1__GetThumbnail);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetThumbnail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetThumbnail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetThumbnail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetThumbnail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetThumbnail %p -> %p\n", q, p));
	*(struct __ns1__GetThumbnail*)p = *(struct __ns1__GetThumbnail*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetUser(struct soap *soap, struct __ns1__GetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetUser(struct soap *soap, const struct __ns1__GetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetUser(soap, &a->ns3__GetUser);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetUser(struct soap *soap, const struct __ns1__GetUser *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetUser(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetUser(struct soap *soap, const char *tag, int id, const struct __ns1__GetUser *a, const char *type)
{
	if (soap_out_PointerTo_ns3__GetUser(soap, "ns3:GetUser", -1, &a->ns3__GetUser, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUser * SOAP_FMAC4 soap_get___ns1__GetUser(struct soap *soap, struct __ns1__GetUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetUser * SOAP_FMAC4 soap_in___ns1__GetUser(struct soap *soap, const char *tag, struct __ns1__GetUser *a, const char *type)
{
	size_t soap_flag_ns3__GetUser = 1;
	short soap_flag;
	a = (struct __ns1__GetUser *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetUser, sizeof(struct __ns1__GetUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetUser(soap, "ns3:GetUser", &a->ns3__GetUser, ""))
				{	soap_flag_ns3__GetUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetUser * SOAP_FMAC4 soap_instantiate___ns1__GetUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetUser;
		if (size)
			*size = sizeof(struct __ns1__GetUser);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetUser[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetUser);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetUser*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetUser %p -> %p\n", q, p));
	*(struct __ns1__GetUser*)p = *(struct __ns1__GetUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Logoff(struct soap *soap, struct __ns1__Logoff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__Logoff = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Logoff(struct soap *soap, const struct __ns1__Logoff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__Logoff(soap, &a->ns3__Logoff);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Logoff(struct soap *soap, const struct __ns1__Logoff *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__Logoff(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Logoff(struct soap *soap, const char *tag, int id, const struct __ns1__Logoff *a, const char *type)
{
	if (soap_out_PointerTo_ns3__Logoff(soap, "ns3:Logoff", -1, &a->ns3__Logoff, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Logoff * SOAP_FMAC4 soap_get___ns1__Logoff(struct soap *soap, struct __ns1__Logoff *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Logoff(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__Logoff * SOAP_FMAC4 soap_in___ns1__Logoff(struct soap *soap, const char *tag, struct __ns1__Logoff *a, const char *type)
{
	size_t soap_flag_ns3__Logoff = 1;
	short soap_flag;
	a = (struct __ns1__Logoff *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Logoff, sizeof(struct __ns1__Logoff), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Logoff(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__Logoff && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__Logoff(soap, "ns3:Logoff", &a->ns3__Logoff, ""))
				{	soap_flag_ns3__Logoff--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__Logoff * SOAP_FMAC4 soap_instantiate___ns1__Logoff(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Logoff(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__Logoff, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__Logoff;
		if (size)
			*size = sizeof(struct __ns1__Logoff);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__Logoff[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__Logoff);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__Logoff*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__Logoff(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__Logoff %p -> %p\n", q, p));
	*(struct __ns1__Logoff*)p = *(struct __ns1__Logoff*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetShelveList(struct soap *soap, struct __ns1__GetShelveList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetShelveList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetShelveList(struct soap *soap, const struct __ns1__GetShelveList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetShelveList(soap, &a->ns3__GetShelveList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetShelveList(struct soap *soap, const struct __ns1__GetShelveList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetShelveList(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetShelveList(struct soap *soap, const char *tag, int id, const struct __ns1__GetShelveList *a, const char *type)
{
	if (soap_out_PointerTo_ns3__GetShelveList(soap, "ns3:GetShelveList", -1, &a->ns3__GetShelveList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetShelveList * SOAP_FMAC4 soap_get___ns1__GetShelveList(struct soap *soap, struct __ns1__GetShelveList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetShelveList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetShelveList * SOAP_FMAC4 soap_in___ns1__GetShelveList(struct soap *soap, const char *tag, struct __ns1__GetShelveList *a, const char *type)
{
	size_t soap_flag_ns3__GetShelveList = 1;
	short soap_flag;
	a = (struct __ns1__GetShelveList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetShelveList, sizeof(struct __ns1__GetShelveList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetShelveList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetShelveList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetShelveList(soap, "ns3:GetShelveList", &a->ns3__GetShelveList, ""))
				{	soap_flag_ns3__GetShelveList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetShelveList * SOAP_FMAC4 soap_instantiate___ns1__GetShelveList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetShelveList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetShelveList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetShelveList;
		if (size)
			*size = sizeof(struct __ns1__GetShelveList);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetShelveList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetShelveList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetShelveList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetShelveList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetShelveList %p -> %p\n", q, p));
	*(struct __ns1__GetShelveList*)p = *(struct __ns1__GetShelveList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetTags(struct soap *soap, struct __ns1__GetTags *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetTags = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetTags(struct soap *soap, const struct __ns1__GetTags *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetTags(soap, &a->ns3__GetTags);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetTags(struct soap *soap, const struct __ns1__GetTags *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetTags(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetTags(struct soap *soap, const char *tag, int id, const struct __ns1__GetTags *a, const char *type)
{
	if (soap_out_PointerTo_ns3__GetTags(soap, "ns3:GetTags", -1, &a->ns3__GetTags, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTags * SOAP_FMAC4 soap_get___ns1__GetTags(struct soap *soap, struct __ns1__GetTags *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetTags(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetTags * SOAP_FMAC4 soap_in___ns1__GetTags(struct soap *soap, const char *tag, struct __ns1__GetTags *a, const char *type)
{
	size_t soap_flag_ns3__GetTags = 1;
	short soap_flag;
	a = (struct __ns1__GetTags *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetTags, sizeof(struct __ns1__GetTags), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetTags(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetTags && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetTags(soap, "ns3:GetTags", &a->ns3__GetTags, ""))
				{	soap_flag_ns3__GetTags--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetTags * SOAP_FMAC4 soap_instantiate___ns1__GetTags(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetTags(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetTags, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetTags;
		if (size)
			*size = sizeof(struct __ns1__GetTags);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetTags[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetTags);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetTags*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetTags(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetTags %p -> %p\n", q, p));
	*(struct __ns1__GetTags*)p = *(struct __ns1__GetTags*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetCommentList(struct soap *soap, struct __ns1__GetCommentList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetCommentList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetCommentList(struct soap *soap, const struct __ns1__GetCommentList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetCommentList(soap, &a->ns3__GetCommentList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetCommentList(struct soap *soap, const struct __ns1__GetCommentList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetCommentList(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetCommentList(struct soap *soap, const char *tag, int id, const struct __ns1__GetCommentList *a, const char *type)
{
	if (soap_out_PointerTo_ns3__GetCommentList(soap, "ns3:GetCommentList", -1, &a->ns3__GetCommentList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetCommentList * SOAP_FMAC4 soap_get___ns1__GetCommentList(struct soap *soap, struct __ns1__GetCommentList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetCommentList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetCommentList * SOAP_FMAC4 soap_in___ns1__GetCommentList(struct soap *soap, const char *tag, struct __ns1__GetCommentList *a, const char *type)
{
	size_t soap_flag_ns3__GetCommentList = 1;
	short soap_flag;
	a = (struct __ns1__GetCommentList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetCommentList, sizeof(struct __ns1__GetCommentList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetCommentList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetCommentList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetCommentList(soap, "ns3:GetCommentList", &a->ns3__GetCommentList, ""))
				{	soap_flag_ns3__GetCommentList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetCommentList * SOAP_FMAC4 soap_instantiate___ns1__GetCommentList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetCommentList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetCommentList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetCommentList;
		if (size)
			*size = sizeof(struct __ns1__GetCommentList);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetCommentList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetCommentList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetCommentList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetCommentList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetCommentList %p -> %p\n", q, p));
	*(struct __ns1__GetCommentList*)p = *(struct __ns1__GetCommentList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRole(struct soap *soap, struct __ns1__GetRole *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetRole = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRole(struct soap *soap, const struct __ns1__GetRole *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetRole(soap, &a->ns3__GetRole);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRole(struct soap *soap, const struct __ns1__GetRole *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetRole(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetRole(struct soap *soap, const char *tag, int id, const struct __ns1__GetRole *a, const char *type)
{
	if (soap_out_PointerTo_ns3__GetRole(soap, "ns3:GetRole", -1, &a->ns3__GetRole, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRole * SOAP_FMAC4 soap_get___ns1__GetRole(struct soap *soap, struct __ns1__GetRole *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetRole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetRole * SOAP_FMAC4 soap_in___ns1__GetRole(struct soap *soap, const char *tag, struct __ns1__GetRole *a, const char *type)
{
	size_t soap_flag_ns3__GetRole = 1;
	short soap_flag;
	a = (struct __ns1__GetRole *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetRole, sizeof(struct __ns1__GetRole), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetRole(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetRole && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetRole(soap, "ns3:GetRole", &a->ns3__GetRole, ""))
				{	soap_flag_ns3__GetRole--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetRole * SOAP_FMAC4 soap_instantiate___ns1__GetRole(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRole(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetRole, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetRole;
		if (size)
			*size = sizeof(struct __ns1__GetRole);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetRole[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetRole);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetRole*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetRole(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetRole %p -> %p\n", q, p));
	*(struct __ns1__GetRole*)p = *(struct __ns1__GetRole*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetTitleList(struct soap *soap, struct __ns1__GetTitleList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetTitleList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetTitleList(struct soap *soap, const struct __ns1__GetTitleList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetTitleList(soap, &a->ns3__GetTitleList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetTitleList(struct soap *soap, const struct __ns1__GetTitleList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetTitleList(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetTitleList(struct soap *soap, const char *tag, int id, const struct __ns1__GetTitleList *a, const char *type)
{
	if (soap_out_PointerTo_ns3__GetTitleList(soap, "ns3:GetTitleList", -1, &a->ns3__GetTitleList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTitleList * SOAP_FMAC4 soap_get___ns1__GetTitleList(struct soap *soap, struct __ns1__GetTitleList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetTitleList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetTitleList * SOAP_FMAC4 soap_in___ns1__GetTitleList(struct soap *soap, const char *tag, struct __ns1__GetTitleList *a, const char *type)
{
	size_t soap_flag_ns3__GetTitleList = 1;
	short soap_flag;
	a = (struct __ns1__GetTitleList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetTitleList, sizeof(struct __ns1__GetTitleList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetTitleList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetTitleList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetTitleList(soap, "ns3:GetTitleList", &a->ns3__GetTitleList, ""))
				{	soap_flag_ns3__GetTitleList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetTitleList * SOAP_FMAC4 soap_instantiate___ns1__GetTitleList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetTitleList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetTitleList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetTitleList;
		if (size)
			*size = sizeof(struct __ns1__GetTitleList);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetTitleList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetTitleList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetTitleList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetTitleList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetTitleList %p -> %p\n", q, p));
	*(struct __ns1__GetTitleList*)p = *(struct __ns1__GetTitleList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Login(struct soap *soap, struct __ns1__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__Login = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Login(struct soap *soap, const struct __ns1__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__Login(soap, &a->ns3__Login);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Login(struct soap *soap, const struct __ns1__Login *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__Login(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Login(struct soap *soap, const char *tag, int id, const struct __ns1__Login *a, const char *type)
{
	if (soap_out_PointerTo_ns3__Login(soap, "ns3:Login", -1, &a->ns3__Login, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login * SOAP_FMAC4 soap_get___ns1__Login(struct soap *soap, struct __ns1__Login *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__Login * SOAP_FMAC4 soap_in___ns1__Login(struct soap *soap, const char *tag, struct __ns1__Login *a, const char *type)
{
	size_t soap_flag_ns3__Login = 1;
	short soap_flag;
	a = (struct __ns1__Login *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Login, sizeof(struct __ns1__Login), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Login(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__Login && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__Login(soap, "ns3:Login", &a->ns3__Login, ""))
				{	soap_flag_ns3__Login--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__Login * SOAP_FMAC4 soap_instantiate___ns1__Login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Login(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__Login, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__Login;
		if (size)
			*size = sizeof(struct __ns1__Login);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__Login[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__Login);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__Login*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__Login(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__Login %p -> %p\n", q, p));
	*(struct __ns1__Login*)p = *(struct __ns1__Login*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DeleteTask(struct soap *soap, struct __ns1__DeleteTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__DeleteTask = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DeleteTask(struct soap *soap, const struct __ns1__DeleteTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__DeleteTask(soap, &a->ns3__DeleteTask);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DeleteTask(struct soap *soap, const struct __ns1__DeleteTask *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__DeleteTask(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DeleteTask(struct soap *soap, const char *tag, int id, const struct __ns1__DeleteTask *a, const char *type)
{
	if (soap_out_PointerTo_ns3__DeleteTask(soap, "ns3:DeleteTask", -1, &a->ns3__DeleteTask, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DeleteTask * SOAP_FMAC4 soap_get___ns1__DeleteTask(struct soap *soap, struct __ns1__DeleteTask *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DeleteTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__DeleteTask * SOAP_FMAC4 soap_in___ns1__DeleteTask(struct soap *soap, const char *tag, struct __ns1__DeleteTask *a, const char *type)
{
	size_t soap_flag_ns3__DeleteTask = 1;
	short soap_flag;
	a = (struct __ns1__DeleteTask *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DeleteTask, sizeof(struct __ns1__DeleteTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DeleteTask(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__DeleteTask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__DeleteTask(soap, "ns3:DeleteTask", &a->ns3__DeleteTask, ""))
				{	soap_flag_ns3__DeleteTask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__DeleteTask * SOAP_FMAC4 soap_instantiate___ns1__DeleteTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DeleteTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__DeleteTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__DeleteTask;
		if (size)
			*size = sizeof(struct __ns1__DeleteTask);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__DeleteTask[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__DeleteTask);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__DeleteTask*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__DeleteTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__DeleteTask %p -> %p\n", q, p));
	*(struct __ns1__DeleteTask*)p = *(struct __ns1__DeleteTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetTaskHistory(struct soap *soap, struct __ns1__GetTaskHistory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetTaskHistory = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetTaskHistory(struct soap *soap, const struct __ns1__GetTaskHistory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetTaskHistory(soap, &a->ns3__GetTaskHistory);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetTaskHistory(struct soap *soap, const struct __ns1__GetTaskHistory *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetTaskHistory(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetTaskHistory(struct soap *soap, const char *tag, int id, const struct __ns1__GetTaskHistory *a, const char *type)
{
	if (soap_out_PointerTo_ns3__GetTaskHistory(soap, "ns3:GetTaskHistory", -1, &a->ns3__GetTaskHistory, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTaskHistory * SOAP_FMAC4 soap_get___ns1__GetTaskHistory(struct soap *soap, struct __ns1__GetTaskHistory *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetTaskHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetTaskHistory * SOAP_FMAC4 soap_in___ns1__GetTaskHistory(struct soap *soap, const char *tag, struct __ns1__GetTaskHistory *a, const char *type)
{
	size_t soap_flag_ns3__GetTaskHistory = 1;
	short soap_flag;
	a = (struct __ns1__GetTaskHistory *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetTaskHistory, sizeof(struct __ns1__GetTaskHistory), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetTaskHistory(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetTaskHistory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetTaskHistory(soap, "ns3:GetTaskHistory", &a->ns3__GetTaskHistory, ""))
				{	soap_flag_ns3__GetTaskHistory--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetTaskHistory * SOAP_FMAC4 soap_instantiate___ns1__GetTaskHistory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetTaskHistory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetTaskHistory, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetTaskHistory;
		if (size)
			*size = sizeof(struct __ns1__GetTaskHistory);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetTaskHistory[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetTaskHistory);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetTaskHistory*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetTaskHistory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetTaskHistory %p -> %p\n", q, p));
	*(struct __ns1__GetTaskHistory*)p = *(struct __ns1__GetTaskHistory*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdateTask(struct soap *soap, struct __ns1__UpdateTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__UpdateTask = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdateTask(struct soap *soap, const struct __ns1__UpdateTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__UpdateTask(soap, &a->ns3__UpdateTask);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdateTask(struct soap *soap, const struct __ns1__UpdateTask *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UpdateTask(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdateTask(struct soap *soap, const char *tag, int id, const struct __ns1__UpdateTask *a, const char *type)
{
	if (soap_out_PointerTo_ns3__UpdateTask(soap, "ns3:UpdateTask", -1, &a->ns3__UpdateTask, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateTask * SOAP_FMAC4 soap_get___ns1__UpdateTask(struct soap *soap, struct __ns1__UpdateTask *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdateTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__UpdateTask * SOAP_FMAC4 soap_in___ns1__UpdateTask(struct soap *soap, const char *tag, struct __ns1__UpdateTask *a, const char *type)
{
	size_t soap_flag_ns3__UpdateTask = 1;
	short soap_flag;
	a = (struct __ns1__UpdateTask *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdateTask, sizeof(struct __ns1__UpdateTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdateTask(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__UpdateTask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__UpdateTask(soap, "ns3:UpdateTask", &a->ns3__UpdateTask, ""))
				{	soap_flag_ns3__UpdateTask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__UpdateTask * SOAP_FMAC4 soap_instantiate___ns1__UpdateTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdateTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UpdateTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__UpdateTask;
		if (size)
			*size = sizeof(struct __ns1__UpdateTask);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__UpdateTask[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__UpdateTask);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__UpdateTask*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UpdateTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UpdateTask %p -> %p\n", q, p));
	*(struct __ns1__UpdateTask*)p = *(struct __ns1__UpdateTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetTaskCategoryList(struct soap *soap, struct __ns1__GetTaskCategoryList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetTaskCategoryList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetTaskCategoryList(struct soap *soap, const struct __ns1__GetTaskCategoryList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetTaskCategoryList(soap, &a->ns3__GetTaskCategoryList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetTaskCategoryList(struct soap *soap, const struct __ns1__GetTaskCategoryList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetTaskCategoryList(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetTaskCategoryList(struct soap *soap, const char *tag, int id, const struct __ns1__GetTaskCategoryList *a, const char *type)
{
	if (soap_out_PointerTo_ns3__GetTaskCategoryList(soap, "ns3:GetTaskCategoryList", -1, &a->ns3__GetTaskCategoryList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTaskCategoryList * SOAP_FMAC4 soap_get___ns1__GetTaskCategoryList(struct soap *soap, struct __ns1__GetTaskCategoryList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetTaskCategoryList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetTaskCategoryList * SOAP_FMAC4 soap_in___ns1__GetTaskCategoryList(struct soap *soap, const char *tag, struct __ns1__GetTaskCategoryList *a, const char *type)
{
	size_t soap_flag_ns3__GetTaskCategoryList = 1;
	short soap_flag;
	a = (struct __ns1__GetTaskCategoryList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetTaskCategoryList, sizeof(struct __ns1__GetTaskCategoryList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetTaskCategoryList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetTaskCategoryList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetTaskCategoryList(soap, "ns3:GetTaskCategoryList", &a->ns3__GetTaskCategoryList, ""))
				{	soap_flag_ns3__GetTaskCategoryList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetTaskCategoryList * SOAP_FMAC4 soap_instantiate___ns1__GetTaskCategoryList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetTaskCategoryList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetTaskCategoryList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetTaskCategoryList;
		if (size)
			*size = sizeof(struct __ns1__GetTaskCategoryList);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetTaskCategoryList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetTaskCategoryList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetTaskCategoryList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetTaskCategoryList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetTaskCategoryList %p -> %p\n", q, p));
	*(struct __ns1__GetTaskCategoryList*)p = *(struct __ns1__GetTaskCategoryList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CreateTask(struct soap *soap, struct __ns1__CreateTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__CreateTask = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CreateTask(struct soap *soap, const struct __ns1__CreateTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__CreateTask(soap, &a->ns3__CreateTask);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CreateTask(struct soap *soap, const struct __ns1__CreateTask *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__CreateTask(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CreateTask(struct soap *soap, const char *tag, int id, const struct __ns1__CreateTask *a, const char *type)
{
	if (soap_out_PointerTo_ns3__CreateTask(soap, "ns3:CreateTask", -1, &a->ns3__CreateTask, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CreateTask * SOAP_FMAC4 soap_get___ns1__CreateTask(struct soap *soap, struct __ns1__CreateTask *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CreateTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__CreateTask * SOAP_FMAC4 soap_in___ns1__CreateTask(struct soap *soap, const char *tag, struct __ns1__CreateTask *a, const char *type)
{
	size_t soap_flag_ns3__CreateTask = 1;
	short soap_flag;
	a = (struct __ns1__CreateTask *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CreateTask, sizeof(struct __ns1__CreateTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CreateTask(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__CreateTask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__CreateTask(soap, "ns3:CreateTask", &a->ns3__CreateTask, ""))
				{	soap_flag_ns3__CreateTask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__CreateTask * SOAP_FMAC4 soap_instantiate___ns1__CreateTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CreateTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__CreateTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__CreateTask;
		if (size)
			*size = sizeof(struct __ns1__CreateTask);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__CreateTask[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__CreateTask);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__CreateTask*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__CreateTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__CreateTask %p -> %p\n", q, p));
	*(struct __ns1__CreateTask*)p = *(struct __ns1__CreateTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetTaskStatusList(struct soap *soap, struct __ns1__GetTaskStatusList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetTaskStatusList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetTaskStatusList(struct soap *soap, const struct __ns1__GetTaskStatusList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetTaskStatusList(soap, &a->ns3__GetTaskStatusList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetTaskStatusList(struct soap *soap, const struct __ns1__GetTaskStatusList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetTaskStatusList(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetTaskStatusList(struct soap *soap, const char *tag, int id, const struct __ns1__GetTaskStatusList *a, const char *type)
{
	if (soap_out_PointerTo_ns3__GetTaskStatusList(soap, "ns3:GetTaskStatusList", -1, &a->ns3__GetTaskStatusList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTaskStatusList * SOAP_FMAC4 soap_get___ns1__GetTaskStatusList(struct soap *soap, struct __ns1__GetTaskStatusList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetTaskStatusList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetTaskStatusList * SOAP_FMAC4 soap_in___ns1__GetTaskStatusList(struct soap *soap, const char *tag, struct __ns1__GetTaskStatusList *a, const char *type)
{
	size_t soap_flag_ns3__GetTaskStatusList = 1;
	short soap_flag;
	a = (struct __ns1__GetTaskStatusList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetTaskStatusList, sizeof(struct __ns1__GetTaskStatusList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetTaskStatusList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetTaskStatusList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetTaskStatusList(soap, "ns3:GetTaskStatusList", &a->ns3__GetTaskStatusList, ""))
				{	soap_flag_ns3__GetTaskStatusList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetTaskStatusList * SOAP_FMAC4 soap_instantiate___ns1__GetTaskStatusList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetTaskStatusList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetTaskStatusList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetTaskStatusList;
		if (size)
			*size = sizeof(struct __ns1__GetTaskStatusList);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetTaskStatusList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetTaskStatusList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetTaskStatusList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetTaskStatusList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetTaskStatusList %p -> %p\n", q, p));
	*(struct __ns1__GetTaskStatusList*)p = *(struct __ns1__GetTaskStatusList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetUsersForTitle(struct soap *soap, struct __ns1__GetUsersForTitle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetUsersForTitle = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetUsersForTitle(struct soap *soap, const struct __ns1__GetUsersForTitle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns3__GetUsersForTitle(soap, &a->ns3__GetUsersForTitle);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetUsersForTitle(struct soap *soap, const struct __ns1__GetUsersForTitle *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetUsersForTitle(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetUsersForTitle(struct soap *soap, const char *tag, int id, const struct __ns1__GetUsersForTitle *a, const char *type)
{
	if (soap_out_PointerTo_ns3__GetUsersForTitle(soap, "ns3:GetUsersForTitle", -1, &a->ns3__GetUsersForTitle, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUsersForTitle * SOAP_FMAC4 soap_get___ns1__GetUsersForTitle(struct soap *soap, struct __ns1__GetUsersForTitle *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetUsersForTitle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__GetUsersForTitle * SOAP_FMAC4 soap_in___ns1__GetUsersForTitle(struct soap *soap, const char *tag, struct __ns1__GetUsersForTitle *a, const char *type)
{
	size_t soap_flag_ns3__GetUsersForTitle = 1;
	short soap_flag;
	a = (struct __ns1__GetUsersForTitle *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetUsersForTitle, sizeof(struct __ns1__GetUsersForTitle), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetUsersForTitle(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetUsersForTitle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetUsersForTitle(soap, "ns3:GetUsersForTitle", &a->ns3__GetUsersForTitle, ""))
				{	soap_flag_ns3__GetUsersForTitle--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetUsersForTitle * SOAP_FMAC4 soap_instantiate___ns1__GetUsersForTitle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetUsersForTitle(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetUsersForTitle, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetUsersForTitle;
		if (size)
			*size = sizeof(struct __ns1__GetUsersForTitle);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetUsersForTitle[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetUsersForTitle);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetUsersForTitle*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetUsersForTitle(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetUsersForTitle %p -> %p\n", q, p));
	*(struct __ns1__GetUsersForTitle*)p = *(struct __ns1__GetUsersForTitle*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xop__Include(struct soap *soap, struct _xop__Include *a)
{
	a->__size = 0;
	a->__ptr = NULL;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xop__Include(struct soap *soap, struct _xop__Include const*a)
{
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE__xop__Include))
		if (a->id || a->type)
			soap->mode |= SOAP_ENC_DIME;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xop__Include(struct soap *soap, const struct _xop__Include *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE__xop__Include);
	if (soap_out__xop__Include(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xop__Include(struct soap *soap, const char *tag, int id, const struct _xop__Include *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE__xop__Include);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE__xop__Include);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_get__xop__Include(struct soap *soap, struct _xop__Include *p, const char *tag, const char *type)
{
	if ((p = soap_in__xop__Include(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_in__xop__Include(struct soap *soap, const char *tag, struct _xop__Include *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct _xop__Include *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xop__Include, sizeof(struct _xop__Include), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__xop__Include(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (struct _xop__Include *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xop__Include, 0, sizeof(struct _xop__Include), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_instantiate__xop__Include(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__xop__Include(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__xop__Include, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct _xop__Include;
		if (size)
			*size = sizeof(struct _xop__Include);
	}
	else
	{	cp->ptr = (void*)new struct _xop__Include[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _xop__Include);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _xop__Include*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__xop__Include(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _xop__Include %p -> %p\n", q, p));
	*(struct _xop__Include*)p = *(struct _xop__Include*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Security(struct soap *soap, struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsu__Timestamp = NULL;
	a->UsernameToken = NULL;
	a->BinarySecurityToken = NULL;
	a->ds__Signature = NULL;
	soap_default_string(soap, &a->SOAP_ENV__actor);
	soap_default_string(soap, &a->SOAP_ENV__role);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Security(struct soap *soap, const struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsu__Timestamp(soap, &a->wsu__Timestamp);
	soap_serialize_PointerTo_wsse__UsernameToken(soap, &a->UsernameToken);
	soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, &a->BinarySecurityToken);
	soap_serialize_PointerTods__SignatureType(soap, &a->ds__Signature);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Security(struct soap *soap, const struct _wsse__Security *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Security);
	if (soap_out__wsse__Security(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Security(struct soap *soap, const char *tag, int id, const struct _wsse__Security *a, const char *type)
{
	if (a->SOAP_ENV__actor)
		soap_set_attr(soap, "SOAP-ENV:actor", a->SOAP_ENV__actor);
	if (a->SOAP_ENV__role)
		soap_set_attr(soap, "SOAP-ENV:role", a->SOAP_ENV__role);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Security), type))
		return soap->error;
	if (soap_out_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", -1, &a->wsu__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", -1, &a->UsernameToken, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", -1, &a->BinarySecurityToken, ""))
		return soap->error;
	if (soap_out_PointerTods__SignatureType(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_get__wsse__Security(struct soap *soap, struct _wsse__Security *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_in__wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security *a, const char *type)
{
	size_t soap_flag_wsu__Timestamp = 1;
	size_t soap_flag_UsernameToken = 1;
	size_t soap_flag_BinarySecurityToken = 1;
	size_t soap_flag_ds__Signature = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Security *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Security(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:actor", 0), &a->SOAP_ENV__actor))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:role", 0), &a->SOAP_ENV__role))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsu__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", &a->wsu__Timestamp, ""))
				{	soap_flag_wsu__Timestamp--;
					continue;
				}
			if (soap_flag_UsernameToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", &a->UsernameToken, ""))
				{	soap_flag_UsernameToken--;
					continue;
				}
			if (soap_flag_BinarySecurityToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", &a->BinarySecurityToken, ""))
				{	soap_flag_BinarySecurityToken--;
					continue;
				}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureType(soap, "ds:Signature", &a->ds__Signature, "ds:SignatureType"))
				{	soap_flag_ds__Signature--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Security, 0, sizeof(struct _wsse__Security), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_instantiate__wsse__Security(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Security(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__Security, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct _wsse__Security;
		if (size)
			*size = sizeof(struct _wsse__Security);
	}
	else
	{	cp->ptr = (void*)new struct _wsse__Security[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__Security);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__Security*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__Security(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__Security %p -> %p\n", q, p));
	*(struct _wsse__Security*)p = *(struct _wsse__Security*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Modulus);
	soap_default_string(soap, &a->Exponent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Modulus);
	soap_serialize_string(soap, &a->Exponent);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RSAKeyValueType);
	if (soap_out_ds__RSAKeyValueType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__RSAKeyValueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RSAKeyValueType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:Modulus", -1, &a->Modulus, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:Exponent", -1, &a->Exponent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_get_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_in_ds__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType *a, const char *type)
{
	size_t soap_flag_Modulus = 1;
	size_t soap_flag_Exponent = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Modulus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Modulus", &a->Modulus, "xsd:string"))
				{	soap_flag_Modulus--;
					continue;
				}
			if (soap_flag_Exponent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Exponent", &a->Exponent, "xsd:string"))
				{	soap_flag_Exponent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RSAKeyValueType, 0, sizeof(struct ds__RSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_Modulus > 0 || soap_flag_Exponent > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_instantiate_ds__RSAKeyValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__RSAKeyValueType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__RSAKeyValueType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ds__RSAKeyValueType;
		if (size)
			*size = sizeof(struct ds__RSAKeyValueType);
	}
	else
	{	cp->ptr = (void*)new struct ds__RSAKeyValueType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__RSAKeyValueType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__RSAKeyValueType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__RSAKeyValueType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__RSAKeyValueType %p -> %p\n", q, p));
	*(struct ds__RSAKeyValueType*)p = *(struct ds__RSAKeyValueType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->G);
	soap_default_string(soap, &a->Y);
	soap_default_string(soap, &a->J);
	soap_default_string(soap, &a->P);
	soap_default_string(soap, &a->Q);
	soap_default_string(soap, &a->Seed);
	soap_default_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->G);
	soap_serialize_string(soap, &a->Y);
	soap_serialize_string(soap, &a->J);
	soap_serialize_string(soap, &a->P);
	soap_serialize_string(soap, &a->Q);
	soap_serialize_string(soap, &a->Seed);
	soap_serialize_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DSAKeyValueType);
	if (soap_out_ds__DSAKeyValueType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__DSAKeyValueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DSAKeyValueType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:G", -1, &a->G, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:Y", -1, &a->Y, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:J", -1, &a->J, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:P", -1, &a->P, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:Q", -1, &a->Q, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:Seed", -1, &a->Seed, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:PgenCounter", -1, &a->PgenCounter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_get_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_in_ds__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType *a, const char *type)
{
	size_t soap_flag_G = 1;
	size_t soap_flag_Y = 1;
	size_t soap_flag_J = 1;
	size_t soap_flag_P = 1;
	size_t soap_flag_Q = 1;
	size_t soap_flag_Seed = 1;
	size_t soap_flag_PgenCounter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_G && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:G", &a->G, "xsd:string"))
				{	soap_flag_G--;
					continue;
				}
			if (soap_flag_Y && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Y", &a->Y, "xsd:string"))
				{	soap_flag_Y--;
					continue;
				}
			if (soap_flag_J && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:J", &a->J, "xsd:string"))
				{	soap_flag_J--;
					continue;
				}
			if (soap_flag_P && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:P", &a->P, "xsd:string"))
				{	soap_flag_P--;
					continue;
				}
			if (soap_flag_Q && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Q", &a->Q, "xsd:string"))
				{	soap_flag_Q--;
					continue;
				}
			if (soap_flag_Seed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Seed", &a->Seed, "xsd:string"))
				{	soap_flag_Seed--;
					continue;
				}
			if (soap_flag_PgenCounter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:PgenCounter", &a->PgenCounter, "xsd:string"))
				{	soap_flag_PgenCounter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DSAKeyValueType, 0, sizeof(struct ds__DSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_Y > 0 || soap_flag_P > 0 || soap_flag_Q > 0 || soap_flag_Seed > 0 || soap_flag_PgenCounter > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_instantiate_ds__DSAKeyValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__DSAKeyValueType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__DSAKeyValueType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ds__DSAKeyValueType;
		if (size)
			*size = sizeof(struct ds__DSAKeyValueType);
	}
	else
	{	cp->ptr = (void*)new struct ds__DSAKeyValueType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__DSAKeyValueType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__DSAKeyValueType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__DSAKeyValueType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__DSAKeyValueType %p -> %p\n", q, p));
	*(struct ds__DSAKeyValueType*)p = *(struct ds__DSAKeyValueType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->X509IssuerName);
	soap_default_int(soap, &a->X509SerialNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->X509IssuerName);
	soap_embedded(soap, &a->X509SerialNumber, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509IssuerSerialType);
	if (soap_out_ds__X509IssuerSerialType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509IssuerSerialType(struct soap *soap, const char *tag, int id, const struct ds__X509IssuerSerialType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509IssuerSerialType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:X509IssuerName", -1, &a->X509IssuerName, ""))
		return soap->error;
	if (soap_out_int(soap, "ds:X509SerialNumber", -1, &a->X509SerialNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_get_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_in_ds__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType *a, const char *type)
{
	size_t soap_flag_X509IssuerName = 1;
	size_t soap_flag_X509SerialNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509IssuerSerialType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509IssuerSerialType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509IssuerName", &a->X509IssuerName, "xsd:string"))
				{	soap_flag_X509IssuerName--;
					continue;
				}
			if (soap_flag_X509SerialNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ds:X509SerialNumber", &a->X509SerialNumber, "xsd:int"))
				{	soap_flag_X509SerialNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509IssuerSerialType, 0, sizeof(struct ds__X509IssuerSerialType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_X509IssuerName > 0 || soap_flag_X509SerialNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_instantiate_ds__X509IssuerSerialType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__X509IssuerSerialType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__X509IssuerSerialType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ds__X509IssuerSerialType;
		if (size)
			*size = sizeof(struct ds__X509IssuerSerialType);
	}
	else
	{	cp->ptr = (void*)new struct ds__X509IssuerSerialType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__X509IssuerSerialType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__X509IssuerSerialType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__X509IssuerSerialType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__X509IssuerSerialType %p -> %p\n", q, p));
	*(struct ds__X509IssuerSerialType*)p = *(struct ds__X509IssuerSerialType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509DataType(struct soap *soap, struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->X509IssuerSerial = NULL;
	soap_default_string(soap, &a->X509SKI);
	soap_default_string(soap, &a->X509SubjectName);
	soap_default_string(soap, &a->X509Certificate);
	soap_default_string(soap, &a->X509CRL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__X509IssuerSerialType(soap, &a->X509IssuerSerial);
	soap_serialize_string(soap, &a->X509SKI);
	soap_serialize_string(soap, &a->X509SubjectName);
	soap_serialize_string(soap, &a->X509Certificate);
	soap_serialize_string(soap, &a->X509CRL);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509DataType);
	if (soap_out_ds__X509DataType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509DataType(struct soap *soap, const char *tag, int id, const struct ds__X509DataType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509DataType), type))
		return soap->error;
	if (soap_out_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", -1, &a->X509IssuerSerial, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509SKI", -1, &a->X509SKI, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509SubjectName", -1, &a->X509SubjectName, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509Certificate", -1, &a->X509Certificate, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509CRL", -1, &a->X509CRL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_get_ds__X509DataType(struct soap *soap, struct ds__X509DataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_in_ds__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType *a, const char *type)
{
	size_t soap_flag_X509IssuerSerial = 1;
	size_t soap_flag_X509SKI = 1;
	size_t soap_flag_X509SubjectName = 1;
	size_t soap_flag_X509Certificate = 1;
	size_t soap_flag_X509CRL = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509DataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509DataType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerSerial && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", &a->X509IssuerSerial, "ds:X509IssuerSerialType"))
				{	soap_flag_X509IssuerSerial--;
					continue;
				}
			if (soap_flag_X509SKI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SKI", &a->X509SKI, "xsd:string"))
				{	soap_flag_X509SKI--;
					continue;
				}
			if (soap_flag_X509SubjectName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SubjectName", &a->X509SubjectName, "xsd:string"))
				{	soap_flag_X509SubjectName--;
					continue;
				}
			if (soap_flag_X509Certificate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509Certificate", &a->X509Certificate, "xsd:string"))
				{	soap_flag_X509Certificate--;
					continue;
				}
			if (soap_flag_X509CRL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509CRL", &a->X509CRL, "xsd:string"))
				{	soap_flag_X509CRL--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509DataType, 0, sizeof(struct ds__X509DataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_X509IssuerSerial > 0 || soap_flag_X509SKI > 0 || soap_flag_X509SubjectName > 0 || soap_flag_X509Certificate > 0 || soap_flag_X509CRL > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_instantiate_ds__X509DataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__X509DataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__X509DataType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ds__X509DataType;
		if (size)
			*size = sizeof(struct ds__X509DataType);
	}
	else
	{	cp->ptr = (void*)new struct ds__X509DataType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__X509DataType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__X509DataType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__X509DataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__X509DataType %p -> %p\n", q, p));
	*(struct ds__X509DataType*)p = *(struct ds__X509DataType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RetrievalMethodType);
	if (soap_out_ds__RetrievalMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RetrievalMethodType(struct soap *soap, const char *tag, int id, const struct ds__RetrievalMethodType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RetrievalMethodType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_get_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_in_ds__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RetrievalMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RetrievalMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RetrievalMethodType, 0, sizeof(struct ds__RetrievalMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_instantiate_ds__RetrievalMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__RetrievalMethodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__RetrievalMethodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ds__RetrievalMethodType;
		if (size)
			*size = sizeof(struct ds__RetrievalMethodType);
	}
	else
	{	cp->ptr = (void*)new struct ds__RetrievalMethodType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__RetrievalMethodType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__RetrievalMethodType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__RetrievalMethodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__RetrievalMethodType %p -> %p\n", q, p));
	*(struct ds__RetrievalMethodType*)p = *(struct ds__RetrievalMethodType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DSAKeyValue = NULL;
	a->RSAKeyValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__DSAKeyValueType(soap, &a->DSAKeyValue);
	soap_serialize_PointerTods__RSAKeyValueType(soap, &a->RSAKeyValue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyValueType);
	if (soap_out_ds__KeyValueType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyValueType(struct soap *soap, const char *tag, int id, const struct ds__KeyValueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyValueType), type))
		return soap->error;
	if (soap_out_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", -1, &a->DSAKeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", -1, &a->RSAKeyValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_get_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_in_ds__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType *a, const char *type)
{
	size_t soap_flag_DSAKeyValue = 1;
	size_t soap_flag_RSAKeyValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", &a->DSAKeyValue, "ds:DSAKeyValueType"))
				{	soap_flag_DSAKeyValue--;
					continue;
				}
			if (soap_flag_RSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", &a->RSAKeyValue, "ds:RSAKeyValueType"))
				{	soap_flag_RSAKeyValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyValueType, 0, sizeof(struct ds__KeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_DSAKeyValue > 0 || soap_flag_RSAKeyValue > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_instantiate_ds__KeyValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__KeyValueType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__KeyValueType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ds__KeyValueType;
		if (size)
			*size = sizeof(struct ds__KeyValueType);
	}
	else
	{	cp->ptr = (void*)new struct ds__KeyValueType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__KeyValueType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__KeyValueType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__KeyValueType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__KeyValueType %p -> %p\n", q, p));
	*(struct ds__KeyValueType*)p = *(struct ds__KeyValueType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DigestMethodType);
	if (soap_out_ds__DigestMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DigestMethodType(struct soap *soap, const char *tag, int id, const struct ds__DigestMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DigestMethodType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_get_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_in_ds__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DigestMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DigestMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DigestMethodType, 0, sizeof(struct ds__DigestMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_instantiate_ds__DigestMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__DigestMethodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__DigestMethodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ds__DigestMethodType;
		if (size)
			*size = sizeof(struct ds__DigestMethodType);
	}
	else
	{	cp->ptr = (void*)new struct ds__DigestMethodType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__DigestMethodType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__DigestMethodType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__DigestMethodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__DigestMethodType %p -> %p\n", q, p));
	*(struct ds__DigestMethodType*)p = *(struct ds__DigestMethodType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformType(struct soap *soap, struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->c14n__InclusiveNamespaces = NULL;
	a->__any = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformType(struct soap *soap, const struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformType(struct soap *soap, const struct ds__TransformType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformType);
	if (soap_out_ds__TransformType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformType(struct soap *soap, const char *tag, int id, const struct ds__TransformType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_get_ds__TransformType(struct soap *soap, struct ds__TransformType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_in_ds__TransformType(struct soap *soap, const char *tag, struct ds__TransformType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 0), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformType, 0, sizeof(struct ds__TransformType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_instantiate_ds__TransformType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__TransformType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__TransformType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ds__TransformType;
		if (size)
			*size = sizeof(struct ds__TransformType);
	}
	else
	{	cp->ptr = (void*)new struct ds__TransformType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__TransformType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__TransformType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__TransformType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__TransformType %p -> %p\n", q, p));
	*(struct ds__TransformType*)p = *(struct ds__TransformType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->PrefixList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__c14n__InclusiveNamespaces);
	if (soap_out__c14n__InclusiveNamespaces(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, const struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (a->PrefixList)
		soap_set_attr(soap, "PrefixList", a->PrefixList);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__c14n__InclusiveNamespaces), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_get__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_in__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _c14n__InclusiveNamespaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__c14n__InclusiveNamespaces(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PrefixList", 0), &a->PrefixList))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__c14n__InclusiveNamespaces, 0, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_instantiate__c14n__InclusiveNamespaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__c14n__InclusiveNamespaces(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__c14n__InclusiveNamespaces, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct _c14n__InclusiveNamespaces;
		if (size)
			*size = sizeof(struct _c14n__InclusiveNamespaces);
	}
	else
	{	cp->ptr = (void*)new struct _c14n__InclusiveNamespaces[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _c14n__InclusiveNamespaces);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _c14n__InclusiveNamespaces*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__c14n__InclusiveNamespaces(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _c14n__InclusiveNamespaces %p -> %p\n", q, p));
	*(struct _c14n__InclusiveNamespaces*)p = *(struct _c14n__InclusiveNamespaces*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformsType(struct soap *soap, struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTransform = 0;
	a->Transform = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Transform)
	{	int i;
		for (i = 0; i < a->__sizeTransform; i++)
		{
			soap_embedded(soap, a->Transform + i, SOAP_TYPE_ds__TransformType);
			soap_serialize_ds__TransformType(soap, a->Transform + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformsType);
	if (soap_out_ds__TransformsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformsType(struct soap *soap, const char *tag, int id, const struct ds__TransformsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformsType), type))
		return soap->error;
	if (a->Transform)
	{	int i;
		for (i = 0; i < a->__sizeTransform; i++)
			if (soap_out_ds__TransformType(soap, "ds:Transform", -1, a->Transform + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_get_ds__TransformsType(struct soap *soap, struct ds__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_in_ds__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType *a, const char *type)
{
	struct soap_blist *soap_blist_Transform = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Transform", 1, NULL))
			{	if (a->Transform == NULL)
				{	if (soap_blist_Transform == NULL)
						soap_blist_Transform = soap_new_block(soap);
					a->Transform = (struct ds__TransformType *)soap_push_block(soap, soap_blist_Transform, sizeof(struct ds__TransformType));
					if (a->Transform == NULL)
						return NULL;
					soap_default_ds__TransformType(soap, a->Transform);
				}soap_revert(soap);
				if (soap_in_ds__TransformType(soap, "ds:Transform", a->Transform, "ds:TransformType"))
				{	a->__sizeTransform++;
					a->Transform = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Transform)
			soap_pop_block(soap, soap_blist_Transform);
		if (a->__sizeTransform)
			a->Transform = (struct ds__TransformType *)soap_save_block(soap, soap_blist_Transform, NULL, 1);
		else
		{	a->Transform = NULL;
			if (soap_blist_Transform)
				soap_end_block(soap, soap_blist_Transform);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformsType, 0, sizeof(struct ds__TransformsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_instantiate_ds__TransformsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__TransformsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__TransformsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ds__TransformsType;
		if (size)
			*size = sizeof(struct ds__TransformsType);
	}
	else
	{	cp->ptr = (void*)new struct ds__TransformsType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__TransformsType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__TransformsType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__TransformsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__TransformsType %p -> %p\n", q, p));
	*(struct ds__TransformsType*)p = *(struct ds__TransformsType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	a->DigestMethod = NULL;
	soap_default_string(soap, &a->DigestValue);
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->DigestMethod);
	soap_serialize_string(soap, &a->DigestValue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__ReferenceType);
	if (soap_out_ds__ReferenceType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__ReferenceType(struct soap *soap, const char *tag, int id, const struct ds__ReferenceType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id);
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__ReferenceType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->DigestMethod, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:DigestValue", -1, &a->DigestValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_get_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_in_ds__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	size_t soap_flag_DigestMethod = 1;
	size_t soap_flag_DigestValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap_flag_DigestMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->DigestMethod, "ds:DigestMethodType"))
				{	soap_flag_DigestMethod--;
					continue;
				}
			if (soap_flag_DigestValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:DigestValue", &a->DigestValue, "xsd:string"))
				{	soap_flag_DigestValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__ReferenceType, 0, sizeof(struct ds__ReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_DigestMethod > 0 || soap_flag_DigestValue > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_instantiate_ds__ReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__ReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__ReferenceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ds__ReferenceType;
		if (size)
			*size = sizeof(struct ds__ReferenceType);
	}
	else
	{	cp->ptr = (void*)new struct ds__ReferenceType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__ReferenceType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__ReferenceType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__ReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__ReferenceType %p -> %p\n", q, p));
	*(struct ds__ReferenceType*)p = *(struct ds__ReferenceType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HMACOutputLength = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->HMACOutputLength);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureMethodType);
	if (soap_out_ds__SignatureMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureMethodType(struct soap *soap, const char *tag, int id, const struct ds__SignatureMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ds:HMACOutputLength", -1, &a->HMACOutputLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_get_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_in_ds__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType *a, const char *type)
{
	size_t soap_flag_HMACOutputLength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HMACOutputLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ds:HMACOutputLength", &a->HMACOutputLength, "xsd:int"))
				{	soap_flag_HMACOutputLength--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureMethodType, 0, sizeof(struct ds__SignatureMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_instantiate_ds__SignatureMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__SignatureMethodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__SignatureMethodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ds__SignatureMethodType;
		if (size)
			*size = sizeof(struct ds__SignatureMethodType);
	}
	else
	{	cp->ptr = (void*)new struct ds__SignatureMethodType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__SignatureMethodType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__SignatureMethodType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__SignatureMethodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__SignatureMethodType %p -> %p\n", q, p));
	*(struct ds__SignatureMethodType*)p = *(struct ds__SignatureMethodType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
	a->c14n__InclusiveNamespaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__CanonicalizationMethodType);
	if (soap_out_ds__CanonicalizationMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, const struct ds__CanonicalizationMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__CanonicalizationMethodType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_get_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_in_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__CanonicalizationMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__CanonicalizationMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__CanonicalizationMethodType, 0, sizeof(struct ds__CanonicalizationMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_instantiate_ds__CanonicalizationMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__CanonicalizationMethodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__CanonicalizationMethodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ds__CanonicalizationMethodType;
		if (size)
			*size = sizeof(struct ds__CanonicalizationMethodType);
	}
	else
	{	cp->ptr = (void*)new struct ds__CanonicalizationMethodType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__CanonicalizationMethodType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__CanonicalizationMethodType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__CanonicalizationMethodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__CanonicalizationMethodType %p -> %p\n", q, p));
	*(struct ds__CanonicalizationMethodType*)p = *(struct ds__CanonicalizationMethodType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->KeyName);
	a->KeyValue = NULL;
	a->RetrievalMethod = NULL;
	a->X509Data = NULL;
	a->wsse__SecurityTokenReference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->KeyName);
	soap_serialize_PointerTods__KeyValueType(soap, &a->KeyValue);
	soap_serialize_PointerTods__RetrievalMethodType(soap, &a->RetrievalMethod);
	soap_serialize_PointerTods__X509DataType(soap, &a->X509Data);
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyInfoType);
	if (soap_out_ds__KeyInfoType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyInfoType(struct soap *soap, const char *tag, int id, const struct ds__KeyInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyInfoType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:KeyName", -1, &a->KeyName, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyValueType(soap, "ds:KeyValue", -1, &a->KeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", -1, &a->RetrievalMethod, ""))
		return soap->error;
	if (soap_out_PointerTods__X509DataType(soap, "ds:X509Data", -1, &a->X509Data, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_get_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_in_ds__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType *a, const char *type)
{
	size_t soap_flag_KeyName = 1;
	size_t soap_flag_KeyValue = 1;
	size_t soap_flag_RetrievalMethod = 1;
	size_t soap_flag_X509Data = 1;
	size_t soap_flag_wsse__SecurityTokenReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:KeyName", &a->KeyName, "xsd:string"))
				{	soap_flag_KeyName--;
					continue;
				}
			if (soap_flag_KeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyValueType(soap, "ds:KeyValue", &a->KeyValue, "ds:KeyValueType"))
				{	soap_flag_KeyValue--;
					continue;
				}
			if (soap_flag_RetrievalMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", &a->RetrievalMethod, "ds:RetrievalMethodType"))
				{	soap_flag_RetrievalMethod--;
					continue;
				}
			if (soap_flag_X509Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509DataType(soap, "ds:X509Data", &a->X509Data, "ds:X509DataType"))
				{	soap_flag_X509Data--;
					continue;
				}
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
				{	soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyInfoType, 0, sizeof(struct ds__KeyInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_instantiate_ds__KeyInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__KeyInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__KeyInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ds__KeyInfoType;
		if (size)
			*size = sizeof(struct ds__KeyInfoType);
	}
	else
	{	cp->ptr = (void*)new struct ds__KeyInfoType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__KeyInfoType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__KeyInfoType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__KeyInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__KeyInfoType %p -> %p\n", q, p));
	*(struct ds__KeyInfoType*)p = *(struct ds__KeyInfoType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CanonicalizationMethod = NULL;
	a->SignatureMethod = NULL;
	a->__sizeReference = 0;
	a->Reference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__CanonicalizationMethodType(soap, &a->CanonicalizationMethod);
	soap_serialize_PointerTods__SignatureMethodType(soap, &a->SignatureMethod);
	if (a->Reference)
	{	int i;
		for (i = 0; i < a->__sizeReference; i++)
		{
			soap_serialize_PointerTods__ReferenceType(soap, a->Reference + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignedInfoType);
	if (soap_out_ds__SignedInfoType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignedInfoType(struct soap *soap, const char *tag, int id, const struct ds__SignedInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignedInfoType), type))
		return soap->error;
	if (soap_out_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", -1, &a->CanonicalizationMethod, ""))
		return soap->error;
	if (soap_out_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", -1, &a->SignatureMethod, ""))
		return soap->error;
	if (a->Reference)
	{	int i;
		for (i = 0; i < a->__sizeReference; i++)
			if (soap_out_PointerTods__ReferenceType(soap, "ds:Reference", -1, a->Reference + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_get_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_in_ds__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType *a, const char *type)
{
	size_t soap_flag_CanonicalizationMethod = 1;
	size_t soap_flag_SignatureMethod = 1;
	struct soap_blist *soap_blist_Reference = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignedInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignedInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CanonicalizationMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", &a->CanonicalizationMethod, "ds:CanonicalizationMethodType"))
				{	soap_flag_CanonicalizationMethod--;
					continue;
				}
			if (soap_flag_SignatureMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", &a->SignatureMethod, "ds:SignatureMethodType"))
				{	soap_flag_SignatureMethod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Reference", 1, NULL))
			{	if (a->Reference == NULL)
				{	if (soap_blist_Reference == NULL)
						soap_blist_Reference = soap_new_block(soap);
					a->Reference = (struct ds__ReferenceType **)soap_push_block(soap, soap_blist_Reference, sizeof(struct ds__ReferenceType *));
					if (a->Reference == NULL)
						return NULL;
					*a->Reference = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTods__ReferenceType(soap, "ds:Reference", a->Reference, "ds:ReferenceType"))
				{	a->__sizeReference++;
					a->Reference = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Reference)
			soap_pop_block(soap, soap_blist_Reference);
		if (a->__sizeReference)
			a->Reference = (struct ds__ReferenceType **)soap_save_block(soap, soap_blist_Reference, NULL, 1);
		else
		{	a->Reference = NULL;
			if (soap_blist_Reference)
				soap_end_block(soap, soap_blist_Reference);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignedInfoType, 0, sizeof(struct ds__SignedInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_CanonicalizationMethod > 0 || soap_flag_SignatureMethod > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_instantiate_ds__SignedInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__SignedInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__SignedInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ds__SignedInfoType;
		if (size)
			*size = sizeof(struct ds__SignedInfoType);
	}
	else
	{	cp->ptr = (void*)new struct ds__SignedInfoType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__SignedInfoType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__SignedInfoType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__SignedInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__SignedInfoType %p -> %p\n", q, p));
	*(struct ds__SignedInfoType*)p = *(struct ds__SignedInfoType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureType(struct soap *soap, struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SignedInfo = NULL;
	soap_default_string(soap, &a->SignatureValue);
	a->KeyInfo = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__SignedInfoType(soap, &a->SignedInfo);
	soap_serialize_string(soap, &a->SignatureValue);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->KeyInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureType);
	if (soap_out_ds__SignatureType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureType(struct soap *soap, const char *tag, int id, const struct ds__SignatureType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureType), type))
		return soap->error;
	if (soap_out_PointerTods__SignedInfoType(soap, "ds:SignedInfo", -1, &a->SignedInfo, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:SignatureValue", -1, &a->SignatureValue, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "ds:KeyInfo", -1, &a->KeyInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_get_ds__SignatureType(struct soap *soap, struct ds__SignatureType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_in_ds__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType *a, const char *type)
{
	size_t soap_flag_SignedInfo = 1;
	size_t soap_flag_SignatureValue = 1;
	size_t soap_flag_KeyInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SignedInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignedInfoType(soap, "ds:SignedInfo", &a->SignedInfo, "ds:SignedInfoType"))
				{	soap_flag_SignedInfo--;
					continue;
				}
			if (soap_flag_SignatureValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:SignatureValue", &a->SignatureValue, "xsd:string"))
				{	soap_flag_SignatureValue--;
					continue;
				}
			if (soap_flag_KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "ds:KeyInfo", &a->KeyInfo, "ds:KeyInfoType"))
				{	soap_flag_KeyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureType, 0, sizeof(struct ds__SignatureType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_instantiate_ds__SignatureType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__SignatureType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__SignatureType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ds__SignatureType;
		if (size)
			*size = sizeof(struct ds__SignatureType);
	}
	else
	{	cp->ptr = (void*)new struct ds__SignatureType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__SignatureType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__SignatureType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__SignatureType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__SignatureType %p -> %p\n", q, p));
	*(struct ds__SignatureType*)p = *(struct ds__SignatureType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Reference = NULL;
	a->KeyIdentifier = NULL;
	a->Embedded = NULL;
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Usage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsse__Reference(soap, &a->Reference);
	soap_serialize_PointerTo_wsse__KeyIdentifier(soap, &a->KeyIdentifier);
	soap_serialize_PointerTo_wsse__Embedded(soap, &a->Embedded);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__SecurityTokenReference);
	if (soap_out__wsse__SecurityTokenReference(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, const struct _wsse__SecurityTokenReference *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id);
	if (a->Usage)
		soap_set_attr(soap, "Usage", a->Usage);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__SecurityTokenReference), type))
		return soap->error;
	if (soap_out_PointerTo_wsse__Reference(soap, "wsse:Reference", -1, &a->Reference, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", -1, &a->KeyIdentifier, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Embedded(soap, "wsse:Embedded", -1, &a->Embedded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_get__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_in__wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference *a, const char *type)
{
	size_t soap_flag_Reference = 1;
	size_t soap_flag_KeyIdentifier = 1;
	size_t soap_flag_Embedded = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__SecurityTokenReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__SecurityTokenReference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Usage", 0), &a->Usage))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Reference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Reference(soap, "wsse:Reference", &a->Reference, ""))
				{	soap_flag_Reference--;
					continue;
				}
			if (soap_flag_KeyIdentifier && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", &a->KeyIdentifier, ""))
				{	soap_flag_KeyIdentifier--;
					continue;
				}
			if (soap_flag_Embedded && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Embedded(soap, "wsse:Embedded", &a->Embedded, ""))
				{	soap_flag_Embedded--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__SecurityTokenReference, 0, sizeof(struct _wsse__SecurityTokenReference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_instantiate__wsse__SecurityTokenReference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__SecurityTokenReference(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__SecurityTokenReference, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct _wsse__SecurityTokenReference;
		if (size)
			*size = sizeof(struct _wsse__SecurityTokenReference);
	}
	else
	{	cp->ptr = (void*)new struct _wsse__SecurityTokenReference[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__SecurityTokenReference);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__SecurityTokenReference*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__SecurityTokenReference(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__SecurityTokenReference %p -> %p\n", q, p));
	*(struct _wsse__SecurityTokenReference*)p = *(struct _wsse__SecurityTokenReference*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__KeyIdentifier);
	if (soap_out__wsse__KeyIdentifier(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, const struct _wsse__KeyIdentifier *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", a->EncodingType);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_get__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_in__wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__KeyIdentifier *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__KeyIdentifier(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_instantiate__wsse__KeyIdentifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__KeyIdentifier(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__KeyIdentifier, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct _wsse__KeyIdentifier;
		if (size)
			*size = sizeof(struct _wsse__KeyIdentifier);
	}
	else
	{	cp->ptr = (void*)new struct _wsse__KeyIdentifier[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__KeyIdentifier);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__KeyIdentifier*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__KeyIdentifier(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__KeyIdentifier %p -> %p\n", q, p));
	*(struct _wsse__KeyIdentifier*)p = *(struct _wsse__KeyIdentifier*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Embedded);
	if (soap_out__wsse__Embedded(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Embedded(struct soap *soap, const char *tag, int id, const struct _wsse__Embedded *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Embedded), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_get__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_in__wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Embedded *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Embedded(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Embedded, 0, sizeof(struct _wsse__Embedded), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_instantiate__wsse__Embedded(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Embedded(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__Embedded, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct _wsse__Embedded;
		if (size)
			*size = sizeof(struct _wsse__Embedded);
	}
	else
	{	cp->ptr = (void*)new struct _wsse__Embedded[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__Embedded);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__Embedded*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__Embedded(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__Embedded %p -> %p\n", q, p));
	*(struct _wsse__Embedded*)p = *(struct _wsse__Embedded*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Reference(struct soap *soap, struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Reference);
	if (soap_out__wsse__Reference(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Reference(struct soap *soap, const char *tag, int id, const struct _wsse__Reference *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Reference), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_get__wsse__Reference(struct soap *soap, struct _wsse__Reference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_in__wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Reference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Reference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Reference, 0, sizeof(struct _wsse__Reference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_instantiate__wsse__Reference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Reference(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__Reference, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct _wsse__Reference;
		if (size)
			*size = sizeof(struct _wsse__Reference);
	}
	else
	{	cp->ptr = (void*)new struct _wsse__Reference[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__Reference);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__Reference*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__Reference(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__Reference %p -> %p\n", q, p));
	*(struct _wsse__Reference*)p = *(struct _wsse__Reference*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__BinarySecurityToken);
	if (soap_out__wsse__BinarySecurityToken(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, const struct _wsse__BinarySecurityToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", a->EncodingType);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_get__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_in__wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__BinarySecurityToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__BinarySecurityToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_instantiate__wsse__BinarySecurityToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__BinarySecurityToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__BinarySecurityToken, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct _wsse__BinarySecurityToken;
		if (size)
			*size = sizeof(struct _wsse__BinarySecurityToken);
	}
	else
	{	cp->ptr = (void*)new struct _wsse__BinarySecurityToken[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__BinarySecurityToken);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__BinarySecurityToken*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__BinarySecurityToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__BinarySecurityToken %p -> %p\n", q, p));
	*(struct _wsse__BinarySecurityToken*)p = *(struct _wsse__BinarySecurityToken*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Password(struct soap *soap, struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Password(struct soap *soap, const struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Password(struct soap *soap, const struct _wsse__Password *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Password);
	if (soap_out__wsse__Password(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Password(struct soap *soap, const char *tag, int id, const struct _wsse__Password *a, const char *type)
{
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_get__wsse__Password(struct soap *soap, struct _wsse__Password *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_in__wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__Password *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__Password(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_instantiate__wsse__Password(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Password(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__Password, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct _wsse__Password;
		if (size)
			*size = sizeof(struct _wsse__Password);
	}
	else
	{	cp->ptr = (void*)new struct _wsse__Password[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__Password);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__Password*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__Password(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__Password %p -> %p\n", q, p));
	*(struct _wsse__Password*)p = *(struct _wsse__Password*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	a->Password = NULL;
	soap_default_string(soap, &a->Nonce);
	soap_default_string(soap, &a->wsu__Created);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Username);
	soap_serialize_PointerTo_wsse__Password(soap, &a->Password);
	soap_serialize_string(soap, &a->Nonce);
	soap_serialize_string(soap, &a->wsu__Created);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__UsernameToken);
	if (soap_out__wsse__UsernameToken(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__UsernameToken(struct soap *soap, const char *tag, int id, const struct _wsse__UsernameToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__UsernameToken), type))
		return soap->error;
	if (soap_out_string(soap, "wsse:Username", -1, &a->Username, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Password(soap, "wsse:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_string(soap, "wsse:Nonce", -1, &a->Nonce, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, &a->wsu__Created, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_get__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_in__wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Nonce = 1;
	size_t soap_flag_wsu__Created = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__UsernameToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__UsernameToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsse:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Password(soap, "wsse:Password", &a->Password, ""))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsse:Nonce", &a->Nonce, "xsd:string"))
				{	soap_flag_Nonce--;
					continue;
				}
			if (soap_flag_wsu__Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Created", &a->wsu__Created, "xsd:string"))
				{	soap_flag_wsu__Created--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__UsernameToken, 0, sizeof(struct _wsse__UsernameToken), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_instantiate__wsse__UsernameToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__UsernameToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__UsernameToken, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct _wsse__UsernameToken;
		if (size)
			*size = sizeof(struct _wsse__UsernameToken);
	}
	else
	{	cp->ptr = (void*)new struct _wsse__UsernameToken[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__UsernameToken);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__UsernameToken*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__UsernameToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__UsernameToken %p -> %p\n", q, p));
	*(struct _wsse__UsernameToken*)p = *(struct _wsse__UsernameToken*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Created);
	soap_default_string(soap, &a->Expires);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Created);
	soap_serialize_string(soap, &a->Expires);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsu__Timestamp);
	if (soap_out__wsu__Timestamp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsu__Timestamp(struct soap *soap, const char *tag, int id, const struct _wsu__Timestamp *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsu__Timestamp), type))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, &a->Created, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Expires", -1, &a->Expires, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_get__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_in__wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp *a, const char *type)
{
	size_t soap_flag_Created = 1;
	size_t soap_flag_Expires = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsu__Timestamp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsu__Timestamp(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Created", &a->Created, "xsd:string"))
				{	soap_flag_Created--;
					continue;
				}
			if (soap_flag_Expires && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Expires", &a->Expires, "xsd:string"))
				{	soap_flag_Expires--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsu__Timestamp, 0, sizeof(struct _wsu__Timestamp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_instantiate__wsu__Timestamp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsu__Timestamp(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsu__Timestamp, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct _wsu__Timestamp;
		if (size)
			*size = sizeof(struct _wsu__Timestamp);
	}
	else
	{	cp->ptr = (void*)new struct _wsu__Timestamp[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsu__Timestamp);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsu__Timestamp*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsu__Timestamp(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsu__Timestamp %p -> %p\n", q, p));
	*(struct _wsu__Timestamp*)p = *(struct _wsu__Timestamp*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__MessageID(soap, &a->wsa__MessageID);
	a->wsa__RelatesTo = NULL;
	a->wsa__From = NULL;
	a->wsa__ReplyTo = NULL;
	a->wsa__FaultTo = NULL;
	soap_default__wsa__To(soap, &a->wsa__To);
	soap_default__wsa__Action(soap, &a->wsa__Action);
	a->wsse__Security = NULL;
	a->wsrp__path = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wsa__MessageID(soap, &a->wsa__MessageID);
	soap_serialize_PointerTo_wsa__RelatesTo(soap, &a->wsa__RelatesTo);
	soap_serialize_PointerTo_wsa__From(soap, &a->wsa__From);
	soap_serialize_PointerTo_wsa__ReplyTo(soap, &a->wsa__ReplyTo);
	soap_serialize_PointerTo_wsa__FaultTo(soap, &a->wsa__FaultTo);
	soap_serialize__wsa__To(soap, &a->wsa__To);
	soap_serialize__wsa__Action(soap, &a->wsa__Action);
	soap_serialize_PointerTo_wsse__Security(soap, &a->wsse__Security);
	soap_serialize_PointerTo_wsrp__path(soap, &a->wsrp__path);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	if (soap_out__wsa__MessageID(soap, "wsa:MessageID", -1, &a->wsa__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", -1, &a->wsa__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__From(soap, "wsa:From", -1, &a->wsa__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", -1, &a->wsa__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", -1, &a->wsa__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa__To(soap, "wsa:To", -1, &a->wsa__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa__Action(soap, "wsa:Action", -1, &a->wsa__Action, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsse__Security(soap, "wsse:Security", -1, &a->wsse__Security, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsrp__path(soap, "wsrp:path", -1, &a->wsrp__path, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsa__MessageID = 1;
	size_t soap_flag_wsa__RelatesTo = 1;
	size_t soap_flag_wsa__From = 1;
	size_t soap_flag_wsa__ReplyTo = 1;
	size_t soap_flag_wsa__FaultTo = 1;
	size_t soap_flag_wsa__To = 1;
	size_t soap_flag_wsa__Action = 1;
	size_t soap_flag_wsse__Security = 1;
	size_t soap_flag_wsrp__path = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa__MessageID(soap, "wsa:MessageID", &a->wsa__MessageID, ""))
				{	soap_flag_wsa__MessageID--;
					continue;
				}
			if (soap_flag_wsa__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", &a->wsa__RelatesTo, ""))
				{	soap_flag_wsa__RelatesTo--;
					continue;
				}
			if (soap_flag_wsa__From && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__From(soap, "wsa:From", &a->wsa__From, ""))
				{	soap_flag_wsa__From--;
					continue;
				}
			if (soap_flag_wsa__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", &a->wsa__ReplyTo, ""))
				{	soap_flag_wsa__ReplyTo--;
					continue;
				}
			if (soap_flag_wsa__FaultTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", &a->wsa__FaultTo, ""))
				{	soap_flag_wsa__FaultTo--;
					continue;
				}
			if (soap_flag_wsa__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa__To(soap, "wsa:To", &a->wsa__To, ""))
				{	soap_flag_wsa__To--;
					continue;
				}
			if (soap_flag_wsa__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa__Action(soap, "wsa:Action", &a->wsa__Action, ""))
				{	soap_flag_wsa__Action--;
					continue;
				}
			if (soap_flag_wsse__Security && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Security(soap, "wsse:Security", &a->wsse__Security, ""))
				{	soap_flag_wsse__Security--;
					continue;
				}
			if (soap_flag_wsrp__path && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrp__path(soap, "wsrp:path", &a->wsrp__path, ""))
				{	soap_flag_wsrp__path--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__Relationship(struct soap *soap, struct wsa__Relationship *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__QName(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__Relationship(struct soap *soap, const struct wsa__Relationship *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__Relationship(struct soap *soap, const struct wsa__Relationship *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__Relationship);
	if (soap_out_wsa__Relationship(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__Relationship(struct soap *soap, const char *tag, int id, const struct wsa__Relationship *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", soap_QName2s(soap, a->RelationshipType));
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_get_wsa__Relationship(struct soap *soap, struct wsa__Relationship *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__Relationship(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_in_wsa__Relationship(struct soap *soap, const char *tag, struct wsa__Relationship *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__Relationship *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__Relationship, sizeof(struct wsa__Relationship), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__Relationship(soap, a);
	if (soap_s2QName(soap, soap_attr_value(soap, "RelationshipType", 0), &a->RelationshipType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "wsa:Relationship"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_instantiate_wsa__Relationship(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa__Relationship(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa__Relationship, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct wsa__Relationship;
		if (size)
			*size = sizeof(struct wsa__Relationship);
	}
	else
	{	cp->ptr = (void*)new struct wsa__Relationship[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct wsa__Relationship);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct wsa__Relationship*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa__Relationship(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa__Relationship %p -> %p\n", q, p));
	*(struct wsa__Relationship*)p = *(struct wsa__Relationship*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->__item);
	soap_default_string(soap, &a->PortName);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ServiceNameType(struct soap *soap, const struct wsa__ServiceNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ServiceNameType(struct soap *soap, const struct wsa__ServiceNameType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__ServiceNameType);
	if (soap_out_wsa__ServiceNameType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ServiceNameType(struct soap *soap, const char *tag, int id, const struct wsa__ServiceNameType *a, const char *type)
{
	const char *soap_tmp___item = soap_QName2s(soap, a->__item);
	if (a->PortName)
		soap_set_attr(soap, "PortName", a->PortName);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute);
	return soap_out__QName(soap, tag, id, (char*const*)&soap_tmp___item, "");
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_get_wsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ServiceNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_in_wsa__ServiceNameType(struct soap *soap, const char *tag, struct wsa__ServiceNameType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__ServiceNameType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ServiceNameType, sizeof(struct wsa__ServiceNameType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__ServiceNameType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PortName", 0), &a->PortName))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute))
		return NULL;
	if (!soap_in__QName(soap, tag, &a->__item, "wsa:ServiceNameType"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_instantiate_wsa__ServiceNameType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa__ServiceNameType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa__ServiceNameType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct wsa__ServiceNameType;
		if (size)
			*size = sizeof(struct wsa__ServiceNameType);
	}
	else
	{	cp->ptr = (void*)new struct wsa__ServiceNameType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct wsa__ServiceNameType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct wsa__ServiceNameType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa__ServiceNameType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa__ServiceNameType %p -> %p\n", q, p));
	*(struct wsa__ServiceNameType*)p = *(struct wsa__ServiceNameType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__ReferenceParametersType);
	if (soap_out_wsa__ReferenceParametersType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa__ReferenceParametersType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferenceParametersType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa__ReferenceParametersType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ReferenceParametersType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferenceParametersType, 0, sizeof(struct wsa__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_instantiate_wsa__ReferenceParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa__ReferenceParametersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa__ReferenceParametersType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct wsa__ReferenceParametersType;
		if (size)
			*size = sizeof(struct wsa__ReferenceParametersType);
	}
	else
	{	cp->ptr = (void*)new struct wsa__ReferenceParametersType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct wsa__ReferenceParametersType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct wsa__ReferenceParametersType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa__ReferenceParametersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa__ReferenceParametersType %p -> %p\n", q, p));
	*(struct wsa__ReferenceParametersType*)p = *(struct wsa__ReferenceParametersType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ReferencePropertiesType(struct soap *soap, const struct wsa__ReferencePropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ReferencePropertiesType(struct soap *soap, const struct wsa__ReferencePropertiesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__ReferencePropertiesType);
	if (soap_out_wsa__ReferencePropertiesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferencePropertiesType(struct soap *soap, const char *tag, int id, const struct wsa__ReferencePropertiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferencePropertiesType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_get_wsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferencePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_in_wsa__ReferencePropertiesType(struct soap *soap, const char *tag, struct wsa__ReferencePropertiesType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__ReferencePropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ReferencePropertiesType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferencePropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferencePropertiesType, 0, sizeof(struct wsa__ReferencePropertiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_instantiate_wsa__ReferencePropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa__ReferencePropertiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa__ReferencePropertiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct wsa__ReferencePropertiesType;
		if (size)
			*size = sizeof(struct wsa__ReferencePropertiesType);
	}
	else
	{	cp->ptr = (void*)new struct wsa__ReferencePropertiesType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct wsa__ReferencePropertiesType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct wsa__ReferencePropertiesType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa__ReferencePropertiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa__ReferencePropertiesType %p -> %p\n", q, p));
	*(struct wsa__ReferencePropertiesType*)p = *(struct wsa__ReferencePropertiesType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceProperties = NULL;
	a->ReferenceParameters = NULL;
	a->PortType = NULL;
	a->ServiceName = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Address);
	soap_serialize_PointerTowsa__ReferencePropertiesType(soap, &a->ReferenceProperties);
	soap_serialize_PointerTowsa__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTo_QName(soap, &a->PortType);
	soap_serialize_PointerTowsa__ServiceNameType(soap, &a->ServiceName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__EndpointReferenceType);
	if (soap_out_wsa__EndpointReferenceType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa__EndpointReferenceType *a, const char *type)
{
	const char *soap_tmp_PortType = a->PortType ? soap_QName2s(soap, *a->PortType) : NULL;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__EndpointReferenceType), type))
		return soap->error;
	if (soap_out_string(soap, "wsa:Address", -1, &a->Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferencePropertiesType(soap, "wsa:ReferenceProperties", -1, &a->ReferenceProperties, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out__QName(soap, "wsa:PortType", -1, (char*const*)&soap_tmp_PortType, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ServiceNameType(soap, "wsa:ServiceName", -1, &a->ServiceName, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceProperties = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_PortType = 1;
	size_t soap_flag_ServiceName = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(struct wsa__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__EndpointReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa:Address", &a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_ReferenceProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ReferencePropertiesType(soap, "wsa:ReferenceProperties", &a->ReferenceProperties, "wsa:ReferencePropertiesType"))
				{	soap_flag_ReferenceProperties--;
					continue;
				}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", &a->ReferenceParameters, "wsa:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			if (soap_flag_PortType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_QName(soap, "wsa:PortType", &a->PortType, ""))
				{	soap_flag_PortType--;
					continue;
				}
			if (soap_flag_ServiceName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ServiceNameType(soap, "wsa:ServiceName", &a->ServiceName, "wsa:ServiceNameType"))
				{	soap_flag_ServiceName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__EndpointReferenceType, 0, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_Address > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_instantiate_wsa__EndpointReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa__EndpointReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa__EndpointReferenceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct wsa__EndpointReferenceType;
		if (size)
			*size = sizeof(struct wsa__EndpointReferenceType);
	}
	else
	{	cp->ptr = (void*)new struct wsa__EndpointReferenceType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct wsa__EndpointReferenceType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct wsa__EndpointReferenceType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa__EndpointReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa__EndpointReferenceType %p -> %p\n", q, p));
	*(struct wsa__EndpointReferenceType*)p = *(struct wsa__EndpointReferenceType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__fault_USCOREt(struct soap *soap, struct wsrp__fault_USCOREt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsrp__faultcode);
	soap_default_string(soap, &a->wsrp__faultreason);
	soap_default_string(soap, &a->endpoint);
	a->found = NULL;
	a->maxsize = NULL;
	a->maxtime = NULL;
	a->retryAfter = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__fault_USCOREt(struct soap *soap, const struct wsrp__fault_USCOREt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsrp__faultcode);
	soap_serialize_string(soap, &a->wsrp__faultreason);
	soap_serialize_string(soap, &a->endpoint);
	soap_serialize_PointerTowsrp__found_USCOREt(soap, &a->found);
	soap_serialize_PointerToint(soap, &a->maxsize);
	soap_serialize_PointerToint(soap, &a->maxtime);
	soap_serialize_PointerToint(soap, &a->retryAfter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__fault_USCOREt(struct soap *soap, const struct wsrp__fault_USCOREt *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrp__fault_USCOREt);
	if (soap_out_wsrp__fault_USCOREt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__fault_USCOREt(struct soap *soap, const char *tag, int id, const struct wsrp__fault_USCOREt *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrp__fault_USCOREt), type))
		return soap->error;
	if (soap_out_string(soap, "wsrp:faultcode", -1, &a->wsrp__faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "wsrp:faultreason", -1, &a->wsrp__faultreason, ""))
		return soap->error;
	if (soap_out_string(soap, "endpoint", -1, &a->endpoint, ""))
		return soap->error;
	if (soap_out_PointerTowsrp__found_USCOREt(soap, "found", -1, &a->found, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "maxsize", -1, &a->maxsize, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "maxtime", -1, &a->maxtime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "retryAfter", -1, &a->retryAfter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrp__fault_USCOREt * SOAP_FMAC4 soap_get_wsrp__fault_USCOREt(struct soap *soap, struct wsrp__fault_USCOREt *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__fault_USCOREt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__fault_USCOREt * SOAP_FMAC4 soap_in_wsrp__fault_USCOREt(struct soap *soap, const char *tag, struct wsrp__fault_USCOREt *a, const char *type)
{
	size_t soap_flag_wsrp__faultcode = 1;
	size_t soap_flag_wsrp__faultreason = 1;
	size_t soap_flag_endpoint = 1;
	size_t soap_flag_found = 1;
	size_t soap_flag_maxsize = 1;
	size_t soap_flag_maxtime = 1;
	size_t soap_flag_retryAfter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrp__fault_USCOREt *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__fault_USCOREt, sizeof(struct wsrp__fault_USCOREt), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrp__fault_USCOREt(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrp__faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsrp:faultcode", &a->wsrp__faultcode, "xsd:string"))
				{	soap_flag_wsrp__faultcode--;
					continue;
				}
			if (soap_flag_wsrp__faultreason && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsrp:faultreason", &a->wsrp__faultreason, "xsd:string"))
				{	soap_flag_wsrp__faultreason--;
					continue;
				}
			if (soap_flag_endpoint && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "endpoint", &a->endpoint, "xsd:string"))
				{	soap_flag_endpoint--;
					continue;
				}
			if (soap_flag_found && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsrp__found_USCOREt(soap, "found", &a->found, "wsrp:found_t"))
				{	soap_flag_found--;
					continue;
				}
			if (soap_flag_maxsize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "maxsize", &a->maxsize, "xsd:int"))
				{	soap_flag_maxsize--;
					continue;
				}
			if (soap_flag_maxtime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "maxtime", &a->maxtime, "xsd:int"))
				{	soap_flag_maxtime--;
					continue;
				}
			if (soap_flag_retryAfter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "retryAfter", &a->retryAfter, "xsd:int"))
				{	soap_flag_retryAfter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__fault_USCOREt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrp__fault_USCOREt, 0, sizeof(struct wsrp__fault_USCOREt), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_wsrp__faultcode > 0 || soap_flag_wsrp__faultreason > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsrp__fault_USCOREt * SOAP_FMAC4 soap_instantiate_wsrp__fault_USCOREt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrp__fault_USCOREt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsrp__fault_USCOREt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct wsrp__fault_USCOREt;
		if (size)
			*size = sizeof(struct wsrp__fault_USCOREt);
	}
	else
	{	cp->ptr = (void*)new struct wsrp__fault_USCOREt[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct wsrp__fault_USCOREt);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct wsrp__fault_USCOREt*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsrp__fault_USCOREt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsrp__fault_USCOREt %p -> %p\n", q, p));
	*(struct wsrp__fault_USCOREt*)p = *(struct wsrp__fault_USCOREt*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__found_USCOREt(struct soap *soap, struct wsrp__found_USCOREt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeat = 0;
	a->at = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__found_USCOREt(struct soap *soap, const struct wsrp__found_USCOREt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->at)
	{	int i;
		for (i = 0; i < a->__sizeat; i++)
		{
			soap_serialize_string(soap, a->at + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__found_USCOREt(struct soap *soap, const struct wsrp__found_USCOREt *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrp__found_USCOREt);
	if (soap_out_wsrp__found_USCOREt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__found_USCOREt(struct soap *soap, const char *tag, int id, const struct wsrp__found_USCOREt *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrp__found_USCOREt), type))
		return soap->error;
	if (a->at)
	{	int i;
		for (i = 0; i < a->__sizeat; i++)
			if (soap_out_string(soap, "at", -1, a->at + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrp__found_USCOREt * SOAP_FMAC4 soap_get_wsrp__found_USCOREt(struct soap *soap, struct wsrp__found_USCOREt *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__found_USCOREt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__found_USCOREt * SOAP_FMAC4 soap_in_wsrp__found_USCOREt(struct soap *soap, const char *tag, struct wsrp__found_USCOREt *a, const char *type)
{
	struct soap_blist *soap_blist_at = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrp__found_USCOREt *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__found_USCOREt, sizeof(struct wsrp__found_USCOREt), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrp__found_USCOREt(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "at", 1, NULL))
			{	if (a->at == NULL)
				{	if (soap_blist_at == NULL)
						soap_blist_at = soap_new_block(soap);
					a->at = (char **)soap_push_block(soap, soap_blist_at, sizeof(char *));
					if (a->at == NULL)
						return NULL;
					*a->at = NULL;
				}soap_revert(soap);
				if (soap_in_string(soap, "at", a->at, "xsd:string"))
				{	a->__sizeat++;
					a->at = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->at)
			soap_pop_block(soap, soap_blist_at);
		if (a->__sizeat)
			a->at = (char **)soap_save_block(soap, soap_blist_at, NULL, 1);
		else
		{	a->at = NULL;
			if (soap_blist_at)
				soap_end_block(soap, soap_blist_at);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__found_USCOREt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrp__found_USCOREt, 0, sizeof(struct wsrp__found_USCOREt), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsrp__found_USCOREt * SOAP_FMAC4 soap_instantiate_wsrp__found_USCOREt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrp__found_USCOREt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsrp__found_USCOREt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct wsrp__found_USCOREt;
		if (size)
			*size = sizeof(struct wsrp__found_USCOREt);
	}
	else
	{	cp->ptr = (void*)new struct wsrp__found_USCOREt[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct wsrp__found_USCOREt);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct wsrp__found_USCOREt*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsrp__found_USCOREt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsrp__found_USCOREt %p -> %p\n", q, p));
	*(struct wsrp__found_USCOREt*)p = *(struct wsrp__found_USCOREt*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__rev_USCOREt(struct soap *soap, struct wsrp__rev_USCOREt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizevia = 0;
	a->wsrp__via = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__rev_USCOREt(struct soap *soap, const struct wsrp__rev_USCOREt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->wsrp__via)
	{	int i;
		for (i = 0; i < a->__sizevia; i++)
		{
			soap_serialize_PointerTowsrp__via_USCOREt(soap, a->wsrp__via + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__rev_USCOREt(struct soap *soap, const struct wsrp__rev_USCOREt *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrp__rev_USCOREt);
	if (soap_out_wsrp__rev_USCOREt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__rev_USCOREt(struct soap *soap, const char *tag, int id, const struct wsrp__rev_USCOREt *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrp__rev_USCOREt), type))
		return soap->error;
	if (a->wsrp__via)
	{	int i;
		for (i = 0; i < a->__sizevia; i++)
			if (soap_out_PointerTowsrp__via_USCOREt(soap, "wsrp:via", -1, a->wsrp__via + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrp__rev_USCOREt * SOAP_FMAC4 soap_get_wsrp__rev_USCOREt(struct soap *soap, struct wsrp__rev_USCOREt *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__rev_USCOREt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__rev_USCOREt * SOAP_FMAC4 soap_in_wsrp__rev_USCOREt(struct soap *soap, const char *tag, struct wsrp__rev_USCOREt *a, const char *type)
{
	struct soap_blist *soap_blist_wsrp__via = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrp__rev_USCOREt *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__rev_USCOREt, sizeof(struct wsrp__rev_USCOREt), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrp__rev_USCOREt(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrp:via", 1, NULL))
			{	if (a->wsrp__via == NULL)
				{	if (soap_blist_wsrp__via == NULL)
						soap_blist_wsrp__via = soap_new_block(soap);
					a->wsrp__via = (struct wsrp__via_USCOREt **)soap_push_block(soap, soap_blist_wsrp__via, sizeof(struct wsrp__via_USCOREt *));
					if (a->wsrp__via == NULL)
						return NULL;
					*a->wsrp__via = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTowsrp__via_USCOREt(soap, "wsrp:via", a->wsrp__via, "wsrp:via_t"))
				{	a->__sizevia++;
					a->wsrp__via = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrp__via)
			soap_pop_block(soap, soap_blist_wsrp__via);
		if (a->__sizevia)
			a->wsrp__via = (struct wsrp__via_USCOREt **)soap_save_block(soap, soap_blist_wsrp__via, NULL, 1);
		else
		{	a->wsrp__via = NULL;
			if (soap_blist_wsrp__via)
				soap_end_block(soap, soap_blist_wsrp__via);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__rev_USCOREt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrp__rev_USCOREt, 0, sizeof(struct wsrp__rev_USCOREt), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsrp__rev_USCOREt * SOAP_FMAC4 soap_instantiate_wsrp__rev_USCOREt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrp__rev_USCOREt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsrp__rev_USCOREt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct wsrp__rev_USCOREt;
		if (size)
			*size = sizeof(struct wsrp__rev_USCOREt);
	}
	else
	{	cp->ptr = (void*)new struct wsrp__rev_USCOREt[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct wsrp__rev_USCOREt);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct wsrp__rev_USCOREt*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsrp__rev_USCOREt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsrp__rev_USCOREt %p -> %p\n", q, p));
	*(struct wsrp__rev_USCOREt*)p = *(struct wsrp__rev_USCOREt*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__fwd_USCOREt(struct soap *soap, struct wsrp__fwd_USCOREt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizevia = 0;
	a->wsrp__via = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__fwd_USCOREt(struct soap *soap, const struct wsrp__fwd_USCOREt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->wsrp__via)
	{	int i;
		for (i = 0; i < a->__sizevia; i++)
		{
			soap_serialize_PointerTowsrp__via_USCOREt(soap, a->wsrp__via + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__fwd_USCOREt(struct soap *soap, const struct wsrp__fwd_USCOREt *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrp__fwd_USCOREt);
	if (soap_out_wsrp__fwd_USCOREt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__fwd_USCOREt(struct soap *soap, const char *tag, int id, const struct wsrp__fwd_USCOREt *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrp__fwd_USCOREt), type))
		return soap->error;
	if (a->wsrp__via)
	{	int i;
		for (i = 0; i < a->__sizevia; i++)
			if (soap_out_PointerTowsrp__via_USCOREt(soap, "wsrp:via", -1, a->wsrp__via + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrp__fwd_USCOREt * SOAP_FMAC4 soap_get_wsrp__fwd_USCOREt(struct soap *soap, struct wsrp__fwd_USCOREt *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__fwd_USCOREt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__fwd_USCOREt * SOAP_FMAC4 soap_in_wsrp__fwd_USCOREt(struct soap *soap, const char *tag, struct wsrp__fwd_USCOREt *a, const char *type)
{
	struct soap_blist *soap_blist_wsrp__via = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrp__fwd_USCOREt *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__fwd_USCOREt, sizeof(struct wsrp__fwd_USCOREt), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrp__fwd_USCOREt(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrp:via", 1, NULL))
			{	if (a->wsrp__via == NULL)
				{	if (soap_blist_wsrp__via == NULL)
						soap_blist_wsrp__via = soap_new_block(soap);
					a->wsrp__via = (struct wsrp__via_USCOREt **)soap_push_block(soap, soap_blist_wsrp__via, sizeof(struct wsrp__via_USCOREt *));
					if (a->wsrp__via == NULL)
						return NULL;
					*a->wsrp__via = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTowsrp__via_USCOREt(soap, "wsrp:via", a->wsrp__via, "wsrp:via_t"))
				{	a->__sizevia++;
					a->wsrp__via = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrp__via)
			soap_pop_block(soap, soap_blist_wsrp__via);
		if (a->__sizevia)
			a->wsrp__via = (struct wsrp__via_USCOREt **)soap_save_block(soap, soap_blist_wsrp__via, NULL, 1);
		else
		{	a->wsrp__via = NULL;
			if (soap_blist_wsrp__via)
				soap_end_block(soap, soap_blist_wsrp__via);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__fwd_USCOREt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrp__fwd_USCOREt, 0, sizeof(struct wsrp__fwd_USCOREt), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsrp__fwd_USCOREt * SOAP_FMAC4 soap_instantiate_wsrp__fwd_USCOREt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrp__fwd_USCOREt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsrp__fwd_USCOREt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct wsrp__fwd_USCOREt;
		if (size)
			*size = sizeof(struct wsrp__fwd_USCOREt);
	}
	else
	{	cp->ptr = (void*)new struct wsrp__fwd_USCOREt[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct wsrp__fwd_USCOREt);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct wsrp__fwd_USCOREt*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsrp__fwd_USCOREt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsrp__fwd_USCOREt %p -> %p\n", q, p));
	*(struct wsrp__fwd_USCOREt*)p = *(struct wsrp__fwd_USCOREt*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__via_USCOREt(struct soap *soap, struct wsrp__via_USCOREt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->vid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__via_USCOREt(struct soap *soap, const struct wsrp__via_USCOREt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__via_USCOREt(struct soap *soap, const struct wsrp__via_USCOREt *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrp__via_USCOREt);
	if (soap_out_wsrp__via_USCOREt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__via_USCOREt(struct soap *soap, const char *tag, int id, const struct wsrp__via_USCOREt *a, const char *type)
{
	if (a->vid)
		soap_set_attr(soap, "vid", a->vid);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsrp__via_USCOREt * SOAP_FMAC4 soap_get_wsrp__via_USCOREt(struct soap *soap, struct wsrp__via_USCOREt *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__via_USCOREt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__via_USCOREt * SOAP_FMAC4 soap_in_wsrp__via_USCOREt(struct soap *soap, const char *tag, struct wsrp__via_USCOREt *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsrp__via_USCOREt *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__via_USCOREt, sizeof(struct wsrp__via_USCOREt), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsrp__via_USCOREt(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "vid", 0), &a->vid))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "wsrp:via_t"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct wsrp__via_USCOREt * SOAP_FMAC4 soap_instantiate_wsrp__via_USCOREt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrp__via_USCOREt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsrp__via_USCOREt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct wsrp__via_USCOREt;
		if (size)
			*size = sizeof(struct wsrp__via_USCOREt);
	}
	else
	{	cp->ptr = (void*)new struct wsrp__via_USCOREt[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct wsrp__via_USCOREt);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct wsrp__via_USCOREt*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsrp__via_USCOREt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsrp__via_USCOREt %p -> %p\n", q, p));
	*(struct wsrp__via_USCOREt*)p = *(struct wsrp__via_USCOREt*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrp__path_USCOREt(struct soap *soap, struct wsrp__path_USCOREt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsrp__action);
	soap_default_string(soap, &a->wsrp__to);
	a->wsrp__fwd = NULL;
	a->wsrp__rev = NULL;
	soap_default_string(soap, &a->wsrp__from);
	soap_default_string(soap, &a->wsrp__id);
	soap_default_string(soap, &a->wsrp__relatesTo);
	a->wsrp__fault = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrp__path_USCOREt(struct soap *soap, const struct wsrp__path_USCOREt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->wsrp__action);
	soap_serialize_string(soap, &a->wsrp__to);
	soap_serialize_PointerTowsrp__fwd_USCOREt(soap, &a->wsrp__fwd);
	soap_serialize_PointerTowsrp__rev_USCOREt(soap, &a->wsrp__rev);
	soap_serialize_string(soap, &a->wsrp__from);
	soap_serialize_string(soap, &a->wsrp__id);
	soap_serialize_string(soap, &a->wsrp__relatesTo);
	soap_serialize_PointerTowsrp__fault_USCOREt(soap, &a->wsrp__fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrp__path_USCOREt(struct soap *soap, const struct wsrp__path_USCOREt *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrp__path_USCOREt);
	if (soap_out_wsrp__path_USCOREt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrp__path_USCOREt(struct soap *soap, const char *tag, int id, const struct wsrp__path_USCOREt *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrp__path_USCOREt), type))
		return soap->error;
	if (soap_out_string(soap, "wsrp:action", -1, &a->wsrp__action, ""))
		return soap->error;
	if (soap_out_string(soap, "wsrp:to", -1, &a->wsrp__to, ""))
		return soap->error;
	if (soap_out_PointerTowsrp__fwd_USCOREt(soap, "wsrp:fwd", -1, &a->wsrp__fwd, ""))
		return soap->error;
	if (soap_out_PointerTowsrp__rev_USCOREt(soap, "wsrp:rev", -1, &a->wsrp__rev, ""))
		return soap->error;
	if (soap_out_string(soap, "wsrp:from", -1, &a->wsrp__from, ""))
		return soap->error;
	if (soap_out_string(soap, "wsrp:id", -1, &a->wsrp__id, ""))
		return soap->error;
	if (soap_out_string(soap, "wsrp:relatesTo", -1, &a->wsrp__relatesTo, ""))
		return soap->error;
	if (soap_out_PointerTowsrp__fault_USCOREt(soap, "wsrp:fault", -1, &a->wsrp__fault, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrp__path_USCOREt * SOAP_FMAC4 soap_get_wsrp__path_USCOREt(struct soap *soap, struct wsrp__path_USCOREt *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrp__path_USCOREt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__path_USCOREt * SOAP_FMAC4 soap_in_wsrp__path_USCOREt(struct soap *soap, const char *tag, struct wsrp__path_USCOREt *a, const char *type)
{
	size_t soap_flag_wsrp__action = 1;
	size_t soap_flag_wsrp__to = 1;
	size_t soap_flag_wsrp__fwd = 1;
	size_t soap_flag_wsrp__rev = 1;
	size_t soap_flag_wsrp__from = 1;
	size_t soap_flag_wsrp__id = 1;
	size_t soap_flag_wsrp__relatesTo = 1;
	size_t soap_flag_wsrp__fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrp__path_USCOREt *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrp__path_USCOREt, sizeof(struct wsrp__path_USCOREt), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrp__path_USCOREt(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrp__action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsrp:action", &a->wsrp__action, "xsd:string"))
				{	soap_flag_wsrp__action--;
					continue;
				}
			if (soap_flag_wsrp__to && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsrp:to", &a->wsrp__to, "xsd:string"))
				{	soap_flag_wsrp__to--;
					continue;
				}
			if (soap_flag_wsrp__fwd && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsrp__fwd_USCOREt(soap, "wsrp:fwd", &a->wsrp__fwd, "wsrp:fwd_t"))
				{	soap_flag_wsrp__fwd--;
					continue;
				}
			if (soap_flag_wsrp__rev && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsrp__rev_USCOREt(soap, "wsrp:rev", &a->wsrp__rev, "wsrp:rev_t"))
				{	soap_flag_wsrp__rev--;
					continue;
				}
			if (soap_flag_wsrp__from && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsrp:from", &a->wsrp__from, "xsd:string"))
				{	soap_flag_wsrp__from--;
					continue;
				}
			if (soap_flag_wsrp__id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsrp:id", &a->wsrp__id, "xsd:string"))
				{	soap_flag_wsrp__id--;
					continue;
				}
			if (soap_flag_wsrp__relatesTo && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsrp:relatesTo", &a->wsrp__relatesTo, "xsd:string"))
				{	soap_flag_wsrp__relatesTo--;
					continue;
				}
			if (soap_flag_wsrp__fault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsrp__fault_USCOREt(soap, "wsrp:fault", &a->wsrp__fault, "wsrp:fault_t"))
				{	soap_flag_wsrp__fault--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrp__path_USCOREt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrp__path_USCOREt, 0, sizeof(struct wsrp__path_USCOREt), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap_flag_wsrp__action > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsrp__path_USCOREt * SOAP_FMAC4 soap_instantiate_wsrp__path_USCOREt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrp__path_USCOREt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsrp__path_USCOREt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct wsrp__path_USCOREt;
		if (size)
			*size = sizeof(struct wsrp__path_USCOREt);
	}
	else
	{	cp->ptr = (void*)new struct wsrp__path_USCOREt[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct wsrp__path_USCOREt);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct wsrp__path_USCOREt*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsrp__path_USCOREt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsrp__path_USCOREt %p -> %p\n", q, p));
	*(struct wsrp__path_USCOREt*)p = *(struct wsrp__path_USCOREt*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__DownloadVersionResponse(struct soap *soap, _ns3__DownloadVersionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__DownloadVersionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__DownloadVersionResponse(struct soap *soap, _ns3__DownloadVersionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__DownloadVersionResponse);
	if (soap_out_PointerTo_ns3__DownloadVersionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__DownloadVersionResponse(struct soap *soap, const char *tag, int id, _ns3__DownloadVersionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__DownloadVersionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__DownloadVersionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__DownloadVersionResponse(struct soap *soap, _ns3__DownloadVersionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__DownloadVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__DownloadVersionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__DownloadVersionResponse(struct soap *soap, const char *tag, _ns3__DownloadVersionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__DownloadVersionResponse **)soap_malloc(soap, sizeof(_ns3__DownloadVersionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__DownloadVersionResponse *)soap_instantiate__ns3__DownloadVersionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__DownloadVersionResponse ** p = (_ns3__DownloadVersionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__DownloadVersionResponse, sizeof(_ns3__DownloadVersionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__DownloadVersion(struct soap *soap, _ns3__DownloadVersion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__DownloadVersion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__DownloadVersion(struct soap *soap, _ns3__DownloadVersion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__DownloadVersion);
	if (soap_out_PointerTo_ns3__DownloadVersion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__DownloadVersion(struct soap *soap, const char *tag, int id, _ns3__DownloadVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__DownloadVersion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__DownloadVersion ** SOAP_FMAC4 soap_get_PointerTo_ns3__DownloadVersion(struct soap *soap, _ns3__DownloadVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__DownloadVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__DownloadVersion ** SOAP_FMAC4 soap_in_PointerTo_ns3__DownloadVersion(struct soap *soap, const char *tag, _ns3__DownloadVersion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__DownloadVersion **)soap_malloc(soap, sizeof(_ns3__DownloadVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__DownloadVersion *)soap_instantiate__ns3__DownloadVersion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__DownloadVersion ** p = (_ns3__DownloadVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__DownloadVersion, sizeof(_ns3__DownloadVersion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__CheckInAssetResponse(struct soap *soap, _ns3__CheckInAssetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__CheckInAssetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__CheckInAssetResponse(struct soap *soap, _ns3__CheckInAssetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__CheckInAssetResponse);
	if (soap_out_PointerTo_ns3__CheckInAssetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__CheckInAssetResponse(struct soap *soap, const char *tag, int id, _ns3__CheckInAssetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__CheckInAssetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__CheckInAssetResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__CheckInAssetResponse(struct soap *soap, _ns3__CheckInAssetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__CheckInAssetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__CheckInAssetResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__CheckInAssetResponse(struct soap *soap, const char *tag, _ns3__CheckInAssetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__CheckInAssetResponse **)soap_malloc(soap, sizeof(_ns3__CheckInAssetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__CheckInAssetResponse *)soap_instantiate__ns3__CheckInAssetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__CheckInAssetResponse ** p = (_ns3__CheckInAssetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__CheckInAssetResponse, sizeof(_ns3__CheckInAssetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__CheckInAsset(struct soap *soap, _ns3__CheckInAsset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__CheckInAsset))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__CheckInAsset(struct soap *soap, _ns3__CheckInAsset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__CheckInAsset);
	if (soap_out_PointerTo_ns3__CheckInAsset(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__CheckInAsset(struct soap *soap, const char *tag, int id, _ns3__CheckInAsset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__CheckInAsset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__CheckInAsset ** SOAP_FMAC4 soap_get_PointerTo_ns3__CheckInAsset(struct soap *soap, _ns3__CheckInAsset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__CheckInAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__CheckInAsset ** SOAP_FMAC4 soap_in_PointerTo_ns3__CheckInAsset(struct soap *soap, const char *tag, _ns3__CheckInAsset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__CheckInAsset **)soap_malloc(soap, sizeof(_ns3__CheckInAsset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__CheckInAsset *)soap_instantiate__ns3__CheckInAsset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__CheckInAsset ** p = (_ns3__CheckInAsset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__CheckInAsset, sizeof(_ns3__CheckInAsset), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetLockResponse(struct soap *soap, _ns3__GetLockResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetLockResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetLockResponse(struct soap *soap, _ns3__GetLockResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetLockResponse);
	if (soap_out_PointerTo_ns3__GetLockResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetLockResponse(struct soap *soap, const char *tag, int id, _ns3__GetLockResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetLockResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetLockResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetLockResponse(struct soap *soap, _ns3__GetLockResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetLockResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetLockResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetLockResponse(struct soap *soap, const char *tag, _ns3__GetLockResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetLockResponse **)soap_malloc(soap, sizeof(_ns3__GetLockResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetLockResponse *)soap_instantiate__ns3__GetLockResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetLockResponse ** p = (_ns3__GetLockResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetLockResponse, sizeof(_ns3__GetLockResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetLock(struct soap *soap, _ns3__GetLock *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetLock))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetLock(struct soap *soap, _ns3__GetLock *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetLock);
	if (soap_out_PointerTo_ns3__GetLock(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetLock(struct soap *soap, const char *tag, int id, _ns3__GetLock *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetLock);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetLock ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetLock(struct soap *soap, _ns3__GetLock **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetLock(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetLock ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetLock(struct soap *soap, const char *tag, _ns3__GetLock **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetLock **)soap_malloc(soap, sizeof(_ns3__GetLock *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetLock *)soap_instantiate__ns3__GetLock(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetLock ** p = (_ns3__GetLock **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetLock, sizeof(_ns3__GetLock), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__UpdateAssetStatusResponse(struct soap *soap, _ns3__UpdateAssetStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__UpdateAssetStatusResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__UpdateAssetStatusResponse(struct soap *soap, _ns3__UpdateAssetStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__UpdateAssetStatusResponse);
	if (soap_out_PointerTo_ns3__UpdateAssetStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__UpdateAssetStatusResponse(struct soap *soap, const char *tag, int id, _ns3__UpdateAssetStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__UpdateAssetStatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__UpdateAssetStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__UpdateAssetStatusResponse(struct soap *soap, _ns3__UpdateAssetStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__UpdateAssetStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__UpdateAssetStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__UpdateAssetStatusResponse(struct soap *soap, const char *tag, _ns3__UpdateAssetStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__UpdateAssetStatusResponse **)soap_malloc(soap, sizeof(_ns3__UpdateAssetStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__UpdateAssetStatusResponse *)soap_instantiate__ns3__UpdateAssetStatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__UpdateAssetStatusResponse ** p = (_ns3__UpdateAssetStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__UpdateAssetStatusResponse, sizeof(_ns3__UpdateAssetStatusResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__UpdateAssetStatus(struct soap *soap, _ns3__UpdateAssetStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__UpdateAssetStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__UpdateAssetStatus(struct soap *soap, _ns3__UpdateAssetStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__UpdateAssetStatus);
	if (soap_out_PointerTo_ns3__UpdateAssetStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__UpdateAssetStatus(struct soap *soap, const char *tag, int id, _ns3__UpdateAssetStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__UpdateAssetStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__UpdateAssetStatus ** SOAP_FMAC4 soap_get_PointerTo_ns3__UpdateAssetStatus(struct soap *soap, _ns3__UpdateAssetStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__UpdateAssetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__UpdateAssetStatus ** SOAP_FMAC4 soap_in_PointerTo_ns3__UpdateAssetStatus(struct soap *soap, const char *tag, _ns3__UpdateAssetStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__UpdateAssetStatus **)soap_malloc(soap, sizeof(_ns3__UpdateAssetStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__UpdateAssetStatus *)soap_instantiate__ns3__UpdateAssetStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__UpdateAssetStatus ** p = (_ns3__UpdateAssetStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__UpdateAssetStatus, sizeof(_ns3__UpdateAssetStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__UpdateAssetResponse(struct soap *soap, _ns3__UpdateAssetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__UpdateAssetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__UpdateAssetResponse(struct soap *soap, _ns3__UpdateAssetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__UpdateAssetResponse);
	if (soap_out_PointerTo_ns3__UpdateAssetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__UpdateAssetResponse(struct soap *soap, const char *tag, int id, _ns3__UpdateAssetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__UpdateAssetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__UpdateAssetResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__UpdateAssetResponse(struct soap *soap, _ns3__UpdateAssetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__UpdateAssetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__UpdateAssetResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__UpdateAssetResponse(struct soap *soap, const char *tag, _ns3__UpdateAssetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__UpdateAssetResponse **)soap_malloc(soap, sizeof(_ns3__UpdateAssetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__UpdateAssetResponse *)soap_instantiate__ns3__UpdateAssetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__UpdateAssetResponse ** p = (_ns3__UpdateAssetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__UpdateAssetResponse, sizeof(_ns3__UpdateAssetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__UpdateAsset(struct soap *soap, _ns3__UpdateAsset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__UpdateAsset))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__UpdateAsset(struct soap *soap, _ns3__UpdateAsset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__UpdateAsset);
	if (soap_out_PointerTo_ns3__UpdateAsset(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__UpdateAsset(struct soap *soap, const char *tag, int id, _ns3__UpdateAsset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__UpdateAsset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__UpdateAsset ** SOAP_FMAC4 soap_get_PointerTo_ns3__UpdateAsset(struct soap *soap, _ns3__UpdateAsset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__UpdateAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__UpdateAsset ** SOAP_FMAC4 soap_in_PointerTo_ns3__UpdateAsset(struct soap *soap, const char *tag, _ns3__UpdateAsset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__UpdateAsset **)soap_malloc(soap, sizeof(_ns3__UpdateAsset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__UpdateAsset *)soap_instantiate__ns3__UpdateAsset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__UpdateAsset ** p = (_ns3__UpdateAsset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__UpdateAsset, sizeof(_ns3__UpdateAsset), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetAssetListResponse(struct soap *soap, _ns3__GetAssetListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetAssetListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetAssetListResponse(struct soap *soap, _ns3__GetAssetListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetAssetListResponse);
	if (soap_out_PointerTo_ns3__GetAssetListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetAssetListResponse(struct soap *soap, const char *tag, int id, _ns3__GetAssetListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetAssetListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetAssetListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetAssetListResponse(struct soap *soap, _ns3__GetAssetListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetAssetListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetAssetListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetAssetListResponse(struct soap *soap, const char *tag, _ns3__GetAssetListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetAssetListResponse **)soap_malloc(soap, sizeof(_ns3__GetAssetListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetAssetListResponse *)soap_instantiate__ns3__GetAssetListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetAssetListResponse ** p = (_ns3__GetAssetListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetAssetListResponse, sizeof(_ns3__GetAssetListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetAssetList(struct soap *soap, _ns3__GetAssetList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetAssetList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetAssetList(struct soap *soap, _ns3__GetAssetList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetAssetList);
	if (soap_out_PointerTo_ns3__GetAssetList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetAssetList(struct soap *soap, const char *tag, int id, _ns3__GetAssetList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetAssetList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetAssetList ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetAssetList(struct soap *soap, _ns3__GetAssetList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetAssetList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetAssetList ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetAssetList(struct soap *soap, const char *tag, _ns3__GetAssetList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetAssetList **)soap_malloc(soap, sizeof(_ns3__GetAssetList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetAssetList *)soap_instantiate__ns3__GetAssetList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetAssetList ** p = (_ns3__GetAssetList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetAssetList, sizeof(_ns3__GetAssetList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetStatusByTitleResponse(struct soap *soap, _ns3__GetStatusByTitleResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetStatusByTitleResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetStatusByTitleResponse(struct soap *soap, _ns3__GetStatusByTitleResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetStatusByTitleResponse);
	if (soap_out_PointerTo_ns3__GetStatusByTitleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetStatusByTitleResponse(struct soap *soap, const char *tag, int id, _ns3__GetStatusByTitleResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetStatusByTitleResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetStatusByTitleResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetStatusByTitleResponse(struct soap *soap, _ns3__GetStatusByTitleResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetStatusByTitleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetStatusByTitleResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetStatusByTitleResponse(struct soap *soap, const char *tag, _ns3__GetStatusByTitleResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetStatusByTitleResponse **)soap_malloc(soap, sizeof(_ns3__GetStatusByTitleResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetStatusByTitleResponse *)soap_instantiate__ns3__GetStatusByTitleResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetStatusByTitleResponse ** p = (_ns3__GetStatusByTitleResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetStatusByTitleResponse, sizeof(_ns3__GetStatusByTitleResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetStatusByTitle(struct soap *soap, _ns3__GetStatusByTitle *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetStatusByTitle))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetStatusByTitle(struct soap *soap, _ns3__GetStatusByTitle *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetStatusByTitle);
	if (soap_out_PointerTo_ns3__GetStatusByTitle(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetStatusByTitle(struct soap *soap, const char *tag, int id, _ns3__GetStatusByTitle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetStatusByTitle);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetStatusByTitle ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetStatusByTitle(struct soap *soap, _ns3__GetStatusByTitle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetStatusByTitle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetStatusByTitle ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetStatusByTitle(struct soap *soap, const char *tag, _ns3__GetStatusByTitle **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetStatusByTitle **)soap_malloc(soap, sizeof(_ns3__GetStatusByTitle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetStatusByTitle *)soap_instantiate__ns3__GetStatusByTitle(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetStatusByTitle ** p = (_ns3__GetStatusByTitle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetStatusByTitle, sizeof(_ns3__GetStatusByTitle), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetEditionsByTitleResponse(struct soap *soap, _ns3__GetEditionsByTitleResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetEditionsByTitleResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetEditionsByTitleResponse(struct soap *soap, _ns3__GetEditionsByTitleResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetEditionsByTitleResponse);
	if (soap_out_PointerTo_ns3__GetEditionsByTitleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetEditionsByTitleResponse(struct soap *soap, const char *tag, int id, _ns3__GetEditionsByTitleResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetEditionsByTitleResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetEditionsByTitleResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetEditionsByTitleResponse(struct soap *soap, _ns3__GetEditionsByTitleResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetEditionsByTitleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetEditionsByTitleResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetEditionsByTitleResponse(struct soap *soap, const char *tag, _ns3__GetEditionsByTitleResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetEditionsByTitleResponse **)soap_malloc(soap, sizeof(_ns3__GetEditionsByTitleResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetEditionsByTitleResponse *)soap_instantiate__ns3__GetEditionsByTitleResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetEditionsByTitleResponse ** p = (_ns3__GetEditionsByTitleResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetEditionsByTitleResponse, sizeof(_ns3__GetEditionsByTitleResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetEditionsByTitle(struct soap *soap, _ns3__GetEditionsByTitle *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetEditionsByTitle))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetEditionsByTitle(struct soap *soap, _ns3__GetEditionsByTitle *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetEditionsByTitle);
	if (soap_out_PointerTo_ns3__GetEditionsByTitle(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetEditionsByTitle(struct soap *soap, const char *tag, int id, _ns3__GetEditionsByTitle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetEditionsByTitle);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetEditionsByTitle ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetEditionsByTitle(struct soap *soap, _ns3__GetEditionsByTitle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetEditionsByTitle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetEditionsByTitle ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetEditionsByTitle(struct soap *soap, const char *tag, _ns3__GetEditionsByTitle **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetEditionsByTitle **)soap_malloc(soap, sizeof(_ns3__GetEditionsByTitle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetEditionsByTitle *)soap_instantiate__ns3__GetEditionsByTitle(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetEditionsByTitle ** p = (_ns3__GetEditionsByTitle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetEditionsByTitle, sizeof(_ns3__GetEditionsByTitle), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__CheckOutAssetResponse(struct soap *soap, _ns3__CheckOutAssetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__CheckOutAssetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__CheckOutAssetResponse(struct soap *soap, _ns3__CheckOutAssetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__CheckOutAssetResponse);
	if (soap_out_PointerTo_ns3__CheckOutAssetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__CheckOutAssetResponse(struct soap *soap, const char *tag, int id, _ns3__CheckOutAssetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__CheckOutAssetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__CheckOutAssetResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__CheckOutAssetResponse(struct soap *soap, _ns3__CheckOutAssetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__CheckOutAssetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__CheckOutAssetResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__CheckOutAssetResponse(struct soap *soap, const char *tag, _ns3__CheckOutAssetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__CheckOutAssetResponse **)soap_malloc(soap, sizeof(_ns3__CheckOutAssetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__CheckOutAssetResponse *)soap_instantiate__ns3__CheckOutAssetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__CheckOutAssetResponse ** p = (_ns3__CheckOutAssetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__CheckOutAssetResponse, sizeof(_ns3__CheckOutAssetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__CheckOutAsset(struct soap *soap, _ns3__CheckOutAsset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__CheckOutAsset))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__CheckOutAsset(struct soap *soap, _ns3__CheckOutAsset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__CheckOutAsset);
	if (soap_out_PointerTo_ns3__CheckOutAsset(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__CheckOutAsset(struct soap *soap, const char *tag, int id, _ns3__CheckOutAsset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__CheckOutAsset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__CheckOutAsset ** SOAP_FMAC4 soap_get_PointerTo_ns3__CheckOutAsset(struct soap *soap, _ns3__CheckOutAsset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__CheckOutAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__CheckOutAsset ** SOAP_FMAC4 soap_in_PointerTo_ns3__CheckOutAsset(struct soap *soap, const char *tag, _ns3__CheckOutAsset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__CheckOutAsset **)soap_malloc(soap, sizeof(_ns3__CheckOutAsset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__CheckOutAsset *)soap_instantiate__ns3__CheckOutAsset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__CheckOutAsset ** p = (_ns3__CheckOutAsset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__CheckOutAsset, sizeof(_ns3__CheckOutAsset), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetEditionTaskListResponse(struct soap *soap, _ns3__GetEditionTaskListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetEditionTaskListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetEditionTaskListResponse(struct soap *soap, _ns3__GetEditionTaskListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetEditionTaskListResponse);
	if (soap_out_PointerTo_ns3__GetEditionTaskListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetEditionTaskListResponse(struct soap *soap, const char *tag, int id, _ns3__GetEditionTaskListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetEditionTaskListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetEditionTaskListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetEditionTaskListResponse(struct soap *soap, _ns3__GetEditionTaskListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetEditionTaskListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetEditionTaskListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetEditionTaskListResponse(struct soap *soap, const char *tag, _ns3__GetEditionTaskListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetEditionTaskListResponse **)soap_malloc(soap, sizeof(_ns3__GetEditionTaskListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetEditionTaskListResponse *)soap_instantiate__ns3__GetEditionTaskListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetEditionTaskListResponse ** p = (_ns3__GetEditionTaskListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetEditionTaskListResponse, sizeof(_ns3__GetEditionTaskListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetEditionTaskList(struct soap *soap, _ns3__GetEditionTaskList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetEditionTaskList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetEditionTaskList(struct soap *soap, _ns3__GetEditionTaskList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetEditionTaskList);
	if (soap_out_PointerTo_ns3__GetEditionTaskList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetEditionTaskList(struct soap *soap, const char *tag, int id, _ns3__GetEditionTaskList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetEditionTaskList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetEditionTaskList ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetEditionTaskList(struct soap *soap, _ns3__GetEditionTaskList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetEditionTaskList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetEditionTaskList ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetEditionTaskList(struct soap *soap, const char *tag, _ns3__GetEditionTaskList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetEditionTaskList **)soap_malloc(soap, sizeof(_ns3__GetEditionTaskList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetEditionTaskList *)soap_instantiate__ns3__GetEditionTaskList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetEditionTaskList ** p = (_ns3__GetEditionTaskList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetEditionTaskList, sizeof(_ns3__GetEditionTaskList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__RelinkAssetResponse(struct soap *soap, _ns3__RelinkAssetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__RelinkAssetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__RelinkAssetResponse(struct soap *soap, _ns3__RelinkAssetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__RelinkAssetResponse);
	if (soap_out_PointerTo_ns3__RelinkAssetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__RelinkAssetResponse(struct soap *soap, const char *tag, int id, _ns3__RelinkAssetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__RelinkAssetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__RelinkAssetResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__RelinkAssetResponse(struct soap *soap, _ns3__RelinkAssetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__RelinkAssetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__RelinkAssetResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__RelinkAssetResponse(struct soap *soap, const char *tag, _ns3__RelinkAssetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__RelinkAssetResponse **)soap_malloc(soap, sizeof(_ns3__RelinkAssetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__RelinkAssetResponse *)soap_instantiate__ns3__RelinkAssetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__RelinkAssetResponse ** p = (_ns3__RelinkAssetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__RelinkAssetResponse, sizeof(_ns3__RelinkAssetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__RelinkAsset(struct soap *soap, _ns3__RelinkAsset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__RelinkAsset))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__RelinkAsset(struct soap *soap, _ns3__RelinkAsset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__RelinkAsset);
	if (soap_out_PointerTo_ns3__RelinkAsset(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__RelinkAsset(struct soap *soap, const char *tag, int id, _ns3__RelinkAsset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__RelinkAsset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__RelinkAsset ** SOAP_FMAC4 soap_get_PointerTo_ns3__RelinkAsset(struct soap *soap, _ns3__RelinkAsset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__RelinkAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__RelinkAsset ** SOAP_FMAC4 soap_in_PointerTo_ns3__RelinkAsset(struct soap *soap, const char *tag, _ns3__RelinkAsset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__RelinkAsset **)soap_malloc(soap, sizeof(_ns3__RelinkAsset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__RelinkAsset *)soap_instantiate__ns3__RelinkAsset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__RelinkAsset ** p = (_ns3__RelinkAsset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__RelinkAsset, sizeof(_ns3__RelinkAsset), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__UnlinkAssetResponse(struct soap *soap, _ns3__UnlinkAssetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__UnlinkAssetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__UnlinkAssetResponse(struct soap *soap, _ns3__UnlinkAssetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__UnlinkAssetResponse);
	if (soap_out_PointerTo_ns3__UnlinkAssetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__UnlinkAssetResponse(struct soap *soap, const char *tag, int id, _ns3__UnlinkAssetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__UnlinkAssetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__UnlinkAssetResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__UnlinkAssetResponse(struct soap *soap, _ns3__UnlinkAssetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__UnlinkAssetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__UnlinkAssetResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__UnlinkAssetResponse(struct soap *soap, const char *tag, _ns3__UnlinkAssetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__UnlinkAssetResponse **)soap_malloc(soap, sizeof(_ns3__UnlinkAssetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__UnlinkAssetResponse *)soap_instantiate__ns3__UnlinkAssetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__UnlinkAssetResponse ** p = (_ns3__UnlinkAssetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__UnlinkAssetResponse, sizeof(_ns3__UnlinkAssetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__UnlinkAsset(struct soap *soap, _ns3__UnlinkAsset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__UnlinkAsset))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__UnlinkAsset(struct soap *soap, _ns3__UnlinkAsset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__UnlinkAsset);
	if (soap_out_PointerTo_ns3__UnlinkAsset(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__UnlinkAsset(struct soap *soap, const char *tag, int id, _ns3__UnlinkAsset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__UnlinkAsset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__UnlinkAsset ** SOAP_FMAC4 soap_get_PointerTo_ns3__UnlinkAsset(struct soap *soap, _ns3__UnlinkAsset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__UnlinkAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__UnlinkAsset ** SOAP_FMAC4 soap_in_PointerTo_ns3__UnlinkAsset(struct soap *soap, const char *tag, _ns3__UnlinkAsset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__UnlinkAsset **)soap_malloc(soap, sizeof(_ns3__UnlinkAsset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__UnlinkAsset *)soap_instantiate__ns3__UnlinkAsset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__UnlinkAsset ** p = (_ns3__UnlinkAsset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__UnlinkAsset, sizeof(_ns3__UnlinkAsset), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__UploadExportResponse(struct soap *soap, _ns3__UploadExportResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__UploadExportResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__UploadExportResponse(struct soap *soap, _ns3__UploadExportResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__UploadExportResponse);
	if (soap_out_PointerTo_ns3__UploadExportResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__UploadExportResponse(struct soap *soap, const char *tag, int id, _ns3__UploadExportResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__UploadExportResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__UploadExportResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__UploadExportResponse(struct soap *soap, _ns3__UploadExportResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__UploadExportResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__UploadExportResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__UploadExportResponse(struct soap *soap, const char *tag, _ns3__UploadExportResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__UploadExportResponse **)soap_malloc(soap, sizeof(_ns3__UploadExportResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__UploadExportResponse *)soap_instantiate__ns3__UploadExportResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__UploadExportResponse ** p = (_ns3__UploadExportResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__UploadExportResponse, sizeof(_ns3__UploadExportResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__UploadExport(struct soap *soap, _ns3__UploadExport *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__UploadExport))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__UploadExport(struct soap *soap, _ns3__UploadExport *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__UploadExport);
	if (soap_out_PointerTo_ns3__UploadExport(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__UploadExport(struct soap *soap, const char *tag, int id, _ns3__UploadExport *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__UploadExport);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__UploadExport ** SOAP_FMAC4 soap_get_PointerTo_ns3__UploadExport(struct soap *soap, _ns3__UploadExport **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__UploadExport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__UploadExport ** SOAP_FMAC4 soap_in_PointerTo_ns3__UploadExport(struct soap *soap, const char *tag, _ns3__UploadExport **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__UploadExport **)soap_malloc(soap, sizeof(_ns3__UploadExport *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__UploadExport *)soap_instantiate__ns3__UploadExport(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__UploadExport ** p = (_ns3__UploadExport **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__UploadExport, sizeof(_ns3__UploadExport), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__UploadVersionResponse(struct soap *soap, _ns3__UploadVersionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__UploadVersionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__UploadVersionResponse(struct soap *soap, _ns3__UploadVersionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__UploadVersionResponse);
	if (soap_out_PointerTo_ns3__UploadVersionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__UploadVersionResponse(struct soap *soap, const char *tag, int id, _ns3__UploadVersionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__UploadVersionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__UploadVersionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__UploadVersionResponse(struct soap *soap, _ns3__UploadVersionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__UploadVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__UploadVersionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__UploadVersionResponse(struct soap *soap, const char *tag, _ns3__UploadVersionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__UploadVersionResponse **)soap_malloc(soap, sizeof(_ns3__UploadVersionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__UploadVersionResponse *)soap_instantiate__ns3__UploadVersionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__UploadVersionResponse ** p = (_ns3__UploadVersionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__UploadVersionResponse, sizeof(_ns3__UploadVersionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__UploadVersion(struct soap *soap, _ns3__UploadVersion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__UploadVersion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__UploadVersion(struct soap *soap, _ns3__UploadVersion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__UploadVersion);
	if (soap_out_PointerTo_ns3__UploadVersion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__UploadVersion(struct soap *soap, const char *tag, int id, _ns3__UploadVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__UploadVersion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__UploadVersion ** SOAP_FMAC4 soap_get_PointerTo_ns3__UploadVersion(struct soap *soap, _ns3__UploadVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__UploadVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__UploadVersion ** SOAP_FMAC4 soap_in_PointerTo_ns3__UploadVersion(struct soap *soap, const char *tag, _ns3__UploadVersion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__UploadVersion **)soap_malloc(soap, sizeof(_ns3__UploadVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__UploadVersion *)soap_instantiate__ns3__UploadVersion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__UploadVersion ** p = (_ns3__UploadVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__UploadVersion, sizeof(_ns3__UploadVersion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__UploadPageResponse(struct soap *soap, _ns3__UploadPageResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__UploadPageResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__UploadPageResponse(struct soap *soap, _ns3__UploadPageResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__UploadPageResponse);
	if (soap_out_PointerTo_ns3__UploadPageResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__UploadPageResponse(struct soap *soap, const char *tag, int id, _ns3__UploadPageResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__UploadPageResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__UploadPageResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__UploadPageResponse(struct soap *soap, _ns3__UploadPageResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__UploadPageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__UploadPageResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__UploadPageResponse(struct soap *soap, const char *tag, _ns3__UploadPageResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__UploadPageResponse **)soap_malloc(soap, sizeof(_ns3__UploadPageResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__UploadPageResponse *)soap_instantiate__ns3__UploadPageResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__UploadPageResponse ** p = (_ns3__UploadPageResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__UploadPageResponse, sizeof(_ns3__UploadPageResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__UploadPage(struct soap *soap, _ns3__UploadPage *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__UploadPage))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__UploadPage(struct soap *soap, _ns3__UploadPage *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__UploadPage);
	if (soap_out_PointerTo_ns3__UploadPage(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__UploadPage(struct soap *soap, const char *tag, int id, _ns3__UploadPage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__UploadPage);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__UploadPage ** SOAP_FMAC4 soap_get_PointerTo_ns3__UploadPage(struct soap *soap, _ns3__UploadPage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__UploadPage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__UploadPage ** SOAP_FMAC4 soap_in_PointerTo_ns3__UploadPage(struct soap *soap, const char *tag, _ns3__UploadPage **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__UploadPage **)soap_malloc(soap, sizeof(_ns3__UploadPage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__UploadPage *)soap_instantiate__ns3__UploadPage(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__UploadPage ** p = (_ns3__UploadPage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__UploadPage, sizeof(_ns3__UploadPage), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__UploadPDFResponse(struct soap *soap, _ns3__UploadPDFResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__UploadPDFResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__UploadPDFResponse(struct soap *soap, _ns3__UploadPDFResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__UploadPDFResponse);
	if (soap_out_PointerTo_ns3__UploadPDFResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__UploadPDFResponse(struct soap *soap, const char *tag, int id, _ns3__UploadPDFResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__UploadPDFResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__UploadPDFResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__UploadPDFResponse(struct soap *soap, _ns3__UploadPDFResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__UploadPDFResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__UploadPDFResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__UploadPDFResponse(struct soap *soap, const char *tag, _ns3__UploadPDFResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__UploadPDFResponse **)soap_malloc(soap, sizeof(_ns3__UploadPDFResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__UploadPDFResponse *)soap_instantiate__ns3__UploadPDFResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__UploadPDFResponse ** p = (_ns3__UploadPDFResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__UploadPDFResponse, sizeof(_ns3__UploadPDFResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__UploadPDF(struct soap *soap, _ns3__UploadPDF *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__UploadPDF))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__UploadPDF(struct soap *soap, _ns3__UploadPDF *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__UploadPDF);
	if (soap_out_PointerTo_ns3__UploadPDF(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__UploadPDF(struct soap *soap, const char *tag, int id, _ns3__UploadPDF *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__UploadPDF);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__UploadPDF ** SOAP_FMAC4 soap_get_PointerTo_ns3__UploadPDF(struct soap *soap, _ns3__UploadPDF **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__UploadPDF(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__UploadPDF ** SOAP_FMAC4 soap_in_PointerTo_ns3__UploadPDF(struct soap *soap, const char *tag, _ns3__UploadPDF **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__UploadPDF **)soap_malloc(soap, sizeof(_ns3__UploadPDF *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__UploadPDF *)soap_instantiate__ns3__UploadPDF(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__UploadPDF ** p = (_ns3__UploadPDF **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__UploadPDF, sizeof(_ns3__UploadPDF), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetAssetResponse(struct soap *soap, _ns3__GetAssetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetAssetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetAssetResponse(struct soap *soap, _ns3__GetAssetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetAssetResponse);
	if (soap_out_PointerTo_ns3__GetAssetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetAssetResponse(struct soap *soap, const char *tag, int id, _ns3__GetAssetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetAssetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetAssetResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetAssetResponse(struct soap *soap, _ns3__GetAssetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetAssetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetAssetResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetAssetResponse(struct soap *soap, const char *tag, _ns3__GetAssetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetAssetResponse **)soap_malloc(soap, sizeof(_ns3__GetAssetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetAssetResponse *)soap_instantiate__ns3__GetAssetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetAssetResponse ** p = (_ns3__GetAssetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetAssetResponse, sizeof(_ns3__GetAssetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetAsset(struct soap *soap, _ns3__GetAsset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetAsset))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetAsset(struct soap *soap, _ns3__GetAsset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetAsset);
	if (soap_out_PointerTo_ns3__GetAsset(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetAsset(struct soap *soap, const char *tag, int id, _ns3__GetAsset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetAsset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetAsset ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetAsset(struct soap *soap, _ns3__GetAsset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetAsset ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetAsset(struct soap *soap, const char *tag, _ns3__GetAsset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetAsset **)soap_malloc(soap, sizeof(_ns3__GetAsset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetAsset *)soap_instantiate__ns3__GetAsset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetAsset ** p = (_ns3__GetAsset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetAsset, sizeof(_ns3__GetAsset), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__CanUpdateAssetNameResponse(struct soap *soap, _ns3__CanUpdateAssetNameResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__CanUpdateAssetNameResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__CanUpdateAssetNameResponse(struct soap *soap, _ns3__CanUpdateAssetNameResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__CanUpdateAssetNameResponse);
	if (soap_out_PointerTo_ns3__CanUpdateAssetNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__CanUpdateAssetNameResponse(struct soap *soap, const char *tag, int id, _ns3__CanUpdateAssetNameResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__CanUpdateAssetNameResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__CanUpdateAssetNameResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__CanUpdateAssetNameResponse(struct soap *soap, _ns3__CanUpdateAssetNameResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__CanUpdateAssetNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__CanUpdateAssetNameResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__CanUpdateAssetNameResponse(struct soap *soap, const char *tag, _ns3__CanUpdateAssetNameResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__CanUpdateAssetNameResponse **)soap_malloc(soap, sizeof(_ns3__CanUpdateAssetNameResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__CanUpdateAssetNameResponse *)soap_instantiate__ns3__CanUpdateAssetNameResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__CanUpdateAssetNameResponse ** p = (_ns3__CanUpdateAssetNameResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__CanUpdateAssetNameResponse, sizeof(_ns3__CanUpdateAssetNameResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__CanUpdateAssetName(struct soap *soap, _ns3__CanUpdateAssetName *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__CanUpdateAssetName))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__CanUpdateAssetName(struct soap *soap, _ns3__CanUpdateAssetName *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__CanUpdateAssetName);
	if (soap_out_PointerTo_ns3__CanUpdateAssetName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__CanUpdateAssetName(struct soap *soap, const char *tag, int id, _ns3__CanUpdateAssetName *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__CanUpdateAssetName);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__CanUpdateAssetName ** SOAP_FMAC4 soap_get_PointerTo_ns3__CanUpdateAssetName(struct soap *soap, _ns3__CanUpdateAssetName **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__CanUpdateAssetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__CanUpdateAssetName ** SOAP_FMAC4 soap_in_PointerTo_ns3__CanUpdateAssetName(struct soap *soap, const char *tag, _ns3__CanUpdateAssetName **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__CanUpdateAssetName **)soap_malloc(soap, sizeof(_ns3__CanUpdateAssetName *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__CanUpdateAssetName *)soap_instantiate__ns3__CanUpdateAssetName(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__CanUpdateAssetName ** p = (_ns3__CanUpdateAssetName **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__CanUpdateAssetName, sizeof(_ns3__CanUpdateAssetName), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__UpdateAssetNameResponse(struct soap *soap, _ns3__UpdateAssetNameResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__UpdateAssetNameResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__UpdateAssetNameResponse(struct soap *soap, _ns3__UpdateAssetNameResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__UpdateAssetNameResponse);
	if (soap_out_PointerTo_ns3__UpdateAssetNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__UpdateAssetNameResponse(struct soap *soap, const char *tag, int id, _ns3__UpdateAssetNameResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__UpdateAssetNameResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__UpdateAssetNameResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__UpdateAssetNameResponse(struct soap *soap, _ns3__UpdateAssetNameResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__UpdateAssetNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__UpdateAssetNameResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__UpdateAssetNameResponse(struct soap *soap, const char *tag, _ns3__UpdateAssetNameResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__UpdateAssetNameResponse **)soap_malloc(soap, sizeof(_ns3__UpdateAssetNameResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__UpdateAssetNameResponse *)soap_instantiate__ns3__UpdateAssetNameResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__UpdateAssetNameResponse ** p = (_ns3__UpdateAssetNameResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__UpdateAssetNameResponse, sizeof(_ns3__UpdateAssetNameResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__UpdateAssetName(struct soap *soap, _ns3__UpdateAssetName *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__UpdateAssetName))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__UpdateAssetName(struct soap *soap, _ns3__UpdateAssetName *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__UpdateAssetName);
	if (soap_out_PointerTo_ns3__UpdateAssetName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__UpdateAssetName(struct soap *soap, const char *tag, int id, _ns3__UpdateAssetName *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__UpdateAssetName);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__UpdateAssetName ** SOAP_FMAC4 soap_get_PointerTo_ns3__UpdateAssetName(struct soap *soap, _ns3__UpdateAssetName **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__UpdateAssetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__UpdateAssetName ** SOAP_FMAC4 soap_in_PointerTo_ns3__UpdateAssetName(struct soap *soap, const char *tag, _ns3__UpdateAssetName **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__UpdateAssetName **)soap_malloc(soap, sizeof(_ns3__UpdateAssetName *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__UpdateAssetName *)soap_instantiate__ns3__UpdateAssetName(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__UpdateAssetName ** p = (_ns3__UpdateAssetName **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__UpdateAssetName, sizeof(_ns3__UpdateAssetName), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__CreateAssetResponse(struct soap *soap, _ns3__CreateAssetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__CreateAssetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__CreateAssetResponse(struct soap *soap, _ns3__CreateAssetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__CreateAssetResponse);
	if (soap_out_PointerTo_ns3__CreateAssetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__CreateAssetResponse(struct soap *soap, const char *tag, int id, _ns3__CreateAssetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__CreateAssetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__CreateAssetResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__CreateAssetResponse(struct soap *soap, _ns3__CreateAssetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__CreateAssetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__CreateAssetResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__CreateAssetResponse(struct soap *soap, const char *tag, _ns3__CreateAssetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__CreateAssetResponse **)soap_malloc(soap, sizeof(_ns3__CreateAssetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__CreateAssetResponse *)soap_instantiate__ns3__CreateAssetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__CreateAssetResponse ** p = (_ns3__CreateAssetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__CreateAssetResponse, sizeof(_ns3__CreateAssetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__CreateAsset(struct soap *soap, _ns3__CreateAsset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__CreateAsset))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__CreateAsset(struct soap *soap, _ns3__CreateAsset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__CreateAsset);
	if (soap_out_PointerTo_ns3__CreateAsset(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__CreateAsset(struct soap *soap, const char *tag, int id, _ns3__CreateAsset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__CreateAsset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__CreateAsset ** SOAP_FMAC4 soap_get_PointerTo_ns3__CreateAsset(struct soap *soap, _ns3__CreateAsset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__CreateAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__CreateAsset ** SOAP_FMAC4 soap_in_PointerTo_ns3__CreateAsset(struct soap *soap, const char *tag, _ns3__CreateAsset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__CreateAsset **)soap_malloc(soap, sizeof(_ns3__CreateAsset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__CreateAsset *)soap_instantiate__ns3__CreateAsset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__CreateAsset ** p = (_ns3__CreateAsset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__CreateAsset, sizeof(_ns3__CreateAsset), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__DeleteAssetResponse(struct soap *soap, _ns3__DeleteAssetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__DeleteAssetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__DeleteAssetResponse(struct soap *soap, _ns3__DeleteAssetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__DeleteAssetResponse);
	if (soap_out_PointerTo_ns3__DeleteAssetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__DeleteAssetResponse(struct soap *soap, const char *tag, int id, _ns3__DeleteAssetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__DeleteAssetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__DeleteAssetResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__DeleteAssetResponse(struct soap *soap, _ns3__DeleteAssetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__DeleteAssetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__DeleteAssetResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__DeleteAssetResponse(struct soap *soap, const char *tag, _ns3__DeleteAssetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__DeleteAssetResponse **)soap_malloc(soap, sizeof(_ns3__DeleteAssetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__DeleteAssetResponse *)soap_instantiate__ns3__DeleteAssetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__DeleteAssetResponse ** p = (_ns3__DeleteAssetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__DeleteAssetResponse, sizeof(_ns3__DeleteAssetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__DeleteAsset(struct soap *soap, _ns3__DeleteAsset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__DeleteAsset))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__DeleteAsset(struct soap *soap, _ns3__DeleteAsset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__DeleteAsset);
	if (soap_out_PointerTo_ns3__DeleteAsset(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__DeleteAsset(struct soap *soap, const char *tag, int id, _ns3__DeleteAsset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__DeleteAsset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__DeleteAsset ** SOAP_FMAC4 soap_get_PointerTo_ns3__DeleteAsset(struct soap *soap, _ns3__DeleteAsset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__DeleteAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__DeleteAsset ** SOAP_FMAC4 soap_in_PointerTo_ns3__DeleteAsset(struct soap *soap, const char *tag, _ns3__DeleteAsset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__DeleteAsset **)soap_malloc(soap, sizeof(_ns3__DeleteAsset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__DeleteAsset *)soap_instantiate__ns3__DeleteAsset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__DeleteAsset ** p = (_ns3__DeleteAsset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__DeleteAsset, sizeof(_ns3__DeleteAsset), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__UnlockAssetResponse(struct soap *soap, _ns3__UnlockAssetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__UnlockAssetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__UnlockAssetResponse(struct soap *soap, _ns3__UnlockAssetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__UnlockAssetResponse);
	if (soap_out_PointerTo_ns3__UnlockAssetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__UnlockAssetResponse(struct soap *soap, const char *tag, int id, _ns3__UnlockAssetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__UnlockAssetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__UnlockAssetResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__UnlockAssetResponse(struct soap *soap, _ns3__UnlockAssetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__UnlockAssetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__UnlockAssetResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__UnlockAssetResponse(struct soap *soap, const char *tag, _ns3__UnlockAssetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__UnlockAssetResponse **)soap_malloc(soap, sizeof(_ns3__UnlockAssetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__UnlockAssetResponse *)soap_instantiate__ns3__UnlockAssetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__UnlockAssetResponse ** p = (_ns3__UnlockAssetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__UnlockAssetResponse, sizeof(_ns3__UnlockAssetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__UnlockAsset(struct soap *soap, _ns3__UnlockAsset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__UnlockAsset))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__UnlockAsset(struct soap *soap, _ns3__UnlockAsset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__UnlockAsset);
	if (soap_out_PointerTo_ns3__UnlockAsset(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__UnlockAsset(struct soap *soap, const char *tag, int id, _ns3__UnlockAsset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__UnlockAsset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__UnlockAsset ** SOAP_FMAC4 soap_get_PointerTo_ns3__UnlockAsset(struct soap *soap, _ns3__UnlockAsset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__UnlockAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__UnlockAsset ** SOAP_FMAC4 soap_in_PointerTo_ns3__UnlockAsset(struct soap *soap, const char *tag, _ns3__UnlockAsset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__UnlockAsset **)soap_malloc(soap, sizeof(_ns3__UnlockAsset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__UnlockAsset *)soap_instantiate__ns3__UnlockAsset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__UnlockAsset ** p = (_ns3__UnlockAsset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__UnlockAsset, sizeof(_ns3__UnlockAsset), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__LockAssetResponse(struct soap *soap, _ns3__LockAssetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__LockAssetResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__LockAssetResponse(struct soap *soap, _ns3__LockAssetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__LockAssetResponse);
	if (soap_out_PointerTo_ns3__LockAssetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__LockAssetResponse(struct soap *soap, const char *tag, int id, _ns3__LockAssetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__LockAssetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__LockAssetResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__LockAssetResponse(struct soap *soap, _ns3__LockAssetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__LockAssetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__LockAssetResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__LockAssetResponse(struct soap *soap, const char *tag, _ns3__LockAssetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__LockAssetResponse **)soap_malloc(soap, sizeof(_ns3__LockAssetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__LockAssetResponse *)soap_instantiate__ns3__LockAssetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__LockAssetResponse ** p = (_ns3__LockAssetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__LockAssetResponse, sizeof(_ns3__LockAssetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__LockAsset(struct soap *soap, _ns3__LockAsset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__LockAsset))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__LockAsset(struct soap *soap, _ns3__LockAsset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__LockAsset);
	if (soap_out_PointerTo_ns3__LockAsset(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__LockAsset(struct soap *soap, const char *tag, int id, _ns3__LockAsset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__LockAsset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__LockAsset ** SOAP_FMAC4 soap_get_PointerTo_ns3__LockAsset(struct soap *soap, _ns3__LockAsset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__LockAsset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__LockAsset ** SOAP_FMAC4 soap_in_PointerTo_ns3__LockAsset(struct soap *soap, const char *tag, _ns3__LockAsset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__LockAsset **)soap_malloc(soap, sizeof(_ns3__LockAsset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__LockAsset *)soap_instantiate__ns3__LockAsset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__LockAsset ** p = (_ns3__LockAsset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__LockAsset, sizeof(_ns3__LockAsset), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetThumbnailResponse(struct soap *soap, _ns3__GetThumbnailResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetThumbnailResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetThumbnailResponse(struct soap *soap, _ns3__GetThumbnailResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetThumbnailResponse);
	if (soap_out_PointerTo_ns3__GetThumbnailResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetThumbnailResponse(struct soap *soap, const char *tag, int id, _ns3__GetThumbnailResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetThumbnailResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetThumbnailResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetThumbnailResponse(struct soap *soap, _ns3__GetThumbnailResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetThumbnailResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetThumbnailResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetThumbnailResponse(struct soap *soap, const char *tag, _ns3__GetThumbnailResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetThumbnailResponse **)soap_malloc(soap, sizeof(_ns3__GetThumbnailResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetThumbnailResponse *)soap_instantiate__ns3__GetThumbnailResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetThumbnailResponse ** p = (_ns3__GetThumbnailResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetThumbnailResponse, sizeof(_ns3__GetThumbnailResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetThumbnail(struct soap *soap, _ns3__GetThumbnail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetThumbnail))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetThumbnail(struct soap *soap, _ns3__GetThumbnail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetThumbnail);
	if (soap_out_PointerTo_ns3__GetThumbnail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetThumbnail(struct soap *soap, const char *tag, int id, _ns3__GetThumbnail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetThumbnail);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetThumbnail ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetThumbnail(struct soap *soap, _ns3__GetThumbnail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetThumbnail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetThumbnail ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetThumbnail(struct soap *soap, const char *tag, _ns3__GetThumbnail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetThumbnail **)soap_malloc(soap, sizeof(_ns3__GetThumbnail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetThumbnail *)soap_instantiate__ns3__GetThumbnail(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetThumbnail ** p = (_ns3__GetThumbnail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetThumbnail, sizeof(_ns3__GetThumbnail), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetUserResponse(struct soap *soap, _ns3__GetUserResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetUserResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetUserResponse(struct soap *soap, _ns3__GetUserResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetUserResponse);
	if (soap_out_PointerTo_ns3__GetUserResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetUserResponse(struct soap *soap, const char *tag, int id, _ns3__GetUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetUserResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetUserResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetUserResponse(struct soap *soap, _ns3__GetUserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetUserResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetUserResponse(struct soap *soap, const char *tag, _ns3__GetUserResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetUserResponse **)soap_malloc(soap, sizeof(_ns3__GetUserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetUserResponse *)soap_instantiate__ns3__GetUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetUserResponse ** p = (_ns3__GetUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetUserResponse, sizeof(_ns3__GetUserResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetUser(struct soap *soap, _ns3__GetUser *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetUser))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetUser(struct soap *soap, _ns3__GetUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetUser);
	if (soap_out_PointerTo_ns3__GetUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetUser(struct soap *soap, const char *tag, int id, _ns3__GetUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetUser ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetUser(struct soap *soap, _ns3__GetUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetUser ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetUser(struct soap *soap, const char *tag, _ns3__GetUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetUser **)soap_malloc(soap, sizeof(_ns3__GetUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetUser *)soap_instantiate__ns3__GetUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetUser ** p = (_ns3__GetUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetUser, sizeof(_ns3__GetUser), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__LogoffResponse(struct soap *soap, _ns3__LogoffResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__LogoffResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__LogoffResponse(struct soap *soap, _ns3__LogoffResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__LogoffResponse);
	if (soap_out_PointerTo_ns3__LogoffResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__LogoffResponse(struct soap *soap, const char *tag, int id, _ns3__LogoffResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__LogoffResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__LogoffResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__LogoffResponse(struct soap *soap, _ns3__LogoffResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__LogoffResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__LogoffResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__LogoffResponse(struct soap *soap, const char *tag, _ns3__LogoffResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__LogoffResponse **)soap_malloc(soap, sizeof(_ns3__LogoffResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__LogoffResponse *)soap_instantiate__ns3__LogoffResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__LogoffResponse ** p = (_ns3__LogoffResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__LogoffResponse, sizeof(_ns3__LogoffResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__Logoff(struct soap *soap, _ns3__Logoff *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__Logoff))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__Logoff(struct soap *soap, _ns3__Logoff *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__Logoff);
	if (soap_out_PointerTo_ns3__Logoff(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__Logoff(struct soap *soap, const char *tag, int id, _ns3__Logoff *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__Logoff);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__Logoff ** SOAP_FMAC4 soap_get_PointerTo_ns3__Logoff(struct soap *soap, _ns3__Logoff **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__Logoff(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__Logoff ** SOAP_FMAC4 soap_in_PointerTo_ns3__Logoff(struct soap *soap, const char *tag, _ns3__Logoff **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__Logoff **)soap_malloc(soap, sizeof(_ns3__Logoff *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__Logoff *)soap_instantiate__ns3__Logoff(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__Logoff ** p = (_ns3__Logoff **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__Logoff, sizeof(_ns3__Logoff), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetShelveListResponse(struct soap *soap, _ns3__GetShelveListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetShelveListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetShelveListResponse(struct soap *soap, _ns3__GetShelveListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetShelveListResponse);
	if (soap_out_PointerTo_ns3__GetShelveListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetShelveListResponse(struct soap *soap, const char *tag, int id, _ns3__GetShelveListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetShelveListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetShelveListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetShelveListResponse(struct soap *soap, _ns3__GetShelveListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetShelveListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetShelveListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetShelveListResponse(struct soap *soap, const char *tag, _ns3__GetShelveListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetShelveListResponse **)soap_malloc(soap, sizeof(_ns3__GetShelveListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetShelveListResponse *)soap_instantiate__ns3__GetShelveListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetShelveListResponse ** p = (_ns3__GetShelveListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetShelveListResponse, sizeof(_ns3__GetShelveListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetShelveList(struct soap *soap, _ns3__GetShelveList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetShelveList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetShelveList(struct soap *soap, _ns3__GetShelveList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetShelveList);
	if (soap_out_PointerTo_ns3__GetShelveList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetShelveList(struct soap *soap, const char *tag, int id, _ns3__GetShelveList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetShelveList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetShelveList ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetShelveList(struct soap *soap, _ns3__GetShelveList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetShelveList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetShelveList ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetShelveList(struct soap *soap, const char *tag, _ns3__GetShelveList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetShelveList **)soap_malloc(soap, sizeof(_ns3__GetShelveList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetShelveList *)soap_instantiate__ns3__GetShelveList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetShelveList ** p = (_ns3__GetShelveList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetShelveList, sizeof(_ns3__GetShelveList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetTagsResponse(struct soap *soap, _ns3__GetTagsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetTagsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetTagsResponse(struct soap *soap, _ns3__GetTagsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetTagsResponse);
	if (soap_out_PointerTo_ns3__GetTagsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetTagsResponse(struct soap *soap, const char *tag, int id, _ns3__GetTagsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetTagsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetTagsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetTagsResponse(struct soap *soap, _ns3__GetTagsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetTagsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetTagsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetTagsResponse(struct soap *soap, const char *tag, _ns3__GetTagsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetTagsResponse **)soap_malloc(soap, sizeof(_ns3__GetTagsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetTagsResponse *)soap_instantiate__ns3__GetTagsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetTagsResponse ** p = (_ns3__GetTagsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetTagsResponse, sizeof(_ns3__GetTagsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetTags(struct soap *soap, _ns3__GetTags *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetTags))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetTags(struct soap *soap, _ns3__GetTags *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetTags);
	if (soap_out_PointerTo_ns3__GetTags(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetTags(struct soap *soap, const char *tag, int id, _ns3__GetTags *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetTags);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetTags ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetTags(struct soap *soap, _ns3__GetTags **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetTags(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetTags ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetTags(struct soap *soap, const char *tag, _ns3__GetTags **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetTags **)soap_malloc(soap, sizeof(_ns3__GetTags *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetTags *)soap_instantiate__ns3__GetTags(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetTags ** p = (_ns3__GetTags **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetTags, sizeof(_ns3__GetTags), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetCommentListResponse(struct soap *soap, _ns3__GetCommentListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetCommentListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetCommentListResponse(struct soap *soap, _ns3__GetCommentListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetCommentListResponse);
	if (soap_out_PointerTo_ns3__GetCommentListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetCommentListResponse(struct soap *soap, const char *tag, int id, _ns3__GetCommentListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetCommentListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetCommentListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetCommentListResponse(struct soap *soap, _ns3__GetCommentListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetCommentListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetCommentListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetCommentListResponse(struct soap *soap, const char *tag, _ns3__GetCommentListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetCommentListResponse **)soap_malloc(soap, sizeof(_ns3__GetCommentListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetCommentListResponse *)soap_instantiate__ns3__GetCommentListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetCommentListResponse ** p = (_ns3__GetCommentListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetCommentListResponse, sizeof(_ns3__GetCommentListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetCommentList(struct soap *soap, _ns3__GetCommentList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetCommentList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetCommentList(struct soap *soap, _ns3__GetCommentList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetCommentList);
	if (soap_out_PointerTo_ns3__GetCommentList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetCommentList(struct soap *soap, const char *tag, int id, _ns3__GetCommentList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetCommentList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetCommentList ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetCommentList(struct soap *soap, _ns3__GetCommentList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetCommentList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetCommentList ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetCommentList(struct soap *soap, const char *tag, _ns3__GetCommentList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetCommentList **)soap_malloc(soap, sizeof(_ns3__GetCommentList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetCommentList *)soap_instantiate__ns3__GetCommentList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetCommentList ** p = (_ns3__GetCommentList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetCommentList, sizeof(_ns3__GetCommentList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRoleResponse(struct soap *soap, _ns3__GetRoleResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetRoleResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRoleResponse(struct soap *soap, _ns3__GetRoleResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetRoleResponse);
	if (soap_out_PointerTo_ns3__GetRoleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRoleResponse(struct soap *soap, const char *tag, int id, _ns3__GetRoleResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetRoleResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRoleResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRoleResponse(struct soap *soap, _ns3__GetRoleResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRoleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetRoleResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRoleResponse(struct soap *soap, const char *tag, _ns3__GetRoleResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRoleResponse **)soap_malloc(soap, sizeof(_ns3__GetRoleResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRoleResponse *)soap_instantiate__ns3__GetRoleResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRoleResponse ** p = (_ns3__GetRoleResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetRoleResponse, sizeof(_ns3__GetRoleResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetRole(struct soap *soap, _ns3__GetRole *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetRole))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetRole(struct soap *soap, _ns3__GetRole *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetRole);
	if (soap_out_PointerTo_ns3__GetRole(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetRole(struct soap *soap, const char *tag, int id, _ns3__GetRole *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetRole);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetRole ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetRole(struct soap *soap, _ns3__GetRole **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetRole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetRole ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetRole(struct soap *soap, const char *tag, _ns3__GetRole **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetRole **)soap_malloc(soap, sizeof(_ns3__GetRole *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetRole *)soap_instantiate__ns3__GetRole(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetRole ** p = (_ns3__GetRole **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetRole, sizeof(_ns3__GetRole), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetTitleListResponse(struct soap *soap, _ns3__GetTitleListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetTitleListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetTitleListResponse(struct soap *soap, _ns3__GetTitleListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetTitleListResponse);
	if (soap_out_PointerTo_ns3__GetTitleListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetTitleListResponse(struct soap *soap, const char *tag, int id, _ns3__GetTitleListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetTitleListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetTitleListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetTitleListResponse(struct soap *soap, _ns3__GetTitleListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetTitleListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetTitleListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetTitleListResponse(struct soap *soap, const char *tag, _ns3__GetTitleListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetTitleListResponse **)soap_malloc(soap, sizeof(_ns3__GetTitleListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetTitleListResponse *)soap_instantiate__ns3__GetTitleListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetTitleListResponse ** p = (_ns3__GetTitleListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetTitleListResponse, sizeof(_ns3__GetTitleListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetTitleList(struct soap *soap, _ns3__GetTitleList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetTitleList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetTitleList(struct soap *soap, _ns3__GetTitleList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetTitleList);
	if (soap_out_PointerTo_ns3__GetTitleList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetTitleList(struct soap *soap, const char *tag, int id, _ns3__GetTitleList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetTitleList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetTitleList ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetTitleList(struct soap *soap, _ns3__GetTitleList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetTitleList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetTitleList ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetTitleList(struct soap *soap, const char *tag, _ns3__GetTitleList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetTitleList **)soap_malloc(soap, sizeof(_ns3__GetTitleList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetTitleList *)soap_instantiate__ns3__GetTitleList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetTitleList ** p = (_ns3__GetTitleList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetTitleList, sizeof(_ns3__GetTitleList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__LoginResponse(struct soap *soap, _ns3__LoginResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__LoginResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__LoginResponse(struct soap *soap, _ns3__LoginResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__LoginResponse);
	if (soap_out_PointerTo_ns3__LoginResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__LoginResponse(struct soap *soap, const char *tag, int id, _ns3__LoginResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__LoginResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__LoginResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__LoginResponse(struct soap *soap, _ns3__LoginResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__LoginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__LoginResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__LoginResponse(struct soap *soap, const char *tag, _ns3__LoginResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__LoginResponse **)soap_malloc(soap, sizeof(_ns3__LoginResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__LoginResponse *)soap_instantiate__ns3__LoginResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__LoginResponse ** p = (_ns3__LoginResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__LoginResponse, sizeof(_ns3__LoginResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__Login(struct soap *soap, _ns3__Login *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__Login))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__Login(struct soap *soap, _ns3__Login *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__Login);
	if (soap_out_PointerTo_ns3__Login(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__Login(struct soap *soap, const char *tag, int id, _ns3__Login *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__Login);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__Login ** SOAP_FMAC4 soap_get_PointerTo_ns3__Login(struct soap *soap, _ns3__Login **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__Login ** SOAP_FMAC4 soap_in_PointerTo_ns3__Login(struct soap *soap, const char *tag, _ns3__Login **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__Login **)soap_malloc(soap, sizeof(_ns3__Login *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__Login *)soap_instantiate__ns3__Login(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__Login ** p = (_ns3__Login **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__Login, sizeof(_ns3__Login), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__DeleteTaskResponse(struct soap *soap, _ns3__DeleteTaskResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__DeleteTaskResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__DeleteTaskResponse(struct soap *soap, _ns3__DeleteTaskResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__DeleteTaskResponse);
	if (soap_out_PointerTo_ns3__DeleteTaskResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__DeleteTaskResponse(struct soap *soap, const char *tag, int id, _ns3__DeleteTaskResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__DeleteTaskResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__DeleteTaskResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__DeleteTaskResponse(struct soap *soap, _ns3__DeleteTaskResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__DeleteTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__DeleteTaskResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__DeleteTaskResponse(struct soap *soap, const char *tag, _ns3__DeleteTaskResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__DeleteTaskResponse **)soap_malloc(soap, sizeof(_ns3__DeleteTaskResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__DeleteTaskResponse *)soap_instantiate__ns3__DeleteTaskResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__DeleteTaskResponse ** p = (_ns3__DeleteTaskResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__DeleteTaskResponse, sizeof(_ns3__DeleteTaskResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__DeleteTask(struct soap *soap, _ns3__DeleteTask *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__DeleteTask))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__DeleteTask(struct soap *soap, _ns3__DeleteTask *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__DeleteTask);
	if (soap_out_PointerTo_ns3__DeleteTask(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__DeleteTask(struct soap *soap, const char *tag, int id, _ns3__DeleteTask *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__DeleteTask);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__DeleteTask ** SOAP_FMAC4 soap_get_PointerTo_ns3__DeleteTask(struct soap *soap, _ns3__DeleteTask **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__DeleteTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__DeleteTask ** SOAP_FMAC4 soap_in_PointerTo_ns3__DeleteTask(struct soap *soap, const char *tag, _ns3__DeleteTask **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__DeleteTask **)soap_malloc(soap, sizeof(_ns3__DeleteTask *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__DeleteTask *)soap_instantiate__ns3__DeleteTask(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__DeleteTask ** p = (_ns3__DeleteTask **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__DeleteTask, sizeof(_ns3__DeleteTask), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetTaskHistoryResponse(struct soap *soap, _ns3__GetTaskHistoryResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetTaskHistoryResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetTaskHistoryResponse(struct soap *soap, _ns3__GetTaskHistoryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetTaskHistoryResponse);
	if (soap_out_PointerTo_ns3__GetTaskHistoryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetTaskHistoryResponse(struct soap *soap, const char *tag, int id, _ns3__GetTaskHistoryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetTaskHistoryResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetTaskHistoryResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetTaskHistoryResponse(struct soap *soap, _ns3__GetTaskHistoryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetTaskHistoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetTaskHistoryResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetTaskHistoryResponse(struct soap *soap, const char *tag, _ns3__GetTaskHistoryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetTaskHistoryResponse **)soap_malloc(soap, sizeof(_ns3__GetTaskHistoryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetTaskHistoryResponse *)soap_instantiate__ns3__GetTaskHistoryResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetTaskHistoryResponse ** p = (_ns3__GetTaskHistoryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetTaskHistoryResponse, sizeof(_ns3__GetTaskHistoryResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetTaskHistory(struct soap *soap, _ns3__GetTaskHistory *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetTaskHistory))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetTaskHistory(struct soap *soap, _ns3__GetTaskHistory *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetTaskHistory);
	if (soap_out_PointerTo_ns3__GetTaskHistory(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetTaskHistory(struct soap *soap, const char *tag, int id, _ns3__GetTaskHistory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetTaskHistory);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetTaskHistory ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetTaskHistory(struct soap *soap, _ns3__GetTaskHistory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetTaskHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetTaskHistory ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetTaskHistory(struct soap *soap, const char *tag, _ns3__GetTaskHistory **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetTaskHistory **)soap_malloc(soap, sizeof(_ns3__GetTaskHistory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetTaskHistory *)soap_instantiate__ns3__GetTaskHistory(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetTaskHistory ** p = (_ns3__GetTaskHistory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetTaskHistory, sizeof(_ns3__GetTaskHistory), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__UpdateTaskResponse(struct soap *soap, _ns3__UpdateTaskResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__UpdateTaskResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__UpdateTaskResponse(struct soap *soap, _ns3__UpdateTaskResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__UpdateTaskResponse);
	if (soap_out_PointerTo_ns3__UpdateTaskResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__UpdateTaskResponse(struct soap *soap, const char *tag, int id, _ns3__UpdateTaskResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__UpdateTaskResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__UpdateTaskResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__UpdateTaskResponse(struct soap *soap, _ns3__UpdateTaskResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__UpdateTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__UpdateTaskResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__UpdateTaskResponse(struct soap *soap, const char *tag, _ns3__UpdateTaskResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__UpdateTaskResponse **)soap_malloc(soap, sizeof(_ns3__UpdateTaskResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__UpdateTaskResponse *)soap_instantiate__ns3__UpdateTaskResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__UpdateTaskResponse ** p = (_ns3__UpdateTaskResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__UpdateTaskResponse, sizeof(_ns3__UpdateTaskResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__UpdateTask(struct soap *soap, _ns3__UpdateTask *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__UpdateTask))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__UpdateTask(struct soap *soap, _ns3__UpdateTask *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__UpdateTask);
	if (soap_out_PointerTo_ns3__UpdateTask(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__UpdateTask(struct soap *soap, const char *tag, int id, _ns3__UpdateTask *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__UpdateTask);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__UpdateTask ** SOAP_FMAC4 soap_get_PointerTo_ns3__UpdateTask(struct soap *soap, _ns3__UpdateTask **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__UpdateTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__UpdateTask ** SOAP_FMAC4 soap_in_PointerTo_ns3__UpdateTask(struct soap *soap, const char *tag, _ns3__UpdateTask **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__UpdateTask **)soap_malloc(soap, sizeof(_ns3__UpdateTask *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__UpdateTask *)soap_instantiate__ns3__UpdateTask(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__UpdateTask ** p = (_ns3__UpdateTask **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__UpdateTask, sizeof(_ns3__UpdateTask), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetTaskCategoryListResponse(struct soap *soap, _ns3__GetTaskCategoryListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetTaskCategoryListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetTaskCategoryListResponse(struct soap *soap, _ns3__GetTaskCategoryListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetTaskCategoryListResponse);
	if (soap_out_PointerTo_ns3__GetTaskCategoryListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetTaskCategoryListResponse(struct soap *soap, const char *tag, int id, _ns3__GetTaskCategoryListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetTaskCategoryListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetTaskCategoryListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetTaskCategoryListResponse(struct soap *soap, _ns3__GetTaskCategoryListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetTaskCategoryListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetTaskCategoryListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetTaskCategoryListResponse(struct soap *soap, const char *tag, _ns3__GetTaskCategoryListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetTaskCategoryListResponse **)soap_malloc(soap, sizeof(_ns3__GetTaskCategoryListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetTaskCategoryListResponse *)soap_instantiate__ns3__GetTaskCategoryListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetTaskCategoryListResponse ** p = (_ns3__GetTaskCategoryListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetTaskCategoryListResponse, sizeof(_ns3__GetTaskCategoryListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetTaskCategoryList(struct soap *soap, _ns3__GetTaskCategoryList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetTaskCategoryList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetTaskCategoryList(struct soap *soap, _ns3__GetTaskCategoryList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetTaskCategoryList);
	if (soap_out_PointerTo_ns3__GetTaskCategoryList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetTaskCategoryList(struct soap *soap, const char *tag, int id, _ns3__GetTaskCategoryList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetTaskCategoryList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetTaskCategoryList ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetTaskCategoryList(struct soap *soap, _ns3__GetTaskCategoryList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetTaskCategoryList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetTaskCategoryList ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetTaskCategoryList(struct soap *soap, const char *tag, _ns3__GetTaskCategoryList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetTaskCategoryList **)soap_malloc(soap, sizeof(_ns3__GetTaskCategoryList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetTaskCategoryList *)soap_instantiate__ns3__GetTaskCategoryList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetTaskCategoryList ** p = (_ns3__GetTaskCategoryList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetTaskCategoryList, sizeof(_ns3__GetTaskCategoryList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__CreateTaskResponse(struct soap *soap, _ns3__CreateTaskResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__CreateTaskResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__CreateTaskResponse(struct soap *soap, _ns3__CreateTaskResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__CreateTaskResponse);
	if (soap_out_PointerTo_ns3__CreateTaskResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__CreateTaskResponse(struct soap *soap, const char *tag, int id, _ns3__CreateTaskResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__CreateTaskResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__CreateTaskResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__CreateTaskResponse(struct soap *soap, _ns3__CreateTaskResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__CreateTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__CreateTaskResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__CreateTaskResponse(struct soap *soap, const char *tag, _ns3__CreateTaskResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__CreateTaskResponse **)soap_malloc(soap, sizeof(_ns3__CreateTaskResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__CreateTaskResponse *)soap_instantiate__ns3__CreateTaskResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__CreateTaskResponse ** p = (_ns3__CreateTaskResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__CreateTaskResponse, sizeof(_ns3__CreateTaskResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__CreateTask(struct soap *soap, _ns3__CreateTask *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__CreateTask))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__CreateTask(struct soap *soap, _ns3__CreateTask *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__CreateTask);
	if (soap_out_PointerTo_ns3__CreateTask(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__CreateTask(struct soap *soap, const char *tag, int id, _ns3__CreateTask *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__CreateTask);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__CreateTask ** SOAP_FMAC4 soap_get_PointerTo_ns3__CreateTask(struct soap *soap, _ns3__CreateTask **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__CreateTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__CreateTask ** SOAP_FMAC4 soap_in_PointerTo_ns3__CreateTask(struct soap *soap, const char *tag, _ns3__CreateTask **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__CreateTask **)soap_malloc(soap, sizeof(_ns3__CreateTask *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__CreateTask *)soap_instantiate__ns3__CreateTask(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__CreateTask ** p = (_ns3__CreateTask **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__CreateTask, sizeof(_ns3__CreateTask), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetTaskStatusListResponse(struct soap *soap, _ns3__GetTaskStatusListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetTaskStatusListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetTaskStatusListResponse(struct soap *soap, _ns3__GetTaskStatusListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetTaskStatusListResponse);
	if (soap_out_PointerTo_ns3__GetTaskStatusListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetTaskStatusListResponse(struct soap *soap, const char *tag, int id, _ns3__GetTaskStatusListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetTaskStatusListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetTaskStatusListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetTaskStatusListResponse(struct soap *soap, _ns3__GetTaskStatusListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetTaskStatusListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetTaskStatusListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetTaskStatusListResponse(struct soap *soap, const char *tag, _ns3__GetTaskStatusListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetTaskStatusListResponse **)soap_malloc(soap, sizeof(_ns3__GetTaskStatusListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetTaskStatusListResponse *)soap_instantiate__ns3__GetTaskStatusListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetTaskStatusListResponse ** p = (_ns3__GetTaskStatusListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetTaskStatusListResponse, sizeof(_ns3__GetTaskStatusListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetTaskStatusList(struct soap *soap, _ns3__GetTaskStatusList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetTaskStatusList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetTaskStatusList(struct soap *soap, _ns3__GetTaskStatusList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetTaskStatusList);
	if (soap_out_PointerTo_ns3__GetTaskStatusList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetTaskStatusList(struct soap *soap, const char *tag, int id, _ns3__GetTaskStatusList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetTaskStatusList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetTaskStatusList ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetTaskStatusList(struct soap *soap, _ns3__GetTaskStatusList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetTaskStatusList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetTaskStatusList ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetTaskStatusList(struct soap *soap, const char *tag, _ns3__GetTaskStatusList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetTaskStatusList **)soap_malloc(soap, sizeof(_ns3__GetTaskStatusList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetTaskStatusList *)soap_instantiate__ns3__GetTaskStatusList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetTaskStatusList ** p = (_ns3__GetTaskStatusList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetTaskStatusList, sizeof(_ns3__GetTaskStatusList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetUsersForTitleResponse(struct soap *soap, _ns3__GetUsersForTitleResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetUsersForTitleResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetUsersForTitleResponse(struct soap *soap, _ns3__GetUsersForTitleResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetUsersForTitleResponse);
	if (soap_out_PointerTo_ns3__GetUsersForTitleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetUsersForTitleResponse(struct soap *soap, const char *tag, int id, _ns3__GetUsersForTitleResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetUsersForTitleResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetUsersForTitleResponse ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetUsersForTitleResponse(struct soap *soap, _ns3__GetUsersForTitleResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetUsersForTitleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetUsersForTitleResponse ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetUsersForTitleResponse(struct soap *soap, const char *tag, _ns3__GetUsersForTitleResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetUsersForTitleResponse **)soap_malloc(soap, sizeof(_ns3__GetUsersForTitleResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetUsersForTitleResponse *)soap_instantiate__ns3__GetUsersForTitleResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetUsersForTitleResponse ** p = (_ns3__GetUsersForTitleResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetUsersForTitleResponse, sizeof(_ns3__GetUsersForTitleResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns3__GetUsersForTitle(struct soap *soap, _ns3__GetUsersForTitle *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns3__GetUsersForTitle))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns3__GetUsersForTitle(struct soap *soap, _ns3__GetUsersForTitle *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns3__GetUsersForTitle);
	if (soap_out_PointerTo_ns3__GetUsersForTitle(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns3__GetUsersForTitle(struct soap *soap, const char *tag, int id, _ns3__GetUsersForTitle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns3__GetUsersForTitle);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns3__GetUsersForTitle ** SOAP_FMAC4 soap_get_PointerTo_ns3__GetUsersForTitle(struct soap *soap, _ns3__GetUsersForTitle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns3__GetUsersForTitle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns3__GetUsersForTitle ** SOAP_FMAC4 soap_in_PointerTo_ns3__GetUsersForTitle(struct soap *soap, const char *tag, _ns3__GetUsersForTitle **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns3__GetUsersForTitle **)soap_malloc(soap, sizeof(_ns3__GetUsersForTitle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns3__GetUsersForTitle *)soap_instantiate__ns3__GetUsersForTitle(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns3__GetUsersForTitle ** p = (_ns3__GetUsersForTitle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns3__GetUsersForTitle, sizeof(_ns3__GetUsersForTitle), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfLockDTO(struct soap *soap, ns3__ArrayOfLockDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ArrayOfLockDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfLockDTO(struct soap *soap, ns3__ArrayOfLockDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__ArrayOfLockDTO);
	if (soap_out_PointerTons3__ArrayOfLockDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfLockDTO(struct soap *soap, const char *tag, int id, ns3__ArrayOfLockDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ArrayOfLockDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ArrayOfLockDTO ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfLockDTO(struct soap *soap, ns3__ArrayOfLockDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfLockDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__ArrayOfLockDTO ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfLockDTO(struct soap *soap, const char *tag, ns3__ArrayOfLockDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfLockDTO **)soap_malloc(soap, sizeof(ns3__ArrayOfLockDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfLockDTO *)soap_instantiate_ns3__ArrayOfLockDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__ArrayOfLockDTO ** p = (ns3__ArrayOfLockDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ArrayOfLockDTO, sizeof(ns3__ArrayOfLockDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfTitleStatusDTO(struct soap *soap, ns3__ArrayOfTitleStatusDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ArrayOfTitleStatusDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfTitleStatusDTO(struct soap *soap, ns3__ArrayOfTitleStatusDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__ArrayOfTitleStatusDTO);
	if (soap_out_PointerTons3__ArrayOfTitleStatusDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfTitleStatusDTO(struct soap *soap, const char *tag, int id, ns3__ArrayOfTitleStatusDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ArrayOfTitleStatusDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ArrayOfTitleStatusDTO ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfTitleStatusDTO(struct soap *soap, ns3__ArrayOfTitleStatusDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfTitleStatusDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__ArrayOfTitleStatusDTO ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfTitleStatusDTO(struct soap *soap, const char *tag, ns3__ArrayOfTitleStatusDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfTitleStatusDTO **)soap_malloc(soap, sizeof(ns3__ArrayOfTitleStatusDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfTitleStatusDTO *)soap_instantiate_ns3__ArrayOfTitleStatusDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__ArrayOfTitleStatusDTO ** p = (ns3__ArrayOfTitleStatusDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ArrayOfTitleStatusDTO, sizeof(ns3__ArrayOfTitleStatusDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfEditionTitlesDTO(struct soap *soap, ns3__ArrayOfEditionTitlesDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ArrayOfEditionTitlesDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfEditionTitlesDTO(struct soap *soap, ns3__ArrayOfEditionTitlesDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__ArrayOfEditionTitlesDTO);
	if (soap_out_PointerTons3__ArrayOfEditionTitlesDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfEditionTitlesDTO(struct soap *soap, const char *tag, int id, ns3__ArrayOfEditionTitlesDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ArrayOfEditionTitlesDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ArrayOfEditionTitlesDTO ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfEditionTitlesDTO(struct soap *soap, ns3__ArrayOfEditionTitlesDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfEditionTitlesDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__ArrayOfEditionTitlesDTO ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfEditionTitlesDTO(struct soap *soap, const char *tag, ns3__ArrayOfEditionTitlesDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfEditionTitlesDTO **)soap_malloc(soap, sizeof(ns3__ArrayOfEditionTitlesDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfEditionTitlesDTO *)soap_instantiate_ns3__ArrayOfEditionTitlesDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__ArrayOfEditionTitlesDTO ** p = (ns3__ArrayOfEditionTitlesDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ArrayOfEditionTitlesDTO, sizeof(ns3__ArrayOfEditionTitlesDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfTaskDTO(struct soap *soap, ns3__ArrayOfTaskDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ArrayOfTaskDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfTaskDTO(struct soap *soap, ns3__ArrayOfTaskDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__ArrayOfTaskDTO);
	if (soap_out_PointerTons3__ArrayOfTaskDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfTaskDTO(struct soap *soap, const char *tag, int id, ns3__ArrayOfTaskDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ArrayOfTaskDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ArrayOfTaskDTO ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfTaskDTO(struct soap *soap, ns3__ArrayOfTaskDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfTaskDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__ArrayOfTaskDTO ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfTaskDTO(struct soap *soap, const char *tag, ns3__ArrayOfTaskDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfTaskDTO **)soap_malloc(soap, sizeof(ns3__ArrayOfTaskDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfTaskDTO *)soap_instantiate_ns3__ArrayOfTaskDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__ArrayOfTaskDTO ** p = (ns3__ArrayOfTaskDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ArrayOfTaskDTO, sizeof(ns3__ArrayOfTaskDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__VersionDTO(struct soap *soap, ns3__VersionDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__VersionDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__VersionDTO(struct soap *soap, ns3__VersionDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__VersionDTO);
	if (soap_out_PointerTons3__VersionDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__VersionDTO(struct soap *soap, const char *tag, int id, ns3__VersionDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__VersionDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__VersionDTO ** SOAP_FMAC4 soap_get_PointerTons3__VersionDTO(struct soap *soap, ns3__VersionDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__VersionDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__VersionDTO ** SOAP_FMAC4 soap_in_PointerTons3__VersionDTO(struct soap *soap, const char *tag, ns3__VersionDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__VersionDTO **)soap_malloc(soap, sizeof(ns3__VersionDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__VersionDTO *)soap_instantiate_ns3__VersionDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__VersionDTO ** p = (ns3__VersionDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__VersionDTO, sizeof(ns3__VersionDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfAssetDTO(struct soap *soap, ns3__ArrayOfAssetDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ArrayOfAssetDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfAssetDTO(struct soap *soap, ns3__ArrayOfAssetDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__ArrayOfAssetDTO);
	if (soap_out_PointerTons3__ArrayOfAssetDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfAssetDTO(struct soap *soap, const char *tag, int id, ns3__ArrayOfAssetDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ArrayOfAssetDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ArrayOfAssetDTO ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfAssetDTO(struct soap *soap, ns3__ArrayOfAssetDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfAssetDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__ArrayOfAssetDTO ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfAssetDTO(struct soap *soap, const char *tag, ns3__ArrayOfAssetDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfAssetDTO **)soap_malloc(soap, sizeof(ns3__ArrayOfAssetDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfAssetDTO *)soap_instantiate_ns3__ArrayOfAssetDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__ArrayOfAssetDTO ** p = (ns3__ArrayOfAssetDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ArrayOfAssetDTO, sizeof(ns3__ArrayOfAssetDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfGuid(struct soap *soap, ns3__ArrayOfGuid *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ArrayOfGuid))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfGuid(struct soap *soap, ns3__ArrayOfGuid *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__ArrayOfGuid);
	if (soap_out_PointerTons3__ArrayOfGuid(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfGuid(struct soap *soap, const char *tag, int id, ns3__ArrayOfGuid *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ArrayOfGuid);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ArrayOfGuid ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfGuid(struct soap *soap, ns3__ArrayOfGuid **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfGuid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__ArrayOfGuid ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfGuid(struct soap *soap, const char *tag, ns3__ArrayOfGuid **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfGuid **)soap_malloc(soap, sizeof(ns3__ArrayOfGuid *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfGuid *)soap_instantiate_ns3__ArrayOfGuid(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__ArrayOfGuid ** p = (ns3__ArrayOfGuid **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ArrayOfGuid, sizeof(ns3__ArrayOfGuid), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfString(struct soap *soap, ns3__ArrayOfString *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ArrayOfString))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfString(struct soap *soap, ns3__ArrayOfString *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__ArrayOfString);
	if (soap_out_PointerTons3__ArrayOfString(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfString(struct soap *soap, const char *tag, int id, ns3__ArrayOfString *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ArrayOfString);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ArrayOfString ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfString(struct soap *soap, ns3__ArrayOfString **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__ArrayOfString ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfString(struct soap *soap, const char *tag, ns3__ArrayOfString **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfString **)soap_malloc(soap, sizeof(ns3__ArrayOfString *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfString *)soap_instantiate_ns3__ArrayOfString(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__ArrayOfString ** p = (ns3__ArrayOfString **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ArrayOfString, sizeof(ns3__ArrayOfString), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfCommentDTO(struct soap *soap, ns3__ArrayOfCommentDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ArrayOfCommentDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfCommentDTO(struct soap *soap, ns3__ArrayOfCommentDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__ArrayOfCommentDTO);
	if (soap_out_PointerTons3__ArrayOfCommentDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfCommentDTO(struct soap *soap, const char *tag, int id, ns3__ArrayOfCommentDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ArrayOfCommentDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ArrayOfCommentDTO ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfCommentDTO(struct soap *soap, ns3__ArrayOfCommentDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfCommentDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__ArrayOfCommentDTO ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfCommentDTO(struct soap *soap, const char *tag, ns3__ArrayOfCommentDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfCommentDTO **)soap_malloc(soap, sizeof(ns3__ArrayOfCommentDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfCommentDTO *)soap_instantiate_ns3__ArrayOfCommentDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__ArrayOfCommentDTO ** p = (ns3__ArrayOfCommentDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ArrayOfCommentDTO, sizeof(ns3__ArrayOfCommentDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfTitleDTO(struct soap *soap, ns3__ArrayOfTitleDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ArrayOfTitleDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfTitleDTO(struct soap *soap, ns3__ArrayOfTitleDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__ArrayOfTitleDTO);
	if (soap_out_PointerTons3__ArrayOfTitleDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfTitleDTO(struct soap *soap, const char *tag, int id, ns3__ArrayOfTitleDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ArrayOfTitleDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ArrayOfTitleDTO ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfTitleDTO(struct soap *soap, ns3__ArrayOfTitleDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfTitleDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__ArrayOfTitleDTO ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfTitleDTO(struct soap *soap, const char *tag, ns3__ArrayOfTitleDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfTitleDTO **)soap_malloc(soap, sizeof(ns3__ArrayOfTitleDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfTitleDTO *)soap_instantiate_ns3__ArrayOfTitleDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__ArrayOfTitleDTO ** p = (ns3__ArrayOfTitleDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ArrayOfTitleDTO, sizeof(ns3__ArrayOfTitleDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfIdNameDTO(struct soap *soap, ns3__ArrayOfIdNameDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ArrayOfIdNameDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfIdNameDTO(struct soap *soap, ns3__ArrayOfIdNameDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__ArrayOfIdNameDTO);
	if (soap_out_PointerTons3__ArrayOfIdNameDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfIdNameDTO(struct soap *soap, const char *tag, int id, ns3__ArrayOfIdNameDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ArrayOfIdNameDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ArrayOfIdNameDTO ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfIdNameDTO(struct soap *soap, ns3__ArrayOfIdNameDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfIdNameDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__ArrayOfIdNameDTO ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfIdNameDTO(struct soap *soap, const char *tag, ns3__ArrayOfIdNameDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfIdNameDTO **)soap_malloc(soap, sizeof(ns3__ArrayOfIdNameDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfIdNameDTO *)soap_instantiate_ns3__ArrayOfIdNameDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__ArrayOfIdNameDTO ** p = (ns3__ArrayOfIdNameDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ArrayOfIdNameDTO, sizeof(ns3__ArrayOfIdNameDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfUserDTO(struct soap *soap, ns3__ArrayOfUserDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ArrayOfUserDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfUserDTO(struct soap *soap, ns3__ArrayOfUserDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__ArrayOfUserDTO);
	if (soap_out_PointerTons3__ArrayOfUserDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfUserDTO(struct soap *soap, const char *tag, int id, ns3__ArrayOfUserDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ArrayOfUserDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ArrayOfUserDTO ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfUserDTO(struct soap *soap, ns3__ArrayOfUserDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfUserDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__ArrayOfUserDTO ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfUserDTO(struct soap *soap, const char *tag, ns3__ArrayOfUserDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfUserDTO **)soap_malloc(soap, sizeof(ns3__ArrayOfUserDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfUserDTO *)soap_instantiate_ns3__ArrayOfUserDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__ArrayOfUserDTO ** p = (ns3__ArrayOfUserDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ArrayOfUserDTO, sizeof(ns3__ArrayOfUserDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__LockDTO(struct soap *soap, ns3__LockDTO **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__LockDTO))
		soap_serialize_PointerTons3__LockDTO(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__LockDTO(struct soap *soap, ns3__LockDTO **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__LockDTO);
	if (soap_out_PointerToPointerTons3__LockDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__LockDTO(struct soap *soap, const char *tag, int id, ns3__LockDTO **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__LockDTO);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__LockDTO(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns3__LockDTO *** SOAP_FMAC4 soap_get_PointerToPointerTons3__LockDTO(struct soap *soap, ns3__LockDTO ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__LockDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__LockDTO *** SOAP_FMAC4 soap_in_PointerToPointerTons3__LockDTO(struct soap *soap, const char *tag, ns3__LockDTO ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__LockDTO ***)soap_malloc(soap, sizeof(ns3__LockDTO **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__LockDTO(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns3__LockDTO ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__LockDTO, sizeof(ns3__LockDTO *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__LockDTO(struct soap *soap, ns3__LockDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__LockDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__LockDTO(struct soap *soap, ns3__LockDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__LockDTO);
	if (soap_out_PointerTons3__LockDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__LockDTO(struct soap *soap, const char *tag, int id, ns3__LockDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__LockDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__LockDTO ** SOAP_FMAC4 soap_get_PointerTons3__LockDTO(struct soap *soap, ns3__LockDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__LockDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__LockDTO ** SOAP_FMAC4 soap_in_PointerTons3__LockDTO(struct soap *soap, const char *tag, ns3__LockDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__LockDTO **)soap_malloc(soap, sizeof(ns3__LockDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__LockDTO *)soap_instantiate_ns3__LockDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__LockDTO ** p = (ns3__LockDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__LockDTO, sizeof(ns3__LockDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__StatusDTO(struct soap *soap, ns3__StatusDTO **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__StatusDTO))
		soap_serialize_PointerTons3__StatusDTO(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__StatusDTO(struct soap *soap, ns3__StatusDTO **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__StatusDTO);
	if (soap_out_PointerToPointerTons3__StatusDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__StatusDTO(struct soap *soap, const char *tag, int id, ns3__StatusDTO **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__StatusDTO);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__StatusDTO(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns3__StatusDTO *** SOAP_FMAC4 soap_get_PointerToPointerTons3__StatusDTO(struct soap *soap, ns3__StatusDTO ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__StatusDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__StatusDTO *** SOAP_FMAC4 soap_in_PointerToPointerTons3__StatusDTO(struct soap *soap, const char *tag, ns3__StatusDTO ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__StatusDTO ***)soap_malloc(soap, sizeof(ns3__StatusDTO **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__StatusDTO(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns3__StatusDTO ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__StatusDTO, sizeof(ns3__StatusDTO *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__StatusDTO(struct soap *soap, ns3__StatusDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__StatusDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__StatusDTO(struct soap *soap, ns3__StatusDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__StatusDTO);
	if (soap_out_PointerTons3__StatusDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__StatusDTO(struct soap *soap, const char *tag, int id, ns3__StatusDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__StatusDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__StatusDTO ** SOAP_FMAC4 soap_get_PointerTons3__StatusDTO(struct soap *soap, ns3__StatusDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__StatusDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__StatusDTO ** SOAP_FMAC4 soap_in_PointerTons3__StatusDTO(struct soap *soap, const char *tag, ns3__StatusDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__StatusDTO **)soap_malloc(soap, sizeof(ns3__StatusDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__StatusDTO *)soap_instantiate_ns3__StatusDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__StatusDTO ** p = (ns3__StatusDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__StatusDTO, sizeof(ns3__StatusDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfStatusDTO(struct soap *soap, ns3__ArrayOfStatusDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ArrayOfStatusDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfStatusDTO(struct soap *soap, ns3__ArrayOfStatusDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__ArrayOfStatusDTO);
	if (soap_out_PointerTons3__ArrayOfStatusDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfStatusDTO(struct soap *soap, const char *tag, int id, ns3__ArrayOfStatusDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ArrayOfStatusDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ArrayOfStatusDTO ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfStatusDTO(struct soap *soap, ns3__ArrayOfStatusDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfStatusDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__ArrayOfStatusDTO ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfStatusDTO(struct soap *soap, const char *tag, ns3__ArrayOfStatusDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfStatusDTO **)soap_malloc(soap, sizeof(ns3__ArrayOfStatusDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfStatusDTO *)soap_instantiate_ns3__ArrayOfStatusDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__ArrayOfStatusDTO ** p = (ns3__ArrayOfStatusDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ArrayOfStatusDTO, sizeof(ns3__ArrayOfStatusDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__TitleStatusDTO(struct soap *soap, ns3__TitleStatusDTO **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__TitleStatusDTO))
		soap_serialize_PointerTons3__TitleStatusDTO(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__TitleStatusDTO(struct soap *soap, ns3__TitleStatusDTO **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__TitleStatusDTO);
	if (soap_out_PointerToPointerTons3__TitleStatusDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__TitleStatusDTO(struct soap *soap, const char *tag, int id, ns3__TitleStatusDTO **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__TitleStatusDTO);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__TitleStatusDTO(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns3__TitleStatusDTO *** SOAP_FMAC4 soap_get_PointerToPointerTons3__TitleStatusDTO(struct soap *soap, ns3__TitleStatusDTO ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__TitleStatusDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__TitleStatusDTO *** SOAP_FMAC4 soap_in_PointerToPointerTons3__TitleStatusDTO(struct soap *soap, const char *tag, ns3__TitleStatusDTO ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TitleStatusDTO ***)soap_malloc(soap, sizeof(ns3__TitleStatusDTO **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__TitleStatusDTO(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns3__TitleStatusDTO ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__TitleStatusDTO, sizeof(ns3__TitleStatusDTO *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TitleStatusDTO(struct soap *soap, ns3__TitleStatusDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__TitleStatusDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TitleStatusDTO(struct soap *soap, ns3__TitleStatusDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__TitleStatusDTO);
	if (soap_out_PointerTons3__TitleStatusDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TitleStatusDTO(struct soap *soap, const char *tag, int id, ns3__TitleStatusDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__TitleStatusDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__TitleStatusDTO ** SOAP_FMAC4 soap_get_PointerTons3__TitleStatusDTO(struct soap *soap, ns3__TitleStatusDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TitleStatusDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__TitleStatusDTO ** SOAP_FMAC4 soap_in_PointerTons3__TitleStatusDTO(struct soap *soap, const char *tag, ns3__TitleStatusDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TitleStatusDTO **)soap_malloc(soap, sizeof(ns3__TitleStatusDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__TitleStatusDTO *)soap_instantiate_ns3__TitleStatusDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__TitleStatusDTO ** p = (ns3__TitleStatusDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TitleStatusDTO, sizeof(ns3__TitleStatusDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ArrayOfShelveDTO(struct soap *soap, ns3__ArrayOfShelveDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ArrayOfShelveDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ArrayOfShelveDTO(struct soap *soap, ns3__ArrayOfShelveDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__ArrayOfShelveDTO);
	if (soap_out_PointerTons3__ArrayOfShelveDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ArrayOfShelveDTO(struct soap *soap, const char *tag, int id, ns3__ArrayOfShelveDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ArrayOfShelveDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ArrayOfShelveDTO ** SOAP_FMAC4 soap_get_PointerTons3__ArrayOfShelveDTO(struct soap *soap, ns3__ArrayOfShelveDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ArrayOfShelveDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__ArrayOfShelveDTO ** SOAP_FMAC4 soap_in_PointerTons3__ArrayOfShelveDTO(struct soap *soap, const char *tag, ns3__ArrayOfShelveDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ArrayOfShelveDTO **)soap_malloc(soap, sizeof(ns3__ArrayOfShelveDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ArrayOfShelveDTO *)soap_instantiate_ns3__ArrayOfShelveDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__ArrayOfShelveDTO ** p = (ns3__ArrayOfShelveDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ArrayOfShelveDTO, sizeof(ns3__ArrayOfShelveDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__EditionTitlesDTO(struct soap *soap, ns3__EditionTitlesDTO **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__EditionTitlesDTO))
		soap_serialize_PointerTons3__EditionTitlesDTO(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__EditionTitlesDTO(struct soap *soap, ns3__EditionTitlesDTO **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__EditionTitlesDTO);
	if (soap_out_PointerToPointerTons3__EditionTitlesDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__EditionTitlesDTO(struct soap *soap, const char *tag, int id, ns3__EditionTitlesDTO **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__EditionTitlesDTO);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__EditionTitlesDTO(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns3__EditionTitlesDTO *** SOAP_FMAC4 soap_get_PointerToPointerTons3__EditionTitlesDTO(struct soap *soap, ns3__EditionTitlesDTO ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__EditionTitlesDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__EditionTitlesDTO *** SOAP_FMAC4 soap_in_PointerToPointerTons3__EditionTitlesDTO(struct soap *soap, const char *tag, ns3__EditionTitlesDTO ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__EditionTitlesDTO ***)soap_malloc(soap, sizeof(ns3__EditionTitlesDTO **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__EditionTitlesDTO(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns3__EditionTitlesDTO ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__EditionTitlesDTO, sizeof(ns3__EditionTitlesDTO *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__EditionTitlesDTO(struct soap *soap, ns3__EditionTitlesDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__EditionTitlesDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__EditionTitlesDTO(struct soap *soap, ns3__EditionTitlesDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__EditionTitlesDTO);
	if (soap_out_PointerTons3__EditionTitlesDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__EditionTitlesDTO(struct soap *soap, const char *tag, int id, ns3__EditionTitlesDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__EditionTitlesDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__EditionTitlesDTO ** SOAP_FMAC4 soap_get_PointerTons3__EditionTitlesDTO(struct soap *soap, ns3__EditionTitlesDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__EditionTitlesDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__EditionTitlesDTO ** SOAP_FMAC4 soap_in_PointerTons3__EditionTitlesDTO(struct soap *soap, const char *tag, ns3__EditionTitlesDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__EditionTitlesDTO **)soap_malloc(soap, sizeof(ns3__EditionTitlesDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__EditionTitlesDTO *)soap_instantiate_ns3__EditionTitlesDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__EditionTitlesDTO ** p = (ns3__EditionTitlesDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__EditionTitlesDTO, sizeof(ns3__EditionTitlesDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__TaskDTO(struct soap *soap, ns3__TaskDTO **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__TaskDTO))
		soap_serialize_PointerTons3__TaskDTO(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__TaskDTO(struct soap *soap, ns3__TaskDTO **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__TaskDTO);
	if (soap_out_PointerToPointerTons3__TaskDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__TaskDTO(struct soap *soap, const char *tag, int id, ns3__TaskDTO **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__TaskDTO);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__TaskDTO(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns3__TaskDTO *** SOAP_FMAC4 soap_get_PointerToPointerTons3__TaskDTO(struct soap *soap, ns3__TaskDTO ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__TaskDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__TaskDTO *** SOAP_FMAC4 soap_in_PointerToPointerTons3__TaskDTO(struct soap *soap, const char *tag, ns3__TaskDTO ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TaskDTO ***)soap_malloc(soap, sizeof(ns3__TaskDTO **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__TaskDTO(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns3__TaskDTO ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__TaskDTO, sizeof(ns3__TaskDTO *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TaskDTO(struct soap *soap, ns3__TaskDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__TaskDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TaskDTO(struct soap *soap, ns3__TaskDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__TaskDTO);
	if (soap_out_PointerTons3__TaskDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TaskDTO(struct soap *soap, const char *tag, int id, ns3__TaskDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__TaskDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__TaskDTO ** SOAP_FMAC4 soap_get_PointerTons3__TaskDTO(struct soap *soap, ns3__TaskDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TaskDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__TaskDTO ** SOAP_FMAC4 soap_in_PointerTons3__TaskDTO(struct soap *soap, const char *tag, ns3__TaskDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TaskDTO **)soap_malloc(soap, sizeof(ns3__TaskDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__TaskDTO *)soap_instantiate_ns3__TaskDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__TaskDTO ** p = (ns3__TaskDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TaskDTO, sizeof(ns3__TaskDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__base64Binary);
	if (soap_out_PointerToxsd__base64Binary(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__base64Binary **)soap_malloc(soap, sizeof(xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__base64Binary *)soap_instantiate_xsd__base64Binary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__base64Binary ** p = (xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__AssetDTO(struct soap *soap, ns3__AssetDTO **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__AssetDTO))
		soap_serialize_PointerTons3__AssetDTO(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__AssetDTO(struct soap *soap, ns3__AssetDTO **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__AssetDTO);
	if (soap_out_PointerToPointerTons3__AssetDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__AssetDTO(struct soap *soap, const char *tag, int id, ns3__AssetDTO **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__AssetDTO);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__AssetDTO(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns3__AssetDTO *** SOAP_FMAC4 soap_get_PointerToPointerTons3__AssetDTO(struct soap *soap, ns3__AssetDTO ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__AssetDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__AssetDTO *** SOAP_FMAC4 soap_in_PointerToPointerTons3__AssetDTO(struct soap *soap, const char *tag, ns3__AssetDTO ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__AssetDTO ***)soap_malloc(soap, sizeof(ns3__AssetDTO **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__AssetDTO(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns3__AssetDTO ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__AssetDTO, sizeof(ns3__AssetDTO *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__AssetDTO(struct soap *soap, ns3__AssetDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__AssetDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__AssetDTO(struct soap *soap, ns3__AssetDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__AssetDTO);
	if (soap_out_PointerTons3__AssetDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__AssetDTO(struct soap *soap, const char *tag, int id, ns3__AssetDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__AssetDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__AssetDTO ** SOAP_FMAC4 soap_get_PointerTons3__AssetDTO(struct soap *soap, ns3__AssetDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__AssetDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__AssetDTO ** SOAP_FMAC4 soap_in_PointerTons3__AssetDTO(struct soap *soap, const char *tag, ns3__AssetDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__AssetDTO **)soap_malloc(soap, sizeof(ns3__AssetDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__AssetDTO *)soap_instantiate_ns3__AssetDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__AssetDTO ** p = (ns3__AssetDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__AssetDTO, sizeof(ns3__AssetDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__guid(struct soap *soap, wchar_t **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__guid))
		soap_serialize_ns4__guid(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__guid(struct soap *soap, wchar_t **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__guid);
	if (soap_out_PointerTons4__guid(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__guid(struct soap *soap, const char *tag, int id, wchar_t **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__guid);
	if (id < 0)
		return soap->error;
	return soap_out_ns4__guid(soap, tag, id, *a, type);
}

SOAP_FMAC3 wchar_t *** SOAP_FMAC4 soap_get_PointerTons4__guid(struct soap *soap, wchar_t ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__guid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 wchar_t *** SOAP_FMAC4 soap_in_PointerTons4__guid(struct soap *soap, const char *tag, wchar_t ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wchar_t ***)soap_malloc(soap, sizeof(wchar_t **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns4__guid(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (wchar_t ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__guid, sizeof(wchar_t *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__VersionInfo(struct soap *soap, ns3__VersionInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__VersionInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__VersionInfo(struct soap *soap, ns3__VersionInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__VersionInfo);
	if (soap_out_PointerTons3__VersionInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__VersionInfo(struct soap *soap, const char *tag, int id, ns3__VersionInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__VersionInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__VersionInfo ** SOAP_FMAC4 soap_get_PointerTons3__VersionInfo(struct soap *soap, ns3__VersionInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__VersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__VersionInfo ** SOAP_FMAC4 soap_in_PointerTons3__VersionInfo(struct soap *soap, const char *tag, ns3__VersionInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__VersionInfo **)soap_malloc(soap, sizeof(ns3__VersionInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__VersionInfo *)soap_instantiate_ns3__VersionInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__VersionInfo ** p = (ns3__VersionInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__VersionInfo, sizeof(ns3__VersionInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__ShelveDTO(struct soap *soap, ns3__ShelveDTO **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__ShelveDTO))
		soap_serialize_PointerTons3__ShelveDTO(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__ShelveDTO(struct soap *soap, ns3__ShelveDTO **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__ShelveDTO);
	if (soap_out_PointerToPointerTons3__ShelveDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__ShelveDTO(struct soap *soap, const char *tag, int id, ns3__ShelveDTO **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__ShelveDTO);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__ShelveDTO(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns3__ShelveDTO *** SOAP_FMAC4 soap_get_PointerToPointerTons3__ShelveDTO(struct soap *soap, ns3__ShelveDTO ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__ShelveDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__ShelveDTO *** SOAP_FMAC4 soap_in_PointerToPointerTons3__ShelveDTO(struct soap *soap, const char *tag, ns3__ShelveDTO ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ShelveDTO ***)soap_malloc(soap, sizeof(ns3__ShelveDTO **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__ShelveDTO(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns3__ShelveDTO ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__ShelveDTO, sizeof(ns3__ShelveDTO *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__ShelveDTO(struct soap *soap, ns3__ShelveDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__ShelveDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__ShelveDTO(struct soap *soap, ns3__ShelveDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__ShelveDTO);
	if (soap_out_PointerTons3__ShelveDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__ShelveDTO(struct soap *soap, const char *tag, int id, ns3__ShelveDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__ShelveDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__ShelveDTO ** SOAP_FMAC4 soap_get_PointerTons3__ShelveDTO(struct soap *soap, ns3__ShelveDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__ShelveDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__ShelveDTO ** SOAP_FMAC4 soap_in_PointerTons3__ShelveDTO(struct soap *soap, const char *tag, ns3__ShelveDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__ShelveDTO **)soap_malloc(soap, sizeof(ns3__ShelveDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__ShelveDTO *)soap_instantiate_ns3__ShelveDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__ShelveDTO ** p = (ns3__ShelveDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__ShelveDTO, sizeof(ns3__ShelveDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstring(struct soap *soap, wchar_t **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wstring))
		soap_serialize_wstring(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstring(struct soap *soap, wchar_t **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowstring);
	if (soap_out_PointerTowstring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstring(struct soap *soap, const char *tag, int id, wchar_t **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstring);
	if (id < 0)
		return soap->error;
	return soap_out_wstring(soap, tag, id, *a, type);
}

SOAP_FMAC3 wchar_t *** SOAP_FMAC4 soap_get_PointerTowstring(struct soap *soap, wchar_t ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 wchar_t *** SOAP_FMAC4 soap_in_PointerTowstring(struct soap *soap, const char *tag, wchar_t ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wchar_t ***)soap_malloc(soap, sizeof(wchar_t **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstring(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (wchar_t ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstring, sizeof(wchar_t *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__CommentDTO(struct soap *soap, ns3__CommentDTO **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__CommentDTO))
		soap_serialize_PointerTons3__CommentDTO(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__CommentDTO(struct soap *soap, ns3__CommentDTO **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__CommentDTO);
	if (soap_out_PointerToPointerTons3__CommentDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__CommentDTO(struct soap *soap, const char *tag, int id, ns3__CommentDTO **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__CommentDTO);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__CommentDTO(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns3__CommentDTO *** SOAP_FMAC4 soap_get_PointerToPointerTons3__CommentDTO(struct soap *soap, ns3__CommentDTO ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__CommentDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__CommentDTO *** SOAP_FMAC4 soap_in_PointerToPointerTons3__CommentDTO(struct soap *soap, const char *tag, ns3__CommentDTO ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__CommentDTO ***)soap_malloc(soap, sizeof(ns3__CommentDTO **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__CommentDTO(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns3__CommentDTO ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__CommentDTO, sizeof(ns3__CommentDTO *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__CommentDTO(struct soap *soap, ns3__CommentDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__CommentDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__CommentDTO(struct soap *soap, ns3__CommentDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__CommentDTO);
	if (soap_out_PointerTons3__CommentDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__CommentDTO(struct soap *soap, const char *tag, int id, ns3__CommentDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__CommentDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__CommentDTO ** SOAP_FMAC4 soap_get_PointerTons3__CommentDTO(struct soap *soap, ns3__CommentDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__CommentDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__CommentDTO ** SOAP_FMAC4 soap_in_PointerTons3__CommentDTO(struct soap *soap, const char *tag, ns3__CommentDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__CommentDTO **)soap_malloc(soap, sizeof(ns3__CommentDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__CommentDTO *)soap_instantiate_ns3__CommentDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__CommentDTO ** p = (ns3__CommentDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__CommentDTO, sizeof(ns3__CommentDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__TitleDTO(struct soap *soap, ns3__TitleDTO **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__TitleDTO))
		soap_serialize_PointerTons3__TitleDTO(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__TitleDTO(struct soap *soap, ns3__TitleDTO **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__TitleDTO);
	if (soap_out_PointerToPointerTons3__TitleDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__TitleDTO(struct soap *soap, const char *tag, int id, ns3__TitleDTO **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__TitleDTO);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__TitleDTO(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns3__TitleDTO *** SOAP_FMAC4 soap_get_PointerToPointerTons3__TitleDTO(struct soap *soap, ns3__TitleDTO ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__TitleDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__TitleDTO *** SOAP_FMAC4 soap_in_PointerToPointerTons3__TitleDTO(struct soap *soap, const char *tag, ns3__TitleDTO ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TitleDTO ***)soap_malloc(soap, sizeof(ns3__TitleDTO **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__TitleDTO(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns3__TitleDTO ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__TitleDTO, sizeof(ns3__TitleDTO *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TitleDTO(struct soap *soap, ns3__TitleDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__TitleDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TitleDTO(struct soap *soap, ns3__TitleDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__TitleDTO);
	if (soap_out_PointerTons3__TitleDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TitleDTO(struct soap *soap, const char *tag, int id, ns3__TitleDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__TitleDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__TitleDTO ** SOAP_FMAC4 soap_get_PointerTons3__TitleDTO(struct soap *soap, ns3__TitleDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TitleDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__TitleDTO ** SOAP_FMAC4 soap_in_PointerTons3__TitleDTO(struct soap *soap, const char *tag, ns3__TitleDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TitleDTO **)soap_malloc(soap, sizeof(ns3__TitleDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__TitleDTO *)soap_instantiate_ns3__TitleDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__TitleDTO ** p = (ns3__TitleDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TitleDTO, sizeof(ns3__TitleDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TaskUpdateInfo(struct soap *soap, ns3__TaskUpdateInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__TaskUpdateInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TaskUpdateInfo(struct soap *soap, ns3__TaskUpdateInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__TaskUpdateInfo);
	if (soap_out_PointerTons3__TaskUpdateInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TaskUpdateInfo(struct soap *soap, const char *tag, int id, ns3__TaskUpdateInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__TaskUpdateInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__TaskUpdateInfo ** SOAP_FMAC4 soap_get_PointerTons3__TaskUpdateInfo(struct soap *soap, ns3__TaskUpdateInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TaskUpdateInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__TaskUpdateInfo ** SOAP_FMAC4 soap_in_PointerTons3__TaskUpdateInfo(struct soap *soap, const char *tag, ns3__TaskUpdateInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TaskUpdateInfo **)soap_malloc(soap, sizeof(ns3__TaskUpdateInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__TaskUpdateInfo *)soap_instantiate_ns3__TaskUpdateInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__TaskUpdateInfo ** p = (ns3__TaskUpdateInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TaskUpdateInfo, sizeof(ns3__TaskUpdateInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__IdNameDTO(struct soap *soap, ns3__IdNameDTO **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__IdNameDTO))
		soap_serialize_PointerTons3__IdNameDTO(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__IdNameDTO(struct soap *soap, ns3__IdNameDTO **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__IdNameDTO);
	if (soap_out_PointerToPointerTons3__IdNameDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__IdNameDTO(struct soap *soap, const char *tag, int id, ns3__IdNameDTO **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__IdNameDTO);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__IdNameDTO(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns3__IdNameDTO *** SOAP_FMAC4 soap_get_PointerToPointerTons3__IdNameDTO(struct soap *soap, ns3__IdNameDTO ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__IdNameDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__IdNameDTO *** SOAP_FMAC4 soap_in_PointerToPointerTons3__IdNameDTO(struct soap *soap, const char *tag, ns3__IdNameDTO ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__IdNameDTO ***)soap_malloc(soap, sizeof(ns3__IdNameDTO **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__IdNameDTO(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns3__IdNameDTO ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__IdNameDTO, sizeof(ns3__IdNameDTO *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__IdNameDTO(struct soap *soap, ns3__IdNameDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__IdNameDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__IdNameDTO(struct soap *soap, ns3__IdNameDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__IdNameDTO);
	if (soap_out_PointerTons3__IdNameDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__IdNameDTO(struct soap *soap, const char *tag, int id, ns3__IdNameDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__IdNameDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__IdNameDTO ** SOAP_FMAC4 soap_get_PointerTons3__IdNameDTO(struct soap *soap, ns3__IdNameDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__IdNameDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__IdNameDTO ** SOAP_FMAC4 soap_in_PointerTons3__IdNameDTO(struct soap *soap, const char *tag, ns3__IdNameDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__IdNameDTO **)soap_malloc(soap, sizeof(ns3__IdNameDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__IdNameDTO *)soap_instantiate_ns3__IdNameDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__IdNameDTO ** p = (ns3__IdNameDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__IdNameDTO, sizeof(ns3__IdNameDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons3__UserDTO(struct soap *soap, ns3__UserDTO **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons3__UserDTO))
		soap_serialize_PointerTons3__UserDTO(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons3__UserDTO(struct soap *soap, ns3__UserDTO **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons3__UserDTO);
	if (soap_out_PointerToPointerTons3__UserDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons3__UserDTO(struct soap *soap, const char *tag, int id, ns3__UserDTO **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons3__UserDTO);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons3__UserDTO(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns3__UserDTO *** SOAP_FMAC4 soap_get_PointerToPointerTons3__UserDTO(struct soap *soap, ns3__UserDTO ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons3__UserDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__UserDTO *** SOAP_FMAC4 soap_in_PointerToPointerTons3__UserDTO(struct soap *soap, const char *tag, ns3__UserDTO ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__UserDTO ***)soap_malloc(soap, sizeof(ns3__UserDTO **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons3__UserDTO(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns3__UserDTO ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons3__UserDTO, sizeof(ns3__UserDTO *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__UserDTO(struct soap *soap, ns3__UserDTO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__UserDTO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__UserDTO(struct soap *soap, ns3__UserDTO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__UserDTO);
	if (soap_out_PointerTons3__UserDTO(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__UserDTO(struct soap *soap, const char *tag, int id, ns3__UserDTO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__UserDTO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__UserDTO ** SOAP_FMAC4 soap_get_PointerTons3__UserDTO(struct soap *soap, ns3__UserDTO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__UserDTO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__UserDTO ** SOAP_FMAC4 soap_in_PointerTons3__UserDTO(struct soap *soap, const char *tag, ns3__UserDTO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__UserDTO **)soap_malloc(soap, sizeof(ns3__UserDTO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__UserDTO *)soap_instantiate_ns3__UserDTO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__UserDTO ** p = (ns3__UserDTO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__UserDTO, sizeof(ns3__UserDTO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__guid(struct soap *soap, wchar_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns4__guid);
	if (soap_out_ns4__guid(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__guid(struct soap *soap, const char *tag, int id, wchar_t *const*a, const char *type)
{
	return soap_outwstring(soap, tag, id, a, type, SOAP_TYPE_ns4__guid);
}

SOAP_FMAC3 wchar_t ** SOAP_FMAC4 soap_get_ns4__guid(struct soap *soap, wchar_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__guid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 wchar_t * * SOAP_FMAC4 soap_in_ns4__guid(struct soap *soap, const char *tag, wchar_t **a, const char *type)
{	wchar_t **p;
	p = soap_inwstring(soap, tag, a, type, SOAP_TYPE_ns4__guid, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstring(struct soap *soap, wchar_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_wstring);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstring(struct soap *soap, wchar_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wstring);
	if (soap_out_wstring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstring(struct soap *soap, const char *tag, int id, wchar_t *const*a, const char *type)
{
	return soap_outwstring(soap, tag, id, a, type, SOAP_TYPE_wstring);
}

SOAP_FMAC3 wchar_t ** SOAP_FMAC4 soap_get_wstring(struct soap *soap, wchar_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 wchar_t * * SOAP_FMAC4 soap_in_wstring(struct soap *soap, const char *tag, wchar_t **a, const char *type)
{	wchar_t **p;
	p = soap_inwstring(soap, tag, a, type, SOAP_TYPE_wstring, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrp__path(struct soap *soap, struct wsrp__path_USCOREt *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrp__path))
		soap_serialize__wsrp__path(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrp__path(struct soap *soap, struct wsrp__path_USCOREt *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsrp__path);
	if (soap_out_PointerTo_wsrp__path(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrp__path(struct soap *soap, const char *tag, int id, struct wsrp__path_USCOREt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrp__path);
	if (id < 0)
		return soap->error;
	return soap_out__wsrp__path(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrp__path_USCOREt ** SOAP_FMAC4 soap_get_PointerTo_wsrp__path(struct soap *soap, struct wsrp__path_USCOREt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrp__path(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__path_USCOREt ** SOAP_FMAC4 soap_in_PointerTo_wsrp__path(struct soap *soap, const char *tag, struct wsrp__path_USCOREt **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrp__path_USCOREt **)soap_malloc(soap, sizeof(struct wsrp__path_USCOREt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrp__path(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrp__path_USCOREt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrp__path, sizeof(struct wsrp__path_USCOREt), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Security))
		soap_serialize__wsse__Security(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Security);
	if (soap_out_PointerTo_wsse__Security(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Security(struct soap *soap, const char *tag, int id, struct _wsse__Security *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Security);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Security(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_get_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_in_PointerTo_wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Security **)soap_malloc(soap, sizeof(struct _wsse__Security *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Security(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureType))
		soap_serialize_ds__SignatureType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignatureType);
	if (soap_out_PointerTods__SignatureType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureType(struct soap *soap, const char *tag, int id, struct ds__SignatureType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_get_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_in_PointerTods__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureType **)soap_malloc(soap, sizeof(struct ds__SignatureType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__BinarySecurityToken))
		soap_serialize__wsse__BinarySecurityToken(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__BinarySecurityToken);
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, struct _wsse__BinarySecurityToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__BinarySecurityToken);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__BinarySecurityToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__BinarySecurityToken **)soap_malloc(soap, sizeof(struct _wsse__BinarySecurityToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__BinarySecurityToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__BinarySecurityToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__UsernameToken))
		soap_serialize__wsse__UsernameToken(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__UsernameToken);
	if (soap_out_PointerTo_wsse__UsernameToken(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, int id, struct _wsse__UsernameToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__UsernameToken);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__UsernameToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__UsernameToken **)soap_malloc(soap, sizeof(struct _wsse__UsernameToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__UsernameToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsu__Timestamp))
		soap_serialize__wsu__Timestamp(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsu__Timestamp);
	if (soap_out_PointerTo_wsu__Timestamp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, int id, struct _wsu__Timestamp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsu__Timestamp);
	if (id < 0)
		return soap->error;
	return soap_out__wsu__Timestamp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_get_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_in_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsu__Timestamp **)soap_malloc(soap, sizeof(struct _wsu__Timestamp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsu__Timestamp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509IssuerSerialType))
		soap_serialize_ds__X509IssuerSerialType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__X509IssuerSerialType);
	if (soap_out_PointerTods__X509IssuerSerialType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, int id, struct ds__X509IssuerSerialType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509IssuerSerialType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509IssuerSerialType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_get_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_in_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509IssuerSerialType **)soap_malloc(soap, sizeof(struct ds__X509IssuerSerialType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509IssuerSerialType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RSAKeyValueType))
		soap_serialize_ds__RSAKeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__RSAKeyValueType);
	if (soap_out_PointerTods__RSAKeyValueType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__RSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RSAKeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__RSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DSAKeyValueType))
		soap_serialize_ds__DSAKeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__DSAKeyValueType);
	if (soap_out_PointerTods__DSAKeyValueType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__DSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DSAKeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__DSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformType))
		soap_serialize_ds__TransformType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__TransformType);
	if (soap_out_PointerTods__TransformType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformType(struct soap *soap, const char *tag, int id, struct ds__TransformType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_get_PointerTods__TransformType(struct soap *soap, struct ds__TransformType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_in_PointerTods__TransformType(struct soap *soap, const char *tag, struct ds__TransformType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformType **)soap_malloc(soap, sizeof(struct ds__TransformType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DigestMethodType))
		soap_serialize_ds__DigestMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__DigestMethodType);
	if (soap_out_PointerTods__DigestMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DigestMethodType(struct soap *soap, const char *tag, int id, struct ds__DigestMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DigestMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DigestMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_get_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_in_PointerTods__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DigestMethodType **)soap_malloc(soap, sizeof(struct ds__DigestMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DigestMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformsType))
		soap_serialize_ds__TransformsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__TransformsType);
	if (soap_out_PointerTods__TransformsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformsType(struct soap *soap, const char *tag, int id, struct ds__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformsType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_get_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_in_PointerTods__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformsType **)soap_malloc(soap, sizeof(struct ds__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTods__ReferenceType))
		soap_serialize_PointerTods__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTods__ReferenceType);
	if (soap_out_PointerToPointerTods__ReferenceType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTods__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTods__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_get_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_in_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType ***)soap_malloc(soap, sizeof(struct ds__ReferenceType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTods__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTods__ReferenceType, sizeof(struct ds__ReferenceType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__ReferenceType))
		soap_serialize_ds__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__ReferenceType);
	if (soap_out_PointerTods__ReferenceType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_get_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_in_PointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType **)soap_malloc(soap, sizeof(struct ds__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureMethodType))
		soap_serialize_ds__SignatureMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignatureMethodType);
	if (soap_out_PointerTods__SignatureMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, int id, struct ds__SignatureMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_get_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_in_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureMethodType **)soap_malloc(soap, sizeof(struct ds__SignatureMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__CanonicalizationMethodType))
		soap_serialize_ds__CanonicalizationMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__CanonicalizationMethodType);
	if (soap_out_PointerTods__CanonicalizationMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, struct ds__CanonicalizationMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__CanonicalizationMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__CanonicalizationMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_get_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_in_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__CanonicalizationMethodType **)soap_malloc(soap, sizeof(struct ds__CanonicalizationMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__CanonicalizationMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__SecurityTokenReference))
		soap_serialize__wsse__SecurityTokenReference(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__SecurityTokenReference);
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, struct _wsse__SecurityTokenReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__SecurityTokenReference);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__SecurityTokenReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_get_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_in_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__SecurityTokenReference **)soap_malloc(soap, sizeof(struct _wsse__SecurityTokenReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__SecurityTokenReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509DataType))
		soap_serialize_ds__X509DataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__X509DataType);
	if (soap_out_PointerTods__X509DataType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509DataType(struct soap *soap, const char *tag, int id, struct ds__X509DataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509DataType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509DataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_get_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_in_PointerTods__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509DataType **)soap_malloc(soap, sizeof(struct ds__X509DataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509DataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RetrievalMethodType))
		soap_serialize_ds__RetrievalMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__RetrievalMethodType);
	if (soap_out_PointerTods__RetrievalMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, int id, struct ds__RetrievalMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RetrievalMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RetrievalMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_get_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_in_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RetrievalMethodType **)soap_malloc(soap, sizeof(struct ds__RetrievalMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RetrievalMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyValueType))
		soap_serialize_ds__KeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__KeyValueType);
	if (soap_out_PointerTods__KeyValueType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyValueType(struct soap *soap, const char *tag, int id, struct ds__KeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_get_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_in_PointerTods__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyValueType **)soap_malloc(soap, sizeof(struct ds__KeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__c14n__InclusiveNamespaces))
		soap_serialize__c14n__InclusiveNamespaces(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces);
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, struct _c14n__InclusiveNamespaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__c14n__InclusiveNamespaces);
	if (id < 0)
		return soap->error;
	return soap_out__c14n__InclusiveNamespaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_get_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_in_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _c14n__InclusiveNamespaces **)soap_malloc(soap, sizeof(struct _c14n__InclusiveNamespaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__c14n__InclusiveNamespaces(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyInfoType))
		soap_serialize_ds__KeyInfoType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__KeyInfoType);
	if (soap_out_PointerTods__KeyInfoType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyInfoType(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyInfoType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTods__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignedInfoType))
		soap_serialize_ds__SignedInfoType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignedInfoType);
	if (soap_out_PointerTods__SignedInfoType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignedInfoType(struct soap *soap, const char *tag, int id, struct ds__SignedInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignedInfoType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignedInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_get_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_in_PointerTods__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignedInfoType **)soap_malloc(soap, sizeof(struct ds__SignedInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignedInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Embedded))
		soap_serialize__wsse__Embedded(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Embedded);
	if (soap_out_PointerTo_wsse__Embedded(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, int id, struct _wsse__Embedded *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Embedded);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Embedded(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_get_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_in_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Embedded **)soap_malloc(soap, sizeof(struct _wsse__Embedded *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Embedded(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__KeyIdentifier))
		soap_serialize__wsse__KeyIdentifier(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__KeyIdentifier);
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, struct _wsse__KeyIdentifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__KeyIdentifier);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__KeyIdentifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_get_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_in_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__KeyIdentifier **)soap_malloc(soap, sizeof(struct _wsse__KeyIdentifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__KeyIdentifier(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__KeyIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Reference))
		soap_serialize__wsse__Reference(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Reference);
	if (soap_out_PointerTo_wsse__Reference(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Reference(struct soap *soap, const char *tag, int id, struct _wsse__Reference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Reference);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Reference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_get_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_in_PointerTo_wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Reference **)soap_malloc(soap, sizeof(struct _wsse__Reference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Reference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Password))
		soap_serialize__wsse__Password(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Password);
	if (soap_out_PointerTo_wsse__Password(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Password(struct soap *soap, const char *tag, int id, struct _wsse__Password *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Password);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Password(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_get_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_in_PointerTo_wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Password **)soap_malloc(soap, sizeof(struct _wsse__Password *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Password(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Password **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__FaultTo))
		soap_serialize__wsa__FaultTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa__FaultTo);
	if (soap_out_PointerTo_wsa__FaultTo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__FaultTo(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__FaultTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__FaultTo(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__FaultTo, sizeof(struct wsa__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__ReplyTo))
		soap_serialize__wsa__ReplyTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa__ReplyTo);
	if (soap_out_PointerTo_wsa__ReplyTo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__ReplyTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__ReplyTo(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__ReplyTo, sizeof(struct wsa__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__From))
		soap_serialize__wsa__From(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa__From);
	if (soap_out_PointerTo_wsa__From(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__From(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__From);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__From(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__From, sizeof(struct wsa__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__Relationship *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__RelatesTo))
		soap_serialize__wsa__RelatesTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__Relationship *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa__RelatesTo);
	if (soap_out_PointerTo_wsa__RelatesTo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa__Relationship *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__RelatesTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__Relationship ** SOAP_FMAC4 soap_get_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__Relationship **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__Relationship ** SOAP_FMAC4 soap_in_PointerTo_wsa__RelatesTo(struct soap *soap, const char *tag, struct wsa__Relationship **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__Relationship **)soap_malloc(soap, sizeof(struct wsa__Relationship *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__Relationship **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__RelatesTo, sizeof(struct wsa__Relationship), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ServiceNameType))
		soap_serialize_wsa__ServiceNameType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa__ServiceNameType);
	if (soap_out_PointerTowsa__ServiceNameType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__ServiceNameType(struct soap *soap, const char *tag, int id, struct wsa__ServiceNameType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ServiceNameType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__ServiceNameType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__ServiceNameType ** SOAP_FMAC4 soap_get_PointerTowsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ServiceNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__ServiceNameType ** SOAP_FMAC4 soap_in_PointerTowsa__ServiceNameType(struct soap *soap, const char *tag, struct wsa__ServiceNameType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__ServiceNameType **)soap_malloc(soap, sizeof(struct wsa__ServiceNameType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa__ServiceNameType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__ServiceNameType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ServiceNameType, sizeof(struct wsa__ServiceNameType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_QName(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__QName))
		soap_serialize__QName(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_QName(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_QName);
	if (soap_out_PointerTo_QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_QName(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__QName);
	if (id < 0)
		return soap->error;
	return soap_out__QName(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTo_QName(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTo_QName(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__QName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__QName, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ReferenceParametersType))
		soap_serialize_wsa__ReferenceParametersType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa__ReferenceParametersType);
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ReferenceParametersType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa__ReferenceParametersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ReferencePropertiesType))
		soap_serialize_wsa__ReferencePropertiesType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa__ReferencePropertiesType);
	if (soap_out_PointerTowsa__ReferencePropertiesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__ReferencePropertiesType(struct soap *soap, const char *tag, int id, struct wsa__ReferencePropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ReferencePropertiesType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__ReferencePropertiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType ** SOAP_FMAC4 soap_get_PointerTowsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ReferencePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType ** SOAP_FMAC4 soap_in_PointerTowsa__ReferencePropertiesType(struct soap *soap, const char *tag, struct wsa__ReferencePropertiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__ReferencePropertiesType **)soap_malloc(soap, sizeof(struct wsa__ReferencePropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa__ReferencePropertiesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferencePropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrp__found_USCOREt(struct soap *soap, struct wsrp__found_USCOREt *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrp__found_USCOREt))
		soap_serialize_wsrp__found_USCOREt(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrp__found_USCOREt(struct soap *soap, struct wsrp__found_USCOREt *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrp__found_USCOREt);
	if (soap_out_PointerTowsrp__found_USCOREt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrp__found_USCOREt(struct soap *soap, const char *tag, int id, struct wsrp__found_USCOREt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrp__found_USCOREt);
	if (id < 0)
		return soap->error;
	return soap_out_wsrp__found_USCOREt(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrp__found_USCOREt ** SOAP_FMAC4 soap_get_PointerTowsrp__found_USCOREt(struct soap *soap, struct wsrp__found_USCOREt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrp__found_USCOREt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__found_USCOREt ** SOAP_FMAC4 soap_in_PointerTowsrp__found_USCOREt(struct soap *soap, const char *tag, struct wsrp__found_USCOREt **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrp__found_USCOREt **)soap_malloc(soap, sizeof(struct wsrp__found_USCOREt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrp__found_USCOREt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrp__found_USCOREt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrp__found_USCOREt, sizeof(struct wsrp__found_USCOREt), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTowsrp__via_USCOREt(struct soap *soap, struct wsrp__via_USCOREt **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTowsrp__via_USCOREt))
		soap_serialize_PointerTowsrp__via_USCOREt(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTowsrp__via_USCOREt(struct soap *soap, struct wsrp__via_USCOREt **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTowsrp__via_USCOREt);
	if (soap_out_PointerToPointerTowsrp__via_USCOREt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTowsrp__via_USCOREt(struct soap *soap, const char *tag, int id, struct wsrp__via_USCOREt **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTowsrp__via_USCOREt);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTowsrp__via_USCOREt(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrp__via_USCOREt *** SOAP_FMAC4 soap_get_PointerToPointerTowsrp__via_USCOREt(struct soap *soap, struct wsrp__via_USCOREt ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTowsrp__via_USCOREt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__via_USCOREt *** SOAP_FMAC4 soap_in_PointerToPointerTowsrp__via_USCOREt(struct soap *soap, const char *tag, struct wsrp__via_USCOREt ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrp__via_USCOREt ***)soap_malloc(soap, sizeof(struct wsrp__via_USCOREt **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTowsrp__via_USCOREt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrp__via_USCOREt ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTowsrp__via_USCOREt, sizeof(struct wsrp__via_USCOREt *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrp__via_USCOREt(struct soap *soap, struct wsrp__via_USCOREt *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrp__via_USCOREt))
		soap_serialize_wsrp__via_USCOREt(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrp__via_USCOREt(struct soap *soap, struct wsrp__via_USCOREt *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrp__via_USCOREt);
	if (soap_out_PointerTowsrp__via_USCOREt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrp__via_USCOREt(struct soap *soap, const char *tag, int id, struct wsrp__via_USCOREt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrp__via_USCOREt);
	if (id < 0)
		return soap->error;
	return soap_out_wsrp__via_USCOREt(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrp__via_USCOREt ** SOAP_FMAC4 soap_get_PointerTowsrp__via_USCOREt(struct soap *soap, struct wsrp__via_USCOREt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrp__via_USCOREt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__via_USCOREt ** SOAP_FMAC4 soap_in_PointerTowsrp__via_USCOREt(struct soap *soap, const char *tag, struct wsrp__via_USCOREt **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrp__via_USCOREt **)soap_malloc(soap, sizeof(struct wsrp__via_USCOREt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrp__via_USCOREt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrp__via_USCOREt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrp__via_USCOREt, sizeof(struct wsrp__via_USCOREt), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrp__fault_USCOREt(struct soap *soap, struct wsrp__fault_USCOREt *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrp__fault_USCOREt))
		soap_serialize_wsrp__fault_USCOREt(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrp__fault_USCOREt(struct soap *soap, struct wsrp__fault_USCOREt *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrp__fault_USCOREt);
	if (soap_out_PointerTowsrp__fault_USCOREt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrp__fault_USCOREt(struct soap *soap, const char *tag, int id, struct wsrp__fault_USCOREt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrp__fault_USCOREt);
	if (id < 0)
		return soap->error;
	return soap_out_wsrp__fault_USCOREt(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrp__fault_USCOREt ** SOAP_FMAC4 soap_get_PointerTowsrp__fault_USCOREt(struct soap *soap, struct wsrp__fault_USCOREt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrp__fault_USCOREt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__fault_USCOREt ** SOAP_FMAC4 soap_in_PointerTowsrp__fault_USCOREt(struct soap *soap, const char *tag, struct wsrp__fault_USCOREt **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrp__fault_USCOREt **)soap_malloc(soap, sizeof(struct wsrp__fault_USCOREt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrp__fault_USCOREt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrp__fault_USCOREt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrp__fault_USCOREt, sizeof(struct wsrp__fault_USCOREt), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrp__rev_USCOREt(struct soap *soap, struct wsrp__rev_USCOREt *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrp__rev_USCOREt))
		soap_serialize_wsrp__rev_USCOREt(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrp__rev_USCOREt(struct soap *soap, struct wsrp__rev_USCOREt *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrp__rev_USCOREt);
	if (soap_out_PointerTowsrp__rev_USCOREt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrp__rev_USCOREt(struct soap *soap, const char *tag, int id, struct wsrp__rev_USCOREt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrp__rev_USCOREt);
	if (id < 0)
		return soap->error;
	return soap_out_wsrp__rev_USCOREt(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrp__rev_USCOREt ** SOAP_FMAC4 soap_get_PointerTowsrp__rev_USCOREt(struct soap *soap, struct wsrp__rev_USCOREt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrp__rev_USCOREt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__rev_USCOREt ** SOAP_FMAC4 soap_in_PointerTowsrp__rev_USCOREt(struct soap *soap, const char *tag, struct wsrp__rev_USCOREt **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrp__rev_USCOREt **)soap_malloc(soap, sizeof(struct wsrp__rev_USCOREt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrp__rev_USCOREt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrp__rev_USCOREt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrp__rev_USCOREt, sizeof(struct wsrp__rev_USCOREt), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrp__fwd_USCOREt(struct soap *soap, struct wsrp__fwd_USCOREt *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrp__fwd_USCOREt))
		soap_serialize_wsrp__fwd_USCOREt(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrp__fwd_USCOREt(struct soap *soap, struct wsrp__fwd_USCOREt *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrp__fwd_USCOREt);
	if (soap_out_PointerTowsrp__fwd_USCOREt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrp__fwd_USCOREt(struct soap *soap, const char *tag, int id, struct wsrp__fwd_USCOREt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrp__fwd_USCOREt);
	if (id < 0)
		return soap->error;
	return soap_out_wsrp__fwd_USCOREt(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrp__fwd_USCOREt ** SOAP_FMAC4 soap_get_PointerTowsrp__fwd_USCOREt(struct soap *soap, struct wsrp__fwd_USCOREt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrp__fwd_USCOREt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct wsrp__fwd_USCOREt ** SOAP_FMAC4 soap_in_PointerTowsrp__fwd_USCOREt(struct soap *soap, const char *tag, struct wsrp__fwd_USCOREt **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrp__fwd_USCOREt **)soap_malloc(soap, sizeof(struct wsrp__fwd_USCOREt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrp__fwd_USCOREt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrp__fwd_USCOREt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrp__fwd_USCOREt, sizeof(struct wsrp__fwd_USCOREt), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
